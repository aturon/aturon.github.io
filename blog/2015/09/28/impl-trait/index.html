<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="UTF-8">
  <link href="http://gmpg.org/xfn/11" rel="profile">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>
    
      Resurrecting impl Trait &middot; Aaron Turon
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/blog/styles.css">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/blog/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/blog/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/atom+xml" title="Aaron Turon" href="/blog/atom.xml">
</head>


  <body>

    <div class="container content">
      <header class="masthead">
        <h3 class="masthead-title">
          <a href="/blog/" title="Home">Aaron Turon</a>
          <small></small>

          
          &nbsp;&nbsp;&nbsp;
          <small><a href="/blog/archive">Archive</a></small>
          
          &nbsp;&nbsp;&nbsp;
          <small><a href="/blog/atom.xml">Feed</a></small>
          
        </h3>
      </header>

      <main>
        <article class="post">
  <h1 class="post-title">Resurrecting impl Trait</h1>
  <time datetime="2015-09-28T00:00:00-07:00" class="post-date">28 Sep 2015</time>
  <p><strong>TL;DR</strong>: since before Rust 1.0, we&rsquo;ve wanted to be able to return an unboxed
closure or avoid spelling out huge iterator types. This blog post revives the
old <code>impl Trait</code> proposal, and discusses the broad tradeoffs between two
different ways of carrying it out.</p>

<p><strong>Heads up</strong>: I&rsquo;m going to gloss over some details in this post, in the interest
of getting across the high-level situation as I see it. Of course, any actual
proposal will need to address the questions that I skip over.</p>

<p><strong>Update</strong>: I removed the &ldquo;elision&rdquo; terminology, which was more confusing than
helpful. I also now mention some implementation issues for the return type
inference proposal. And I&rsquo;ve toned down my preference in the wrapup; I&rsquo;m
becoming less certain :)</p>

<h2 id="the-original-proposal">The original proposal</h2>

<p>This post is about a topic near-and-dear to me &ndash; my
<a href="https://github.com/rust-lang/rfcs/pull/105">first Rust RFC</a>! &ndash; which is known
as the &ldquo;<code>impl Trait</code>&rdquo; proposal. The RFC termed these &ldquo;unboxed abstract types&rdquo;,
and it&rsquo;s easiest to start with the motivation given there:</p>

<blockquote>
<p>In today&rsquo;s Rust, you can write a function signature like</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="n">consume_iter_static</span><span class="o">&lt;</span><span class="n">I</span><span class="o">:</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">iter</span><span class="o">:</span> <span class="n">I</span><span class="p">)</span>
<span class="k">fn</span> <span class="n">consume_iter_dynamic</span><span class="p">(</span><span class="n">iter</span><span class="o">:</span> <span class="n">Box</span><span class="o">&lt;</span><span class="nb">Iterator</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;&gt;</span><span class="p">)</span>
</code></pre></div>
<p>In both cases, the function does not depend on the exact type of the argument.
The type is held &ldquo;abstract&rdquo;, and is assumed only to satisfy a trait bound.</p>

<ul>
<li><p>In the <code>_static</code> version using generics,
each use of the function is specialized to a concrete, statically-known type,
giving static dispatch, inline layout, and other performance wins.</p></li>
<li><p>In the <code>_dynamic</code> version using trait objects, the concrete argument type is
only known at runtime using a vtable.</p></li>
</ul>

<p>On the other hand, while you can write</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="n">produce_iter_dynamic</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Box</span><span class="o">&lt;</span><span class="nb">Iterator</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;&gt;</span>
</code></pre></div>
<p>you <em>cannot</em> write something like</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="n">produce_iter_static</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span>
</code></pre></div>
<p>That is, in today&rsquo;s Rust, abstract return types can only be written using trait objects, which
can be a significant performance penalty. This RFC proposes &ldquo;unboxed abstract
types&rdquo; as a way of achieving signatures like <code>produce_iter_static</code>. Like
generics, unboxed abstract types guarantee static dispatch and inline data
layout.</p>

<p>Here are some problems that unboxed abstract types solve or mitigate:</p>

<ul>
<li><p><em>Returning unboxed closures</em>. The ongoing work on unboxed closures expresses
closures using traits. Sugar for closures generates an anonymous type
implementing a closure trait. Without unboxed abstract types, there is no way
to use this sugar while returning the resulting closure unboxed, because there
is no way to write the name of the generated type.</p></li>
<li><p><em>Leaky APIs</em>. Functions can easily leak implementation details in their return
type, when the API should really only promise a trait bound. For example, a
function returning <code>Rev&lt;Splits&lt;&#39;a, u8&gt;&gt;</code> is revealing exactly how the iterator
is constructed, when the function should only promise that it returns <em>some</em>
type implementing <code>Iterator&lt;u8&gt;</code>. Using newtypes/structs with private fields
helps, but is extra work. Unboxed abstract types make it as easy to promise only
a trait bound as it is to return a concrete type.</p></li>
<li><p><em>Complex types</em>. Use of iterators in particular can lead to huge types:</p></li>
</ul>
<div class="highlight"><pre><code class="language-rust" data-lang="rust">  <span class="n">Chain</span><span class="o">&lt;</span><span class="nb">Map</span><span class="o">&lt;</span><span class="nl">&#39;a</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">u8</span><span class="p">),</span> <span class="kt">u16</span><span class="p">,</span> <span class="n">Enumerate</span><span class="o">&lt;</span><span class="n">Filter</span><span class="o">&lt;</span><span class="nl">&#39;a</span><span class="p">,</span> <span class="kt">u8</span><span class="p">,</span> <span class="n">vec</span><span class="o">::</span><span class="n">MoveItems</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;&gt;&gt;&gt;</span><span class="p">,</span> <span class="n">SkipWhile</span><span class="o">&lt;</span><span class="nl">&#39;a</span><span class="p">,</span> <span class="kt">u16</span><span class="p">,</span> <span class="nb">Map</span><span class="o">&lt;</span><span class="nl">&#39;a</span><span class="p">,</span> <span class="o">&amp;</span><span class="kt">u16</span><span class="p">,</span> <span class="kt">u16</span><span class="p">,</span> <span class="n">slice</span><span class="o">::</span><span class="n">Items</span><span class="o">&lt;</span><span class="kt">u16</span><span class="o">&gt;&gt;&gt;&gt;</span>
</code></pre></div>
<p>Even when using newtypes to hide the details, the type still has to be written
  out, which can be very painful. Unboxed abstract types only require writing the
  trait bound.</p>

<ul>
<li><em>Documentation</em>. In today&rsquo;s Rust, reading the documentation for the <code>Iterator</code>
trait is needlessly difficult. Many of the methods return new iterators, but
currently each one returns a different type (<code>Chain</code>, <code>Zip</code>, <code>Map</code>, <code>Filter</code>,
etc), and it requires drilling down into each of these types to determine what
kind of iterator they produce.</li>
</ul>

<p>In short, unboxed abstract types make it easy for a function signature to
promise nothing more than a trait bound, and do not generally require the
function&rsquo;s author to write down the concrete type implementing the bound.</p>
</blockquote>

<p>So, the RFC began with the framing that there was a kind of &ldquo;gap&rdquo; in the
expressiveness matrix: we can choose between static and dynamic dispatch for
inputs, but not for outputs.</p>

<p>The RFC went on to propose the <code>impl Trait</code> notation as a way of solving these
problems:</p>

<blockquote>
<p>The basic idea is to allow code like the following:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">fn</span> <span class="n">produce_iter_static</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="p">(</span><span class="mf">0.</span><span class="p">.</span><span class="mi">10</span><span class="k">u8</span><span class="p">).</span><span class="n">rev</span><span class="p">().</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span><span class="p">).</span><span class="n">skip</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<p>where <code>impl Iterator&lt;u8&gt;</code> should be understood as &ldquo;some type <code>T</code> such that <code>T:
Iterator&lt;u8&gt;</code>.  Notice that the function author does not have to write down any
concrete iterator type, nor does the function&rsquo;s signature reveal those details
to its clients. But the type promises that <em>there exists</em> some concrete type.</p>
</blockquote>

<p>The point here is to avoid writing a return type like</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="n">iter</span><span class="o">::</span><span class="n">Skip</span><span class="o">&lt;</span><span class="n">iter</span><span class="o">::</span><span class="nb">Map</span><span class="o">&lt;</span><span class="k">&#39;static</span><span class="p">,</span><span class="kt">u8</span><span class="p">,</span><span class="kt">u8</span><span class="p">,</span><span class="n">iter</span><span class="o">::</span><span class="n">Rev</span><span class="o">&lt;</span><span class="n">iter</span><span class="o">::</span><span class="n">Range</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;&gt;&gt;&gt;</span>
</code></pre></div>
<p>and instead give only the relevant information: some trait(s) that are
implemented for the return type.</p>

<p>For a variety of reasons the RFC was closed and the feature has not shipped.
But part of the impetus for returning to this topic now is that the illustrious
@eddyb has a working implementation of a subset of the RFC! Ideally, the Rust
community can come to a consensus around a design, and we can adapt and land
this implementation.</p>

<h2 id="design-questions">Design questions</h2>

<p>As it turns out, though, there are a lot of complex issues and decisions at play
here, and as usual, multiple interesting points in the design space. Some of
these were brought up in the RFC itself, others brought up on thread, and others
haven&rsquo;t really been discussed. But they all have to be tackled.</p>

<p>First I&rsquo;ll go quickly through the main questions, then talk about design
priorities, and finally present two possible designs.</p>

<h3 id="is-impl-trait-a-type">Is <code>impl Trait</code> a type?</h3>

<p>Can <code>impl Trait</code> appear everywhere a type can?</p>

<p>If not, where <em>can</em> <code>impl Trait</code> be used? Only return types? What about arguments, struct
definitions, type aliases, etc? In each case, what should the semantics be?</p>

<p>The RFC gave answers to many of these questions, although I think today I would
answer some of them differently.</p>

<h3 id="is-impl-trait-quot-sealed-quot">Is <code>impl Trait</code> &quot;sealed&rdquo;?</h3>

<p>As @Ericson2314 astutely remarked on thread:</p>

<blockquote>
<p>This RFC is trying to serve up type inference and type abstraction as one
feature, when they are orthogonal.</p>

<p>Inference-wise, we want to introduce meta-variables/unknowns where we are are not allowed to today.</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="n">foo</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">_</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
<span class="k">type</span> <span class="n">BigLongIterator</span> <span class="o">=</span> <span class="n">_</span><span class="p">;</span>
</code></pre></div>
<p>Abstraction-wise, we want to give ourselves more leeway to change our libraries without breaking client code.</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="kn">mod</span> <span class="n">nsa</span> <span class="p">{</span>
    <span class="c1">// Works with any T!</span>
    <span class="n">abs</span> <span class="k">type</span> <span class="n">Iter</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;:</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">=</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">SnoopWhile</span><span class="o">&lt;</span><span class="p">...</span><span class="n">T</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></blockquote>

<p>Here &ldquo;type inference&rdquo; means something akin to leaving off a type
annotation that&rsquo;s required today (like the return type of a function),
without any change to semantics.  By contrast, &ldquo;type abstraction&rdquo;
means <em>hiding</em> some information about a type from clients, similarly
to what we often do with
<a href="http://aturon.github.io/features/types/newtype.html">newtypes</a>
today. The original proposal coupled these two features together.</p>

<p>This is going to turn out to be a central question for this blog post. <em>Should</em>
these two aspects of the feature be treated separately or coupled? Are both
needed? What are the tradeoffs?</p>

<h3 id="how-do-you-deal-with-clone-or-iterator-adapters">How do you deal with <code>Clone</code> or <code>Iterator</code> adapters?</h3>

<p>It&rsquo;s pretty common that a trait is <em>conditionally</em> implemented:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">:</span> <span class="nb">Clone</span><span class="o">&gt;</span> <span class="nb">Clone</span> <span class="k">for</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</code></pre></div>
<p>But that poses a problem for <code>impl Trait</code>, which requires an <em>unconditional</em>
statement about which traits are implemented. This is especially painful for
things like the iterator adapters, which are often <code>Clone</code> if the original
iterator is, <code>DoubleEndedIterator</code> if the original iterator is, etc.</p>

<h3 id="do-marker-traits-send-sync-have-to-be-mentioned">Do marker traits (<code>Send</code>, <code>Sync</code>, &hellip;) have to be mentioned?</h3>

<p>When you use the
<a href="http://aturon.github.io/features/types/newtype.html">newtype pattern</a> today,
you have to explicitly forward most traits, but certain traits like <code>Send</code> and
<code>Sync</code> will <em>automatically</em> be implemented for the new type if they were for the
old type. Should <code>impl Trait</code> work similarly, implicitly carrying the markers?</p>

<p>This is not just a question of ergonomics, though the ergonomic issue here is
significant! There&rsquo;s also an extensibility problem: new libraries can add new
&ldquo;OIBIT&rdquo;-style marker traits which are supposed to automatically apply to types,
but forcing those markers to be explicitly opted in to for <code>impl Trait</code> means
they often won&rsquo;t apply. We&rsquo;ve already seen significant problems along these
lines with trait objects today.</p>

<h2 id="design-constraints">Design constraints</h2>

<p>I&rsquo;m going to be a bit opinionated here and lay out some design desires.</p>

<p><strong>Hard constraints</strong>:</p>

<ul>
<li>must be possible to return an unboxed closure and store it in a struct</li>
<li>must be possible to return a compound iterator without giving the type explicitly</li>
<li>must cope with <em>multiple</em> such types appearing as <em>components</em> of a return
type (e.g., returning a pair of different unboxed closures)</li>
<li>must be able to assert that at least <em>some</em> traits are satisfied</li>
<li>must be able to deal with conditional trait implementations</li>
</ul>

<p><strong>Strong desires</strong>:</p>

<ul>
<li>minimal signature verbosity</li>
<li>compatible with adding new OIBITs</li>
<li>simple semantics/explanation of the feature, especially if it looks like a type</li>
</ul>

<p><strong>Nice to haves</strong>:</p>

<ul>
<li>type abstraction (the &ldquo;hiding&rdquo; that @Ericson2314 was talking about)</li>
<li>more ergonomic newtypes (where you don&rsquo;t have to forward trait impls explicitly)</li>
<li>applicable to struct definitions, not just function signatures</li>
</ul>

<h2 id="option-1-return-type-inference">Option 1: return type inference</h2>

<p>I&rsquo;ll start with the simpler design: attack only the type inference aspect of the
original proposal, without actually hiding any details about a type from clients.</p>

<p>The simplest way to do this would be to allow wildcards to leave off types in return
position:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="n">foo</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">_</span> <span class="p">{</span>
    <span class="p">(</span><span class="mf">1.</span><span class="p">.</span><span class="mi">10</span><span class="k">u8</span><span class="p">).</span><span class="n">rev</span><span class="p">().</span><span class="n">skip</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="n">bar</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">(</span><span class="o">||</span> <span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;first closure&quot;</span><span class="p">),</span>
     <span class="o">||</span> <span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;second closure&quot;</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div>
<p>The idea here is that the actual return type is fully concrete &ndash; clients of the
API know exactly what it is, and can take advantage of public inherent methods or
arbitrary traits.</p>

<p>But a pure wildcard proposal is a pretty drastic step away from our policy of
explicitness for signatures and type definitions. In particular, it doesn&rsquo;t lead
to a very informative signature for clients of the API.</p>

<p>A more palatable choice would be something closer to <code>impl Trait</code>, like:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="n">foo</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="o">~</span><span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="kt">u8</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="p">(</span><span class="mf">1.</span><span class="p">.</span><span class="mi">10</span><span class="k">u8</span><span class="p">).</span><span class="n">rev</span><span class="p">().</span><span class="n">skip</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="n">bar</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="o">~</span><span class="n">FnOnce</span><span class="p">(),</span> <span class="o">~</span><span class="n">FnOnce</span><span class="p">())</span> <span class="p">{</span>
    <span class="p">(</span><span class="o">||</span> <span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;first closure&quot;</span><span class="p">),</span>
     <span class="o">||</span> <span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;second closure&quot;</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div>
<p>The idea is that these trait bounds don&rsquo;t say <em>everything</em> about the concrete
type, but they give some trait bounds that must hold of the concrete type. (So
<code>~FnOnce()</code> means &ldquo;an elided type with interface roughly <code>FnOnce()</code>&rdquo;.) Usually,
there is one &ldquo;primary&rdquo; trait for a given return type, though of course you can
list as many as you like using <code>+</code>.</p>

<p>If I have my druthers, this feature would also be usable in argument position:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="n">map</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="o">:</span> <span class="o">~</span><span class="n">FnOnce</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">U</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span>
</code></pre></div>
<p>To be clear about the &ldquo;roughly&rdquo; here: in the <code>foo</code> example, the return type also
implements <code>Clone</code> and <code>ExactSizeIterator</code> &ndash; and client code can rely on those
facts, despite them not being written down.</p>

<p>On the one hand, this approach is uncomfortably implicit (since bounds can be
left off), and it may leak information about the type that we do not
intend.</p>

<p>There are also some implementation concerns &ndash; the typechecker will need to
check function definitions in a particular order to discover concrete types, and
must ensure that return type inference isn&rsquo;t used in a cycle between
functions. Note, however, that type inference continues to be purely local.</p>

<p>On the other hand:</p>

<ul>
<li><p>It&rsquo;s dead simple from the programmer&rsquo;s perspective. There are no
thorny questions about type equality, scoping of type abstractions,
or what <code>~</code> means in various contexts. It&rsquo;s just an extension of
inference.</p></li>
<li><p>It behaves exactly like associated types today.</p></li>
<li><p>It accounts for conditional trait implementations easily, since those will
automatically be known about the return type whenever they are applicable.</p></li>
<li><p>It accounts for marker traits and &ldquo;OIBITs&rdquo; without any fuss.</p></li>
<li><p>This kind of &ldquo;leakage&rdquo; is already prevalent &ndash; and important! &ndash; in Rust
today. For example, when you define an abstract type, you give a trait bound
which must be fulfilled. But when a client has narrowed to a particular
<code>impl</code>, <em>everything</em> about the associated type is revealed:</p></li>
</ul>
<div class="highlight"><pre><code class="language-rust" data-lang="rust">  <span class="k">trait</span> <span class="n">Assoc</span> <span class="p">{</span> <span class="k">type</span> <span class="n">Output</span><span class="o">:</span> <span class="nb">Clone</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">impl</span> <span class="n">Assoc</span> <span class="k">for</span> <span class="kt">u8</span> <span class="p">{</span> <span class="k">type</span> <span class="n">Output</span> <span class="o">=</span> <span class="kt">u8</span><span class="p">;</span> <span class="p">}</span>

  <span class="c1">// we know that u8::Assoc == u8! We&#39;re only limited to the bound when writing</span>
  <span class="c1">// fully generic code.</span>
</code></pre></div>
<ul>
<li>The type leakage is, in general, very unlikely to be relied upon. For example, to
observe the particulars of an iterator adapter type, you&rsquo;d have to do
something like assign it to a suitably-typed mutable variable:</li>
</ul>
<div class="highlight"><pre><code class="language-rust" data-lang="rust">  <span class="kd">let</span> <span class="n">iter</span><span class="o">:</span> <span class="n">Chain</span><span class="o">&lt;</span><span class="nb">Map</span><span class="o">&lt;</span><span class="nl">&#39;a</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">u8</span><span class="p">),</span> <span class="kt">u16</span><span class="p">,</span> <span class="n">Enumerate</span><span class="o">&lt;</span><span class="n">Filter</span><span class="o">&lt;</span><span class="nl">&#39;a</span><span class="p">,</span> <span class="kt">u8</span><span class="p">,</span> <span class="n">vec</span><span class="o">::</span><span class="n">MoveItems</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;&gt;&gt;&gt;</span><span class="p">,</span> <span class="n">SkipWhile</span><span class="o">&lt;</span><span class="nl">&#39;a</span><span class="p">,</span> <span class="kt">u16</span><span class="p">,</span> <span class="nb">Map</span><span class="o">&lt;</span><span class="nl">&#39;a</span><span class="p">,</span> <span class="o">&amp;</span><span class="kt">u16</span><span class="p">,</span> <span class="kt">u16</span><span class="p">,</span> <span class="n">slice</span><span class="o">::</span><span class="n">Items</span><span class="o">&lt;</span><span class="kt">u16</span><span class="o">&gt;&gt;&gt;&gt;</span><span class="p">;</span>
  <span class="n">iter</span> <span class="o">=</span> <span class="n">some_function</span><span class="p">();</span>
</code></pre></div>
<p>This design addresses all of the hard constraints and strong desires &ndash; but none
of the nice-to-haves.</p>

<p><strong>Key point</strong>: the strong simplicity here is a major selling point, given that
the pain we&rsquo;re trying to solve here is one of the places where Rust is
considered to be particularly complicated. (See
<a href="https://www.reddit.com/r/rust/comments/397xn3/why_does_anything_have_higher_priority_than/">this reddit post</a>
for example.)</p>

<h2 id="option-2-type-abstraction">Option 2: type abstraction</h2>

<p>On the other end of the spectrum, we could try to address all of the use cases
outlined, including type abstraction.</p>

<p>I&rsquo;m going to give one particular strawman proposal and syntax here, and only at
a high level &ndash; it&rsquo;s not a fully fleshed out spec, but should give some idea of
the possible direction.</p>

<p>The basic idea is to introduce a &ldquo;type abstraction operator&rdquo; <code>@</code> that is used to
&ldquo;seal&rdquo; a concrete type to a particular interface:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">type</span> <span class="n">File</span> <span class="o">=</span> <span class="n">FileDesc</span><span class="o">@</span><span class="p">(</span><span class="n">Read</span> <span class="o">+</span> <span class="n">Write</span> <span class="o">+</span> <span class="nb">Seek</span> <span class="o">+</span> <span class="n">Debug</span><span class="p">);</span>
</code></pre></div>
<p>You should read this as &ldquo;at&rdquo;, meaning that you are viewing a type &ldquo;at&rdquo; some
specific bounds.</p>

<p>This definition is roughly equivalent to:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">struct</span> <span class="n">File</span><span class="p">(</span><span class="n">FileDesc</span><span class="p">);</span>

<span class="k">impl</span> <span class="n">Read</span> <span class="k">for</span> <span class="n">File</span> <span class="p">{</span>
    <span class="c1">// forward to FileDesc&#39;s Read impl</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Write</span> <span class="k">for</span> <span class="n">File</span> <span class="p">{</span>
    <span class="c1">// forward to FileDesc&#39;s Read impl</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="nb">Seek</span> <span class="k">for</span> <span class="n">File</span> <span class="p">{</span>
    <span class="c1">// forward to FileDesc&#39;s Read impl</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Debug</span> <span class="k">for</span> <span class="n">File</span> <span class="p">{</span>
    <span class="c1">// forward to FileDesc&#39;s Read impl</span>
<span class="p">}</span>
</code></pre></div>
<p>However that there is a <em>scope</em> in which the equivalence <code>File = FileDesc</code> is
known. Within that scope (&ldquo;inside the abstraction boundary&rdquo;), <code>File</code> is a simple
type alias for <code>FileDesc</code>. Outside that scope, <code>File</code> is an opaque type that is
only known to implement the four traits given. This is akin to what you get with
privacy, except that you don&rsquo;t have to explicitly project using <code>.0</code> or
construct using <code>File(SomeFileDesc)</code>.</p>

<p>The obvious scoping rules for the abstraction would be the current privacy rules
(i.e., literally the same as what you get with a newtype).</p>

<p>There are some tricky questions here that need to be answered in a complete
design, which I don&rsquo;t try to answer here:</p>

<ul>
<li><p>Aside from <code>type</code> definitions, where else can <code>@</code> be used? We&rsquo;ll explore one
other location &ndash; function signatures &ndash; in this post, but <code>struct</code>/<code>enum</code>
definitions are another interesting possibility.</p></li>
<li><p>How should these type definitions interact with coherence? Can you implement
traits for <code>File</code>? Inherent methods? What if they conflict with traits/methods
on <code>FileDesc</code>?</p></li>
<li><p>How do you deal with bounds where the type isn&rsquo;t in <code>Self</code> position? For
example, there is also an impl of <code>Read</code> and <code>Write</code> for <code>&amp;File</code> that should
be exported.</p></li>
<li><p>What are the rules for equality around these types?</p></li>
</ul>

<p>For now, I want to focus on the original motivation: avoiding having to fully
name a type, while providing an interface to it.</p>

<h3 id="integrating-return-type-inference">Integrating return type inference</h3>

<p>The other part of the <code>@</code> proposal is that, when used in function signatures,
you can leave off the type before the <code>@</code> (i.e., the concrete type being
abstracted):</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="n">foo</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="o">@</span><span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="kt">u8</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="p">(</span><span class="mf">1.</span><span class="p">.</span><span class="mi">10</span><span class="k">u8</span><span class="p">).</span><span class="n">rev</span><span class="p">().</span><span class="n">skip</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<p>Unlike the <code>~</code> proposal above, <em>this hides everything about the return type
except for the stated trait bound</em>. So clients here don&rsquo;t know that the iterator
is also <code>Clone</code>.</p>

<h3 id="scaling-up-marker-and-conditional-traits">Scaling up: marker and conditional traits</h3>

<p>To make this kind of &ldquo;sealing&rdquo; work, we&rsquo;d have to deal with two additional
thorny problems: marker traits and conditional traits.</p>

<p>Marker traits like <code>Send</code> and <code>Sync</code> are often &ldquo;defaulted&rdquo; (via <code>..</code> impls, AKA
OIBITs). When you follow the newtype pattern, these &ldquo;defaulted&rdquo; traits come
along for the ride, whether you ask for them or not &ndash; they leak through. They
are also often conditional (e.g., one type is <code>Send</code> if some other types are
<code>Send</code>). It&rsquo;s probably simplest to say that <code>@</code> has newtype-like semantics and
marker traits leak through. (Leaking is also important because OIBIT-style
traits can be defined in downstream crates about which you have no knowledge.)</p>

<p>Leaking, of course, makes <code>@Trait</code> and <code>Box&lt;Trait&gt;</code> different forms of type
abstraction, but OIBITs are a huge pain point for trait objects today, so that&rsquo;s
likely a worthwhile difference.</p>

<p>A more difficult issue is truly conditional traits, like:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">:</span> <span class="nb">Clone</span><span class="o">&gt;</span> <span class="nb">Clone</span> <span class="k">for</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</code></pre></div>
<p>To deal with this situation, we&rsquo;d need conditional bounds like:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="o">@</span><span class="p">(</span><span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="n">T</span><span class="o">&gt;</span> <span class="o">+</span>
  <span class="n">I</span><span class="o">:</span> <span class="nb">Clone</span> <span class="o">=&gt;</span> <span class="n">Self</span><span class="o">:</span> <span class="nb">Clone</span> <span class="o">+</span>
  <span class="n">I</span><span class="o">:</span> <span class="nb">DoubleEndedIterator</span> <span class="o">=&gt;</span> <span class="n">Self</span><span class="o">:</span> <span class="nb">DoubleEndedIterator</span><span class="p">)</span>
</code></pre></div>
<p>That&rsquo;s, obviously, pretty verbose. Fortunately, in many cases there are groups
of conditional bounds that tend to go together (see the iterator adapters, for
example). You could imagine capturing these groups into aliases, so that you
could say something like:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">trait</span> <span class="n">IterAdapter</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">I</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="n">T</span><span class="o">&gt;</span> <span class="o">+</span>
  <span class="n">I</span><span class="o">:</span> <span class="nb">Clone</span> <span class="o">=&gt;</span> <span class="n">Self</span><span class="o">:</span> <span class="nb">Clone</span> <span class="o">+</span>
  <span class="n">I</span><span class="o">:</span> <span class="nb">DoubleEndedIterator</span> <span class="o">=&gt;</span> <span class="n">Self</span><span class="o">:</span> <span class="nb">DoubleEndedIterator</span><span class="p">;</span>

<span class="p">...</span> <span class="o">@</span><span class="n">IterAdapter</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">I</span><span class="o">&gt;</span>
</code></pre></div>
<p>These aliases still have documentation advantages over the current adapter API,
since you&rsquo;d reuse the same alias over and over. By contrast, today each adapter
introduces a separate newtype which must be examined separately to find its API.</p>

<h3 id="benefits-drawbacks">Benefits/drawbacks</h3>

<p>So in all, it seems feasible to introduce a type abstraction feature, <code>@</code>, along
with an elided form for function signatures, and have reasonably concise
signatures.</p>

<p>Some benefits:</p>

<ul>
<li><p>The design feels a bit more &ldquo;principled&rdquo; than the pure type inference design:
except for OIBIT traits, the entire interface to a type must be written
explicitly, so there&rsquo;s no accidental leakage and everything is fully
documented.</p></li>
<li><p>The use in <code>type</code> gives a lighter weight form of newtypes that doesn&rsquo;t require
manually forwarding trait impls (akin to &ldquo;generalized newtype deriving&rdquo; from
the Haskell world). However, these types would likely not function as complete
newtypes from the perspective of impl coherence &ndash; it probably doesn&rsquo;t make
sense to impl new traits for them, for example. So they don&rsquo;t solve the whole
problem.</p></li>
</ul>

<p>Some drawbacks:</p>

<ul>
<li><p>Complexity. This variant is <em>way</em> more complicated than pure type
inference. And it&rsquo;s not clear that type abstraction is a feature that Rust
really needs, given that we already have privacy and the newtype pattern. We
could provide &ldquo;newtype deriving&rdquo; in a much simpler way to address the pain
points there.</p></li>
<li><p>Verbosity. Even with aliases, the signatures involve here tend to be much more
complicated. Of course, that&rsquo;s part of the point: this proposal is trying to
be explicit about signatures.</p></li>
<li><p>A somewhat deeper change. This proposal means, for example, that <code>type</code> can no
longer be understood as a straight-up alias, since repeated uses of <code>@</code> create
<em>distinct</em> abstract types.</p></li>
</ul>

<h2 id="wrapup">Wrapup</h2>

<p>We absolutely need to expand Rust in this area; I stand by the design
constraints listed here. But we managed to ship a relatively slim Rust 1.0, and
I&rsquo;d like to fight to keep the language as small and concise as we can manage.</p>

<p>In that light, I&rsquo;m leaning somewhat toward return type inference here, despite
its break from full signature explicitness. But I remain concerned about the
fact that the bound is not actually all that meaningful.</p>

</article>


<aside class="related">
  <h2>Related Posts</h2>
  <ul class="related-posts">
    
      <li>
        <h3>
          <a href="/blog/2016/08/11/futures/">
            Zero-cost futures in Rust
            <small><time datetime="2016-08-11T00:00:00-07:00">11 Aug 2016</time></small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/blog/2016/07/27/rust-platform/">
            The Rust Platform
            <small><time datetime="2016-07-27T00:00:00-07:00">27 Jul 2016</time></small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/blog/2016/07/05/rfc-refinement/">
            Refining Rust's RFCs
            <small><time datetime="2016-07-05T00:00:00-07:00">05 Jul 2016</time></small>
          </a>
        </h3>
      </li>
    
  </ul>
</aside>


      </main>

      <footer class="footer">
        <small>
          &copy; <time datetime="2016-08-11T08:16:46-07:00">2016</time>. All rights reserved.
        </small>
      </footer>
    </div>

  </body>
</html>
