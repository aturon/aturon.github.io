<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="UTF-8">
  <link href="http://gmpg.org/xfn/11" rel="profile">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>
    
      Lock-freedom without garbage collection &middot; Aaron Turon
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/blog/styles.css">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/blog/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/blog/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/atom+xml" title="Aaron Turon" href="/blog/atom.xml">
</head>


  <body>

    <div class="container content">
      <header class="masthead">
        <h3 class="masthead-title">
          <a href="/blog/" title="Home">Aaron Turon</a>
          <small></small>

          
          &nbsp;&nbsp;&nbsp;
          <small><a href="/archive">Archive</a></small>
          
          &nbsp;&nbsp;&nbsp;
          <small><a href="/atom.xml">Feed</a></small>
          
        </h3>
      </header>

      <main>
        <article class="post">
  <h1 class="post-title">Lock-freedom without garbage collection</h1>
  <time datetime="2015-08-21T00:00:00-07:00" class="post-date">21 Aug 2015</time>
  <h2 id="tl;dr">TL;DR</h2>

<p>It&rsquo;s widespread folklore that one advantage of a good garbage collector
is the ease of building high-performance lock-free data structures. Manual
memory management for these data structures is not easy, and a GC makes it
trivial.</p>

<p>This post shows that, <strong>using Rust, it&rsquo;s possible to build a memory management API
for concurrent data structures</strong> that:</p>

<ul>
<li>Makes it as <strong>easy to implement lock-free data structures</strong> as a GC does;</li>
<li>Has <strong>smaller and more predictable overhead</strong> than concurrent GC.</li>
</ul>

<p>I&rsquo;ve implemented &ldquo;epoch-based memory reclamation&rdquo; in a new library called
<a href="https://github.com/aturon/crossbeam">Crossbeam</a>, which is ready to use in for
your own data structures today. This post covers some background on lock-free
data structures, the epoch algorithm, and the entire Rust API.</p>

<h3 id="contents">Contents</h3>

<ul>
<li><a href="#lock-free-data-structures">Lock-free data structures</a>

<ul>
<li><a href="#treiber&#x27;s-stack">Treiber&rsquo;s stack</a></li>
<li><a href="#the-problem">The problem</a></li>
</ul></li>
<li><a href="#epoch-based-reclamation">Epoch-based reclamation</a></li>
<li><a href="#the-rust-api">The Rust API</a>

<ul>
<li><a href="#guard"><code>Guard</code></a></li>
<li><a href="#owned-and-shared-pointers"><code>Owned</code> and <code>Shared</code> pointers</a></li>
<li><a href="#atomic"><code>Atomic</code></a></li>
<li><a href="#freeing-memory">Freeing memory</a></li>
<li><a href="#treiber&#x27;s-stack-on-epochs">Treiber&rsquo;s stack on epochs</a></li>
<li><a href="#managing-garbage">Managing garbage</a></li>
</ul></li>
<li><a href="#benchmarks">Benchmarks</a></li>
<li><a href="#looking-ahead">Looking ahead</a></li>
</ul>

<h2 id="lock-free-data-structures">Lock-free data structures</h2>

<p>When you want to use (and mutate) a data structure from many concurrent threads,
you need synchronization. The simplest solution is a global lock &ndash; in Rust,
wrapping the entire data structure in
a <a href="http://static.rust-lang.org/doc/master/std/sync/struct.Mutex.html"><code>Mutex</code></a> and
calling it a day.</p>

<p>Problem is, that kind of &ldquo;coarse-grained&rdquo; synchronization means that multiple
threads always need to coordinate when accessing a data structure, even if they
were accessing disjoint pieces of it. It also means that even when a thread is
only trying to read, it must <em>write</em>, by updating the lock state &ndash; and since
the lock is a global point of communication, these writes lead to a large amount
of cache invalidation traffic. Even if you use a lot of locks at a finer grain,
there are other
<a href="https://en.wikipedia.org/wiki/Lock_%28computer_science%29#Disadvantages">hazards</a>
like <a href="https://en.wikipedia.org/wiki/Deadlock">deadlock</a> and
<a href="https://en.wikipedia.org/wiki/Priority_inversion">priority inversion</a>, and you
often still leave performance on the table.</p>

<p>A more radical alternative is <em>lock-free data structures</em>, which use atomic
operations to make direct changes to the data structure without further
synchronization. They are often faster, more scalable, and more robust than
lock-based designs.</p>

<p>I won&rsquo;t try to give a full tutorial to lock-free programming in this post, but a
key point is that, if you don&rsquo;t have global synchronization, it&rsquo;s very difficult
to tell when you can free memory. Many published algorithms basically assume a
garbage collector or some other means of reclaiming memory. So before lock-free
concurrency can really take off in Rust, we need a story for memory reclamation
&ndash; and that&rsquo;s what this blog post is all about.</p>

<h3 id="treiber&#39;s-stack">Treiber&rsquo;s stack</h3>

<p>To make things more concrete, let&rsquo;s look at the &ldquo;Hello world&rdquo; of lock-free data
structures: Treiber&rsquo;s stack. The stack is represented as a singly-linked list,
with all modifications happening on the <code>head</code> pointer:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="err">#</span><span class="o">!</span><span class="p">[</span><span class="n">feature</span><span class="p">(</span><span class="n">box_raw</span><span class="p">)]</span>

<span class="kn">use</span> <span class="n">std</span><span class="o">::</span><span class="n">ptr</span><span class="o">::</span><span class="p">{</span><span class="bp">self</span><span class="p">,</span> <span class="n">null_mut</span><span class="p">};</span>
<span class="kn">use</span> <span class="n">std</span><span class="o">::</span><span class="n">sync</span><span class="o">::</span><span class="n">atomic</span><span class="o">::</span><span class="n">AtomicPtr</span><span class="p">;</span>
<span class="kn">use</span> <span class="n">std</span><span class="o">::</span><span class="n">sync</span><span class="o">::</span><span class="n">atomic</span><span class="o">::</span><span class="nb">Ordering</span><span class="o">::</span><span class="p">{</span><span class="n">Relaxed</span><span class="p">,</span> <span class="n">Release</span><span class="p">,</span> <span class="n">Acquire</span><span class="p">};</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">head</span><span class="o">:</span> <span class="n">AtomicPtr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">data</span><span class="o">:</span> <span class="n">T</span><span class="p">,</span>
    <span class="n">next</span><span class="o">:</span> <span class="o">*</span><span class="k">mut</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">new</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="n">Stack</span> <span class="p">{</span>
            <span class="n">head</span><span class="o">:</span> <span class="n">AtomicPtr</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">null_mut</span><span class="p">()),</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>It&rsquo;s easiest to start with popping. To pop, you just loop, taking a snapshot of
the <code>head</code> and doing a compare-and-swap replacing the snapshot with its next
pointer:</p>

<blockquote>
<p>Note that <code>compare_and_swap</code> atomically changes the value of an <code>AtomicPtr</code>
from an old value to a new value, if the old value matched. Also, for this post
you can safely ignore the <code>Acquire</code>, <code>Release</code> and <code>Relaxed</code> labels if you&rsquo;re
not familiar with them.</p>
</blockquote>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">pop</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">loop</span> <span class="p">{</span>
            <span class="c1">// take a snapshot</span>
            <span class="kd">let</span> <span class="n">head</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">Acquire</span><span class="p">);</span>

            <span class="c1">// we observed the stack empty</span>
            <span class="k">if</span> <span class="n">head</span> <span class="o">==</span> <span class="n">null_mut</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nb">None</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="kd">let</span> <span class="n">next</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="p">(</span><span class="o">*</span><span class="n">head</span><span class="p">).</span><span class="n">next</span> <span class="p">};</span>

                <span class="c1">// if snapshot is still good, update from `head` to `next`</span>
                <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">compare_and_swap</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">Release</span><span class="p">)</span> <span class="o">==</span> <span class="n">head</span> <span class="p">{</span>

                    <span class="c1">// extract out the data from the now-unlinked node</span>
                    <span class="k">return</span> <span class="nb">Some</span><span class="p">(</span><span class="k">unsafe</span> <span class="p">{</span> <span class="n">ptr</span><span class="o">::</span><span class="n">read</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">head</span><span class="p">).</span><span class="n">data</span><span class="p">)</span> <span class="p">})</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>The <code>ptr::read</code> function is Rust&rsquo;s way of extracting ownership of data without
static or dynamic tracking. Here we are using the atomicity of
<code>compare_and_swap</code> to guarantee that only one thread will call <code>ptr::read</code> &ndash;
and as we&rsquo;ll see, this implementation never frees <code>Node</code>s, so the destructor on
<code>data</code> is never invoked. Those two facts together make our use of <code>ptr::read</code>
safe.</p>

<p>Pushing is similar:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">push</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="o">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// allocate the node, and immediately turn it into a *mut pointer</span>
        <span class="kd">let</span> <span class="n">n</span> <span class="o">=</span> <span class="n">Box</span><span class="o">::</span><span class="n">into_raw</span><span class="p">(</span><span class="n">Box</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">Node</span> <span class="p">{</span>
            <span class="n">data</span><span class="o">:</span> <span class="n">t</span><span class="p">,</span>
            <span class="n">next</span><span class="o">:</span> <span class="n">null_mut</span><span class="p">(),</span>
        <span class="p">}));</span>
        <span class="k">loop</span> <span class="p">{</span>
            <span class="c1">// snapshot current head</span>
            <span class="kd">let</span> <span class="n">head</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">Relaxed</span><span class="p">);</span>

            <span class="c1">// update `next` pointer with snapshot</span>
            <span class="k">unsafe</span> <span class="p">{</span> <span class="p">(</span><span class="o">*</span><span class="n">n</span><span class="p">).</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span> <span class="p">}</span>

            <span class="c1">// if snapshot is still good, link in new node</span>
            <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">compare_and_swap</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">Release</span><span class="p">)</span> <span class="o">==</span> <span class="n">head</span> <span class="p">{</span>
                <span class="k">break</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="the-problem">The problem</h3>

<p>If we had coded the above in a language with a GC, we&rsquo;d be done. But as written
in Rust, it leaks memory. In particular, the <code>pop</code> implementation doesn&rsquo;t
attempt to free the node pointer after it has removed it from the stack.</p>

<p>What would go wrong if we did just that?</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="c1">// extract out the data from the now-unlinked node</span>
<span class="kd">let</span> <span class="n">data</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="p">(</span><span class="o">*</span><span class="n">head</span><span class="p">).</span><span class="n">data</span><span class="p">.</span><span class="n">take</span><span class="p">()</span> <span class="p">};</span>

<span class="c1">// free the node</span>
<span class="n">mem</span><span class="o">::</span><span class="nb">drop</span><span class="p">(</span><span class="n">Box</span><span class="o">::</span><span class="n">from_raw</span><span class="p">(</span><span class="n">head</span><span class="p">));</span>

<span class="k">return</span> <span class="n">data</span>
</code></pre></div>
<p>The problem is that other threads could also be running <code>pop</code> at the same
time. The earlier line, <code>let next = unsafe { (*head).next };</code>, reads <code>next</code> out
of a snapshot taken of <code>head</code>. If that snapshot pointed to the node we just
deallocated, we&rsquo;d have a use-after-free bug on our hands!</p>

<p>So that&rsquo;s the crux. We want to use lock-free algorithms, but many follow a
similar pattern to the stack above, leaving us with no clear point where it&rsquo;s
safe to deallocate a node. What now?</p>

<h2 id="epoch-based-reclamation">Epoch-based reclamation</h2>

<p>There are a few non-GC-based ways of managing memory for lock-free code, but
they all come down to the same core observations:</p>

<ol>
<li><p>There are two sources of reachability at play &ndash; the data structure, and the
snapshots in threads accessing it. Before we delete a node, we need to know that
it cannot be reached in either of these ways.</p></li>
<li><p>Once a node has been unliked from the data structure, no <em>new</em> snapshots
reaching it will be created.</p></li>
</ol>

<p>One of the most elegant and promising reclamation schemes is
<a href="https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-579.pdf">Keir Fraser&rsquo;s <em>epoch-based reclamation</em></a>,
which was described in very loose terms in his PhD thesis.</p>

<p>The basic idea is to stash away nodes that have been unlinked from the data
structure (the first source of reachability) until they can be safely deleted.
Before we can delete a stashed node, we need to know that all threads that were
accessing the data structure at the time have finished the operation they were
performing. By observation 2 above, that will imply that there are no longer any
snapshots left (since no new ones could have been created in the meantime).  The
hard part is doing all of this without much synchronization.  Otherwise, we lose
the benefit that lock-freedom was supposed to bring in the first place!</p>

<p>The epoch scheme works by having:</p>

<ol>
<li>A global epoch counter (taking on values 0, 1, and 2);</li>
<li>A global list of garbage for each epoch;</li>
<li>An &ldquo;active&rdquo; flag for each thread;</li>
<li>An epoch counter for each thread.</li>
</ol>

<p>The epochs are used to discover when garbage can safely be freed, because no
thread can reach it. <strong>Unlike traditional GC, this does not require walking
through live data</strong>; it&rsquo;s purely a matter of checking epoch counts.</p>

<p>When a thread wants to perform an operation on the data structure, it first sets
its &ldquo;active&rdquo; flag, and then updates its local epoch to match the global one. If
the thread removes a node from the data structure, it adds that node to the
garbage list for the current global epoch. When it completes its operation, it
clears the &ldquo;active&rdquo; thread.</p>

<p>To try to collect the garbage (which can be done at any point), a thread walks
over the flags for all participating threads, and checks whether all active
threads are in the current epoch. If so, it can attempt to increment the global
epoch (modulo 3). If the increment succeeds, the garbage from <em>two</em> epochs ago
can be freed.</p>

<p>Why do we need three epochs? Because &ldquo;garbage collection&rdquo; is done concurrently,
it&rsquo;s possible for threads to be in one of two epochs at any time (the &ldquo;old&rdquo; one,
and the &ldquo;new&rdquo; one). But because we check that all active threads are in the old
epoch before incrementing it, we are guaranteed that no active threads are in
the third epoch.</p>

<p>This scheme is carefully designed so that most of the time, threads touch data
that is already in cache or is (usually) thread-local. Only doing &ldquo;GC&rdquo; involves
changing the global epoch or reading the epochs of other threads. The epoch
approach is also algorithm-agnostic, easy to use, and its performance is
<a href="http://csng.cs.toronto.edu/publication_files/0000/0159/jpdc07.pdf">competitive with other approaches</a>.</p>

<p>It also turns out to be a great match for Rust&rsquo;s ownership system.</p>

<h2 id="the-rust-api">The Rust API</h2>

<p>We want the Rust API to reflect the basic principles of epoch-based reclamation:</p>

<ul>
<li><p>When operating on a shared data structure, a thread must always be in its
&ldquo;active&rdquo; state.</p></li>
<li><p>When a thread is active, all data read out of the data structure will remain
allocated until the thread becomes inactive.</p></li>
</ul>

<p>We&rsquo;ll leverage Rust&rsquo;s ownership system &ndash; in particular, ownership-based
resource management (aka RAII) &ndash; to capture these constraints directly in the
type signatures of an epoch API.</p>

<h3 id="guard"><code>Guard</code></h3>

<p>To operate on a lock-free data structure, you first acquire a <em>guard</em>, which
is an owned value that represents your thread being active:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">struct</span> <span class="n">Guard</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="n">pin</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Guard</span><span class="p">;</span>
</code></pre></div>
<p>The <code>pin</code> function marks the thread as active, loads the global epoch, and may
try to perform GC (detailed a bit later in the post). The destructor for
<code>Guard</code>, on the other hand, exits epoch management by marking the thread
inactive.</p>

<p>Since the <code>Guard</code> represents &ldquo;being active&rdquo;, a borrow <code>&amp;&#39;a Guard</code> guarantees
that the thread is active for the entire lifetime <code>&#39;a</code> &ndash; exactly what we need
to bound the lifetime of the snapshots taken in a lock-free algorithm.</p>

<p>To put the <code>Guard</code> to use, Crossbeam provides a set of three pointer types meant to work together:</p>

<ul>
<li><p><code>Owned&lt;T&gt;</code>, akin to <code>Box&lt;T&gt;</code>, which points to uniquely-owned data that has
not yet been published in a concurrent data structure.</p></li>
<li><p><code>Shared&lt;&#39;a, T&gt;</code>, akin to <code>&amp;&#39;a T</code>, which points to shared data that may or may
not be reachable from a data structure, but it guaranteed not to be freed
during lifetime <code>&#39;a</code>.</p></li>
<li><p><code>Atomic&lt;T&gt;</code>, akin to <code>std::sync::atomic::AtomicPtr</code>, which provides atomic
updates to a pointer using the <code>Owned</code> and <code>Shared</code> types, and connects them
to a <code>Guard</code>.</p></li>
</ul>

<p>We&rsquo;ll look at each of these in turn.</p>

<h3 id="owned-and-shared-pointers"><code>Owned</code> and <code>Shared</code> pointers</h3>

<p>The <code>Owned</code> pointer has an interface nearly identical to <code>Box</code>:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">struct</span> <span class="n">Owned</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Owned</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">new</span><span class="p">(</span><span class="n">t</span><span class="o">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Owned</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Deref</span> <span class="k">for</span> <span class="n">Owned</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Target</span> <span class="o">=</span> <span class="n">T</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">}</span>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">DerefMut</span> <span class="k">for</span> <span class="n">Owned</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</code></pre></div>
<p>The <code>Shared&lt;&#39;a, T&gt;</code> pointer is similar to <code>&amp;&#39;a T</code> &ndash; it is <code>Copy</code> &ndash; but it
dereferences to a <code>&amp;&#39;a T</code>. This is a somewhat hacky way of conveying that the
lifetime of the pointer it provides is in fact <code>&#39;a</code>.</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">struct</span> <span class="n">Shared</span><span class="o">&lt;</span><span class="nl">&#39;a</span><span class="p">,</span> <span class="n">T</span><span class="o">:</span> <span class="nl">&#39;a</span><span class="o">&gt;</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="nl">&#39;a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">Copy</span> <span class="k">for</span> <span class="n">Shared</span><span class="o">&lt;</span><span class="nl">&#39;a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="k">impl</span><span class="o">&lt;</span><span class="nl">&#39;a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="nb">Clone</span> <span class="k">for</span> <span class="n">Shared</span><span class="o">&lt;</span><span class="nl">&#39;a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="nl">&#39;a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">Deref</span> <span class="k">for</span> <span class="n">Shared</span><span class="o">&lt;</span><span class="nl">&#39;a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Target</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">&#39;a</span> <span class="n">T</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div>
<p>Unlike <code>Owned</code>, there is no way to create a <code>Shared</code> pointer directly. Instead,
<code>Shared</code> pointers are acquired by reading from an <code>Atomic</code>, as we&rsquo;ll see
next.</p>

<h3 id="atomic"><code>Atomic</code></h3>

<p>The heart of the library is <code>Atomic</code>, which provides atomic access to a
(nullable) pointer, and connects all the other types of the library together:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">struct</span> <span class="n">Atomic</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Atomic</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c-Doc">/// Create a new, null atomic pointer.</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">new</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Atomic</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>We&rsquo;ll look at operations one at a time, since the signatures are somewhat subtle.</p>

<h4 id="loading">Loading</h4>

<p>First, loading from an <code>Atomic</code>:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Atomic</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">load</span><span class="o">&lt;</span><span class="nl">&#39;a</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span> <span class="n">ord</span><span class="o">:</span> <span class="nb">Ordering</span><span class="p">,</span> <span class="n">_</span><span class="o">:</span> <span class="o">&amp;</span><span class="n">&#39;a</span> <span class="n">Guard</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Shared</span><span class="o">&lt;</span><span class="nl">&#39;a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>In order to perform the load, we must pass in a borrow of a <code>Guard</code>. As
explained above, this is a way of guaranteeing that the thread is active for the
entire lifetime <code>&#39;a</code>. In return, you get an optional <code>Shared</code> pointer back
(<code>None</code> if the <code>Atomic</code> is currently null), with lifetime tied to the guard.</p>

<p>It&rsquo;s interesting to compare this to the standard library&rsquo;s <code>AtomicPtr</code>
interface, where <code>load</code> returns a <code>*mut T</code>. Due to the use of epochs, we&rsquo;re able
to guarantee safe dereferencing of the pointer within <code>&#39;a</code>, whereas with
<code>AtomicPtr</code> all bets are off.</p>

<h4 id="storing">Storing</h4>

<p>Storing is a bit more complicated because of the multiple pointer types in play.</p>

<p>If we simply want to write an <code>Owned</code> pointer or a null value, we do not even
need the thread to be active. We are just transferring ownership <em>into</em> the data
structure, and don&rsquo;t need any assurance about the lifetimes of pointers:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Atomic</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">store</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="o">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Owned</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="n">ord</span><span class="o">:</span> <span class="nb">Ordering</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>Sometimes, though, we want to transfer ownership into the data structure and
immediately acquire a shared pointer to the transferred data &ndash; for example,
because we want to add additional links to the same node in the data
structure. In that case, we&rsquo;ll need to tie the lifetime to a guard:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Atomic</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">store_and_ref</span><span class="o">&lt;</span><span class="nl">&#39;a</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span>
                         <span class="n">val</span><span class="o">:</span> <span class="n">Owned</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
                         <span class="n">ord</span><span class="o">:</span> <span class="nb">Ordering</span><span class="p">,</span>
                         <span class="n">_</span><span class="o">:</span> <span class="o">&amp;</span><span class="n">&#39;a</span> <span class="n">Guard</span><span class="p">)</span>
                         <span class="o">-&gt;</span> <span class="n">Shared</span><span class="o">&lt;</span><span class="nl">&#39;a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>Note that the runtime representation of <code>val</code> and the return value is exactly
the same &ndash; we&rsquo;re passing a pointer in, and getting the same pointer out. But
the <em>ownership</em> situation from Rust&rsquo;s perspective changes radically in this step.</p>

<p>Finally, we can store a shared pointer back into the data structure:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Atomic</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">unsafe</span> <span class="k">fn</span> <span class="n">store_shared</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="o">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Shared</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="n">ord</span><span class="o">:</span> <span class="nb">Ordering</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>This operation does not require a guard, because we&rsquo;re not learning any new
information about the lifetime of a pointer. It is unsafe because the <code>Shared</code>
pointer we provide has a limited lifetime, but we are essentially claiming it
can live forever. Put differently, data that is reachable through a chain of
<code>Atomic</code> is live, independent from any epoch &ndash; the epochs manage cleanup of
data that is no longer reachable from the data structure.</p>

<p>In general, <code>store_shared</code> is safe to use when:</p>

<ul>
<li><p>We know for certain that the same pointer is already reachable through some
other path in the data structure, or,</p></li>
<li><p>We just removed the pointer from the data structure, but did not schedule it
for deletion. In that case, we effectively &ldquo;own&rdquo; the pointer.</p></li>
</ul>

<h4 id="cas">CAS</h4>

<p>Next we have a similar family of compare-and-set operations. The simplest case
is swapping a <code>Shared</code> pointer with a fresh <code>Owned</code> one:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Atomic</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">cas</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span>
           <span class="n">old</span><span class="o">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Shared</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">,</span>
           <span class="n">new</span><span class="o">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Owned</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">,</span>
           <span class="n">ord</span><span class="o">:</span> <span class="nb">Ordering</span><span class="p">)</span>
           <span class="o">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Owned</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;&gt;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>As with <code>store</code>, this operation does not require a guard; it produces no new
lifetime information. The <code>Result</code> indicates whether the CAS succeeded; if not,
ownership of the <code>new</code> pointer is returned to the caller.</p>

<p>We then have an analog to <code>store_and_ref</code>:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Atomic</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">cas_and_ref</span><span class="o">&lt;</span><span class="nl">&#39;a</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span>
                       <span class="n">old</span><span class="o">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Shared</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">,</span>
                       <span class="n">new</span><span class="o">:</span> <span class="n">Owned</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
                       <span class="n">ord</span><span class="o">:</span> <span class="nb">Ordering</span><span class="p">,</span>
                       <span class="n">_</span><span class="o">:</span> <span class="o">&amp;</span><span class="n">&#39;a</span> <span class="n">Guard</span><span class="p">)</span>
                       <span class="o">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">Shared</span><span class="o">&lt;</span><span class="nl">&#39;a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Owned</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">;</span>
</code></pre></div>
<p>In this case, on a successful CAS we acquire a <code>Shared</code> pointer to the data we
inserted.</p>

<p>Finally, we can replace one <code>Shared</code> pointer with another:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Atomic</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">unsafe</span> <span class="k">fn</span> <span class="n">cas_shared</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span>
                         <span class="n">old</span><span class="o">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Shared</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">,</span>
                         <span class="n">new</span><span class="o">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Shared</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">,</span>
                         <span class="n">ord</span><span class="o">:</span> <span class="nb">Ordering</span><span class="p">)</span>
                         <span class="o">-&gt;</span> <span class="kt">bool</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>The boolean return value is <code>true</code> when the CAS is successful. This operation is
unsafe for exactly the same reason that <code>store_shared</code> is.</p>

<h3 id="freeing-memory">Freeing memory</h3>

<p>Of course, all of the above machinery is in service of the ultimate goal:
actually freeing memory that is no longer reachable. When a node has been
de-linked from the data structure, the thread that delinked it can inform its
<code>Guard</code> that the memory should be reclaimed:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span> <span class="n">Guard</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">unsafe</span> <span class="k">fn</span> <span class="n">unlinked</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="o">:</span> <span class="n">Shared</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>This operation adds the <code>Shared</code> pointer to the appropriate garbage list,
allowing it to be freed two epochs later.</p>

<p>The operation is unsafe because it is asserting that:</p>

<ul>
<li>the <code>Shared</code> pointer is not reachable from the data structure,</li>
<li>no other thread will call <code>unlinked</code> on it.</li>
</ul>

<p>Crucially, though, other threads <em>may</em> continue to reference this <code>Shared</code>
pointer; the epoch system will ensure that no threads are doing so by the time
the pointer is actually freed.</p>

<p>There is no particular connection between the lifetime of the <code>Shared</code> pointer
here and the <code>Guard</code>; if we have a reachable <code>Shared</code> pointer, we know that the
guard it came from is active.</p>

<h3 id="treiber&#39;s-stack-on-epochs">Treiber&rsquo;s stack on epochs</h3>

<p>Without further ado, here is the code for Treiber&rsquo;s stack using the Crossbeam
epoch API:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="kn">use</span> <span class="n">std</span><span class="o">::</span><span class="n">sync</span><span class="o">::</span><span class="n">atomic</span><span class="o">::</span><span class="nb">Ordering</span><span class="o">::</span><span class="p">{</span><span class="n">Acquire</span><span class="p">,</span> <span class="n">Release</span><span class="p">,</span> <span class="n">Relaxed</span><span class="p">};</span>
<span class="kn">use</span> <span class="n">std</span><span class="o">::</span><span class="n">ptr</span><span class="p">;</span>

<span class="kn">use</span> <span class="n">crossbeam</span><span class="o">::</span><span class="n">mem</span><span class="o">::</span><span class="n">epoch</span><span class="o">::</span><span class="p">{</span><span class="bp">self</span><span class="p">,</span> <span class="n">Atomic</span><span class="p">,</span> <span class="n">Owned</span><span class="p">};</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">TreiberStack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">head</span><span class="o">:</span> <span class="n">Atomic</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">data</span><span class="o">:</span> <span class="n">T</span><span class="p">,</span>
    <span class="n">next</span><span class="o">:</span> <span class="n">Atomic</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">TreiberStack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">new</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">TreiberStack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="n">TreiberStack</span> <span class="p">{</span>
            <span class="n">head</span><span class="o">:</span> <span class="n">Atomic</span><span class="o">::</span><span class="n">new</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="n">push</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="o">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// allocate the node via Owned</span>
        <span class="kd">let</span> <span class="k">mut</span> <span class="n">n</span> <span class="o">=</span> <span class="n">Owned</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">Node</span> <span class="p">{</span>
            <span class="n">data</span><span class="o">:</span> <span class="n">t</span><span class="p">,</span>
            <span class="n">next</span><span class="o">:</span> <span class="n">Atomic</span><span class="o">::</span><span class="n">new</span><span class="p">(),</span>
        <span class="p">});</span>

        <span class="c1">// become active</span>
        <span class="kd">let</span> <span class="n">guard</span> <span class="o">=</span> <span class="n">epoch</span><span class="o">::</span><span class="n">pin</span><span class="p">();</span>

        <span class="k">loop</span> <span class="p">{</span>
            <span class="c1">// snapshot current head</span>
            <span class="kd">let</span> <span class="n">head</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">Relaxed</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">guard</span><span class="p">);</span>

            <span class="c1">// update `next` pointer with snapshot</span>
            <span class="k">unsafe</span> <span class="p">{</span> <span class="n">n</span><span class="p">.</span><span class="n">next</span><span class="p">.</span><span class="n">store_shared</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">Relaxed</span><span class="p">);</span> <span class="p">}</span>

            <span class="c1">// if snapshot is still good, link in the new node</span>
            <span class="k">match</span> <span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">cas_and_ref</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">Release</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">guard</span><span class="p">)</span> <span class="p">{</span>
                <span class="nb">Ok</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="k">return</span><span class="p">,</span>
                <span class="nb">Err</span><span class="p">(</span><span class="n">owned</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">n</span> <span class="o">=</span> <span class="n">owned</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="n">pop</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="c1">// become active</span>
        <span class="kd">let</span> <span class="n">guard</span> <span class="o">=</span> <span class="n">epoch</span><span class="o">::</span><span class="n">pin</span><span class="p">();</span>

        <span class="k">loop</span> <span class="p">{</span>
            <span class="c1">// take a snapshot</span>
            <span class="k">match</span> <span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">Acquire</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">guard</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// the stack is non-empty</span>
                <span class="nb">Some</span><span class="p">(</span><span class="n">head</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
                    <span class="c1">// read through the snapshot, *safely*!</span>
                    <span class="kd">let</span> <span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">.</span><span class="n">next</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">Relaxed</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">guard</span><span class="p">);</span>

                    <span class="c1">// if snapshot is still good, update from `head` to `next`</span>
                    <span class="kd">let</span> <span class="n">success</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span>
                        <span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">cas_shared</span><span class="p">(</span><span class="nb">Some</span><span class="p">(</span><span class="n">head</span><span class="p">),</span> <span class="n">next</span><span class="p">,</span> <span class="n">Release</span><span class="p">)</span>
                    <span class="p">};</span>

                    <span class="k">if</span> <span class="n">success</span> <span class="p">{</span>
                        <span class="c1">// mark the node as unlinked</span>
                        <span class="k">unsafe</span> <span class="p">{</span> <span class="n">guard</span><span class="p">.</span><span class="n">unlinked</span><span class="p">(</span><span class="n">head</span><span class="p">);</span> <span class="p">}</span>

                        <span class="c1">// extract out the data from the now-unlinked node</span>
                        <span class="k">return</span> <span class="nb">Some</span><span class="p">(</span><span class="k">unsafe</span> <span class="p">{</span> <span class="n">ptr</span><span class="o">::</span><span class="n">read</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">head</span><span class="p">).</span><span class="n">data</span><span class="p">)</span> <span class="p">})</span>
                    <span class="p">}</span>
                <span class="p">}</span>

                <span class="c1">// we observed the stack empty</span>
                <span class="nb">None</span> <span class="o">=&gt;</span> <span class="k">return</span> <span class="nb">None</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>Some obserations:</p>

<ul>
<li><p>The basic logic of the algorithm is identical to the version that relies on a
GC, except that we explicitly flag the popped node as &ldquo;unlinked&rdquo;. In general,
it&rsquo;s possible to take lock-free algorithms &ldquo;off the shelf&rdquo; (the ones on the
shelf generally assume a GC) and code them up directly against Crossbeam in
this way.</p></li>
<li><p>After we take a snapshot, we can dereference it without using <code>unsafe</code>,
because the <code>guard</code> guarantees its liveness.</p></li>
<li><p>The use of <code>ptr::read</code> here is justified by our use of compare-and-swap to
ensure that only one thread calls it, and the fact that the epoch reclamation
scheme <em>does not run destructors</em>, but merely deallocates memory.</p></li>
</ul>

<p>The last point about deallocation deserves a bit more comment, so let&rsquo;s wrap up
the API description by talking about garbage.</p>

<h3 id="managing-garbage">Managing garbage</h3>

<p>The design in Crossbeam treats epoch management as a service shared by all data
structures: there is a single static for global epoch state, and a single
thread-local for the per-thread state. This makes the epoch API very simple to
use, since there&rsquo;s no per-data structure setup. It also means the (rather
trivial) space usage is tied to the number of threads using epochs, not the
number of data structures.</p>

<p>One difference in Crossbeam&rsquo;s implementation from the existing literature on
epochs is that <em>each thread keeps local garbage lists</em>. That is, when a thread
marks a node as &ldquo;unlinked&rdquo; that node is added to some thread-local data, rather
than immediately to a global garbage list (which would require additional
synchronization).</p>

<p>Each time you call <code>epoch::pin()</code>, the current thread will check whether its
local garbage has surpassed a collection threshold, and if so, it will attempt a
collection. Likewise, whenever you call <code>epoch::pin()</code>, if the global epoch has
advanced past the previous snapshot, the current thread can collect some of its
garbage. Besides avoiding global synchronization around the garbage lists, this
new scheme spreads out the work of actually freeing memory among all the threads
accessing a data structure.</p>

<p>You can also manually trigger a collection:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span> <span class="n">Guard</span> <span class="p">{</span>
    <span class="c-Doc">/// Returns `true` if the garbage collection succeeded</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="n">try_collect</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">bool</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>Because GC can only occur if all active threads are on the current epoch, it&rsquo;s
not always possible to collect. But in practice, the garbage on a given thread
rarely exceeds the threshold.</p>

<p>There&rsquo;s one catch, though: because GC can fail, if a thread is exiting, it needs
to do <em>something</em> with its garbage. So the Crossbeam implementation <em>also</em> has
global garbage lists, which are used as a last-ditch place to throw garbage when
a thread exits. These global garbage lists are collected by the thread that
successfully increments the global epoch.</p>

<p>Finally, what does it mean to &ldquo;collect&rdquo; the garbage? As mentioned above, the
library <em>only</em> deallocates the memory; it does not run destructors. There are
many reasons for this:</p>

<p>-</p>

<h2 id="benchmarks">Benchmarks</h2>

<h2 id="looking-ahead">Looking ahead</h2>

</article>



      </main>

      <footer class="footer">
        <small>
          &copy; <time datetime="2015-08-25T15:19:53-07:00">2015</time>. All rights reserved.
        </small>
      </footer>
    </div>

  </body>
</html>
