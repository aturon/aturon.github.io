<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="UTF-8">
  <link href="http://gmpg.org/xfn/11" rel="profile">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>
    
      Shipping specialization: a story of soundness &middot; Aaron Turon
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/blog/styles.css">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/blog/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/blog/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/atom+xml" title="Aaron Turon" href="/blog/atom.xml">
</head>


  <body>

    <div class="container content">
      <header class="masthead">
        <h3 class="masthead-title">
          <a href="/blog/" title="Home">Aaron Turon</a>
          <small></small>

          
          &nbsp;&nbsp;&nbsp;
          <small><a href="/blog/archive">Archive</a></small>
          
          &nbsp;&nbsp;&nbsp;
          <small><a href="/blog/atom.xml">Feed</a></small>
          
        </h3>
      </header>

      <main>
        <article class="post">
  <h1 class="post-title">Shipping specialization: a story of soundness</h1>
  <time datetime="2017-07-08T00:00:00-07:00" class="post-date">08 Jul 2017</time>
  <p>Rust&rsquo;s <a href="https://github.com/rust-lang/rfcs/pull/1210"><code>impl</code> specialization</a> is a major language feature that appeared
after Rust 1.0, but has yet to be stabilized, despite strong demand.</p>

<p>Historically, there have been three big blockers to stabilization:</p>

<ul>
<li><p>The interplay between specialization rules and coherence, which I resovled in
<a href="http://aturon.github.io/blog/2017/02/06/specialization-and-coherence/">an earlier blog post</a>.</p></li>
<li><p>The precise ways in which specialization employs negative reasoning, which
will be resolved by incorporating ideas from <a href="https://github.com/nikomatsakis/chalk/">Chalk</a> into the compiler.</p></li>
<li><p>The soundness of specialization&rsquo;s interactions with lifetimes. The <a href="https://github.com/rust-lang/rfcs/pull/1210">RFC</a> talks
about this issue and proposes a way to address it, but it has never been
implemented, and early attempts to implement it in <a href="https://github.com/nikomatsakis/chalk/">Chalk</a> have revealed
serious problems.</p></li>
</ul>

<p>I&rsquo;ve been wrestling, together with nmatsakis, withoutboats and others, with
these soundness issues.</p>

<p><strong>Spoiler alert</strong>: we have not fully solved them yet. But we see a viable way to
ship a sound, useful subset of specialization in the meantime. Feel free to jump
to &ldquo;A modest proposal&rdquo; if you just want to hear about that.</p>

<p>This blog post is an attempt to write up what we&rsquo;ve learned so far, with the
hopes that it will clarify that thinking, and maybe open the door to <em>you</em>
cracking the nut!</p>

<h2 id="the-problem">The problem</h2>

<p>In stable Rust, it is <strong>not possible</strong> for lifetimes to influence runtime
behavior. This is partly an architectural issue, and partly a design issue:</p>

<ul>
<li><p><strong>Architecture</strong>: the compiler erases lifetime information prior to
monomorphization and code generation, meaning that the generated code simply
has no way to depend on lifetimes. That could be changed, but we&rsquo;d have to
work hard to avoid code blowup by generating separate copies of code
for each lifetime it was used within, assuming that the behavior didn&rsquo;t
change.</p></li>
<li><p><strong>Design</strong>: lifetime inference generally chooses the <em>smallest</em> lifetime that
fits the constraints at any given moment. That means that you can have a piece
of data that is valid for the <code>&#39;static</code> lifetime, yet is viewed as having a
shorter lifetime. Having runtime behavior depend on these choices seems bound
to result in confusion and bugs.</p></li>
</ul>

<p>Unfortunately, specialization makes the story more difficult:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span></span><span class="k">trait</span><span class="w"> </span><span class="n">Bad1</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">bad1</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Bad1</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">default</span> <span class="k">fn</span><span class="w"> </span><span class="n">bad1</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;generic&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Specialization cannot work: trans doesn&#39;t know if T: &#39;static</span>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">&#39;static</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Bad1</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">bad1</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;specialized&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="s">&quot;test&quot;</span><span class="p">.</span><span class="n">bad1</span><span class="p">()</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>What does this program print? Since the string literal <code>&quot;test&quot;</code> has type
<code>&amp;&#39;static str</code>, you might expect the second, specialized <code>impl</code> to be used (and
hence to get <code>specialized</code> as the output). But, as explained above, from the
perspective of trans this type will look like <code>&amp;&#39;erased str</code>, making it
impossible to know whether the more specialized <code>impl</code> can safely be used.</p>

<p>Here&rsquo;s another, less obvious example:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span></span><span class="k">trait</span><span class="w"> </span><span class="n">Bad2</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">U</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Bad2</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>

<span class="c1">// Specialization cannot work: trans doesn&#39;t know if two refs have equal lifetimes</span>
<span class="k">impl</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">U</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Bad2</span><span class="o">&lt;&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="n">U</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
</code></pre></div>
<p>Here, the second <code>impl</code> is requiring that two lifetimes are the same, and once
more for trans we can&rsquo;t tell whether the <code>impl</code> safely applies.</p>

<p>On the other hand, simply <em>naming</em> a lifetime that must exist, without
<em>constraining</em> it, is fine:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span></span><span class="k">trait</span><span class="w"> </span><span class="n">Good</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Good</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>

<span class="c1">// Fine: specializes based on being *any* reference, regardless of lifetime</span>
<span class="k">impl</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Good</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
</code></pre></div>
<p>In addition, it&rsquo;s in principle okay for lifetime constraints to show up as long
as they don&rsquo;t influence specialization:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span></span><span class="k">trait</span><span class="w"> </span><span class="n">MustBeStatic</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">&#39;static</span><span class="o">&gt;</span><span class="w"> </span><span class="n">MustBeStatic</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>

<span class="c1">// Potentially fine: *all* impls impose the &#39;static requirement; the dispatch is</span>
<span class="c1">// happening purely based on `Clone`</span>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">&#39;static</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Clone</span><span class="o">&gt;</span><span class="w"> </span><span class="n">MustBeStatic</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
</code></pre></div>
<h3 id="why-does-this-lead-to-unsoundness">Why does this lead to unsoundness?</h3>

<p>So far, it might seem like we can just be conservative in trans, which could
lead to confusing behavior but is otherwise alright.</p>

<p>Sadly, it&rsquo;s not, at least given the original design of specialization:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span></span><span class="k">trait</span><span class="w"> </span><span class="n">Bomb</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">Assoc</span>: <span class="nb">Default</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Bomb</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">default</span> <span class="k">type</span><span class="w"> </span><span class="n">Assoc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">Bomb</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="nb">&#39;static</span><span class="w"> </span><span class="kt">str</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">Assoc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">build</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Bomb</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">T</span>::<span class="n">Assoc</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">T</span>::<span class="n">Assoc</span>::<span class="n">default</span><span class="p">()</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">s</span>: <span class="nb">String</span> <span class="o">=</span><span class="w"> </span><span class="n">build</span><span class="p">(</span><span class="s">&quot;Uh oh&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">drop</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="c1">// typeck and trans disagree about the type of `s`</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>The problem here: specialization as originally designed will allow the
typechecker to conclude that <code>T::Assoc</code> is <code>String</code> if it knows that <code>T</code> is
<code>&amp;&#39;static str</code>. That&rsquo;s because the impl for <code>&amp;&#39;static str</code> does <em>not</em> use the
<code>default</code> keyword when defining its associated type, meaning that no further
specialization is allowed (so the type checker knows everything there is to
know).</p>

<p>But trans, of course, sees <code>&amp;&#39;erased str</code> instead, and so cannot safely use the
specialized <code>impl</code>. That means that trans will make the call to <code>build</code> return
<code>()</code>, but the rest of the code assumed that a <code>String</code> was returned.</p>

<p>Oops.</p>

<p>(Spoiler alert: the &ldquo;as originally designed&rdquo; bit above is a give-away of where
we&rsquo;re ultimately going to end up&hellip;)</p>

<h2 id="some-solutions-that-dont-work">Some &ldquo;solutions&rdquo; that don&rsquo;t work</h2>

<p>Before giving my proposed way forward, let me explain why some of the solution
that are probably coming to mind don&rsquo;t work out.</p>

<h3 id="cant-we-just-rule-out-bad-specializations">Can&rsquo;t we just rule out &ldquo;bad&rdquo; specializations?</h3>

<p>It&rsquo;s very tempting to blame the specialized <code>impl</code>s for <code>Bad1</code> and <code>Bad2</code> above,
since they clearly impose lifetime constraints. Maybe we could just make it an
error to do so.</p>

<p>Unfortunately, the trait system is very powerful, and you can &ldquo;hide&rdquo; lifetime
constraints within other trait impls that don&rsquo;t involve specialization. Worse
still: the problem can arise from two independent crates, each of which is doing
something seemingly reasonable.</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span></span><span class="c1">////////////////////////////////////////////////////////////////////////////////</span>
<span class="c1">// Crate marker</span>
<span class="c1">////////////////////////////////////////////////////////////////////////////////</span>

<span class="k">trait</span><span class="w"> </span><span class="n">Marker</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="k">impl</span><span class="w"> </span><span class="n">Marker</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="kt">u32</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////</span>
<span class="c1">// Crate foo</span>
<span class="c1">////////////////////////////////////////////////////////////////////////////////</span>

<span class="k">extern</span><span class="w"> </span><span class="k">crate</span><span class="w"> </span><span class="n">marker</span><span class="p">;</span><span class="w"></span>

<span class="k">trait</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">foo</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">default</span> <span class="k">fn</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;Default impl&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">marker</span>::<span class="n">Marker</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">foo</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;Marker impl&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////</span>
<span class="c1">// Crate bar</span>
<span class="c1">////////////////////////////////////////////////////////////////////////////////</span>

<span class="k">extern</span><span class="w"> </span><span class="k">crate</span><span class="w"> </span><span class="n">marker</span><span class="p">;</span><span class="w"></span>

<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Bar</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">T</span><span class="p">);</span><span class="w"></span>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">&#39;static</span><span class="o">&gt;</span><span class="w"> </span><span class="n">marker</span>::<span class="n">Marker</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Bar</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////</span>
<span class="c1">// Crate client</span>
<span class="c1">////////////////////////////////////////////////////////////////////////////////</span>

<span class="k">extern</span><span class="w"> </span><span class="k">crate</span><span class="w"> </span><span class="n">foo</span><span class="p">;</span><span class="w"></span>
<span class="k">extern</span><span class="w"> </span><span class="k">crate</span><span class="w"> </span><span class="n">bar</span><span class="p">;</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// prints: Marker impl</span>
<span class="w">    </span><span class="mi">0</span><span class="k">u32</span><span class="p">.</span><span class="n">foo</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="c1">// prints: ???</span>
<span class="w">    </span><span class="c1">// the relevant specialization depends on the &#39;static lifetime</span>
<span class="w">    </span><span class="n">bar</span>::<span class="n">Bar</span><span class="p">(</span><span class="s">&quot;Activate the marker!&quot;</span><span class="p">).</span><span class="n">foo</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>The problem here is that all of the crates in isolation look perfectly innocent.
The code in <code>marker</code>, <code>bar</code> and <code>client</code> is accepted today. It&rsquo;s only when these
crates are plugged together that a problem arises &ndash; you end up with a
specialization based on a <code>&#39;static</code> lifetime. And the <code>client</code> crate may not
even be aware of the existence of the <code>marker</code> crate.</p>

<p>If we make this kind of situation a hard error, we could easily end up with a
scenario in which plugging together otherwise-unrelated crates is
<em>impossible</em>. Or where a minor version bump in one dependency could irrevocably
break your code.</p>

<h3 id="can-we-make-a-knob-lifetime-dependent-vs-specializable">Can we make a knob: &ldquo;lifetime-dependent&rdquo; vs &ldquo;specializable&rdquo;?</h3>

<p>Thinking more about the previous example, you might imagine the problem is that
the <code>Marker</code> trait ends up being used in two incompatible ways:</p>

<ul>
<li>It&rsquo;s used in a specialization, the second <code>Foo</code> <code>impl</code>.</li>
<li>It&rsquo;s used in <code>impl</code>s that constrain lifetimes (the <code>Bar</code> <code>impl</code>).</li>
</ul>

<p>It&rsquo;s the combination of these things that gets us into trouble. And each one
arises from a different crate. So you might be tempted to add an attribute, say
<code>#[lifetime_sensitive]</code>, which allows for <code>impl</code>s that constrain lifetimes but
prevents use in specialization.</p>

<p>In other words, the <code>Marker</code> trait could say, in advance, whether the <code>Foo</code>
impls or the <code>Bar</code> impl are acceptable.</p>

<p>There are several downsides to this idea, but the real death-knell is that
&ldquo;constraining lifetimes&rdquo; is a surprisingly easy thing to do. To wit:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span></span><span class="k">trait</span><span class="w"> </span><span class="n">Sneaky</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">sneaky</span><span class="p">(</span><span class="bp">self</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Sneaky</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">default</span> <span class="k">fn</span><span class="w"> </span><span class="n">sneaky</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;generic&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Sneaky</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">sneaky</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;specialized&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// what does this print?</span>
<span class="w">    </span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;world&quot;</span><span class="p">).</span><span class="n">sneaky</span><span class="p">()</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>Here we have a specialized <code>impl</code> that doesn&rsquo;t mention any lifetimes or any
other traits; it just talks about the type <code>(T, T)</code>. The problem is that it&rsquo;s
asking for the two tuple components to have the <em>same</em> type, which means that
<em>if</em> a lifetime appears, it must be the same in both.</p>

<p>Once more, when we go to trans the <code>main</code> function, we&rsquo;ll be invoking <code>sneaky</code>
on the type <code>(&amp;&#39;erased str, &amp;&#39;erased str)</code>, and we can&rsquo;t tell for sure whether
the more specialized impl applies.</p>

<p>But saying that you can never repeat a type within a specialization would be
very restrictive. And there&rsquo;s always the worry that we&rsquo;ve missed other sneaky
ways to constrain lifetimes&hellip;</p>

<h3 id="can-we-make-trans-smarter">Can we make trans smarter?</h3>

<p>At this point it becomes tempting to start blaming trans. After all, if we
tracked lifetime information all the way through, wouldn&rsquo;t that solve
everything?</p>

<p>It would solve <em>some</em> things: it would make specialization sound. But at a high
cost.</p>

<p>As explained at the outset, tracking information through trans would involve a
massive overhaul of the compiler, and we&rsquo;d have to be very smart about
coalescing code with different lifetimes but identical behavior. There&rsquo;s no
guarantee we could do this without making the compiler significantly slower
and/or creating more code bloat.</p>

<p>More fundamentally, though, it would lead to highly unpredictable behavior:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span></span><span class="k">trait</span><span class="w"> </span><span class="n">Print</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">print</span><span class="p">(</span><span class="bp">self</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Print</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="kt">str</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">print</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;Arbitrary str: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Print</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="nb">&#39;static</span><span class="w"> </span><span class="kt">str</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">print</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;&#39;static str: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">print_str</span><span class="p">(</span><span class="n">s</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">s</span><span class="p">.</span><span class="n">print</span><span class="p">()</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;hello, world!&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">s</span><span class="p">.</span><span class="n">print</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">print_str</span><span class="p">(</span><span class="n">s</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>Does this program print <code>&#39;static str: hello, world!</code> twice?</p>

<p>No! Because the call to <code>print_str</code> will <em>reborrow</em> the string slice at a
shorter lifetime, and so trans will monomorphize it differently.</p>

<p>Making program behavior sensitive to the exact rules around lifetime inference
and reborrowing seems extremely risky.</p>

<h2 id="a-modest-proposal">A modest proposal</h2>

<p>Hopefully the above gives you some taste of the challenge here. Later in this
post we&rsquo;ll look at some more promising, clever solutions. But none of them have
worked out completely, so I want to pause here and propose an incremental step
forward.</p>

<p>First off, we add a new feature gate, <code>assoc_specialization</code>, which is needed
whenever you use <code>default type</code> in an impl. We then focus on stabilizing just
the core <code>specialization</code> feature, i.e. <em>without</em> being able to specialize
associated types. That immediately means we can stop worrying about making type
checking and trans agree, since type checking will essentially no longer care
about specialization.</p>

<p>Many uses of specialization, including most of the original motivating examples,
do not need to be able to specialize associated types.</p>

<p>With that out of the way, we still have work to do at the trans level. In
particular, we must ensure that trans is conservative when it comes to lifetime
constraints. The proposal here is twofold:</p>

<ul>
<li><p>Any time a specialized impl imposes <em>any</em> lifetime constraints not present in
the more general impl, trans uses the more general impl instead.</p></li>
<li><p>However, in these cases, we trigger an error-by-default lint to warn that a
possibly-applicable specialization is not being used. (This needs to be a
lint, not a hard error, because the relevant impls aren&rsquo;t always under your
crate&rsquo;s control.)</p></li>
</ul>

<p>Let&rsquo;s revisit some of the earlier examples in this light:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span></span><span class="c1">// Specialization cannot work: trans doesn&#39;t know if T: &#39;static:</span>
<span class="k">trait</span><span class="w"> </span><span class="n">Bad1</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">bad1</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Bad1</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">default</span> <span class="k">fn</span><span class="w"> </span><span class="n">bad1</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;generic&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">&#39;static</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Bad1</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">bad1</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;specialized&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// prints `generic`, but also generates a warning</span>
<span class="w">    </span><span class="s">&quot;test&quot;</span><span class="p">.</span><span class="n">bad1</span><span class="p">()</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>For this example, trans would pick the generic implementation, but issue a
warning that a specialization <em>might</em> have applied. You could imagine going
further and detecting simple cases like this where a given impl will <em>never</em> be
used (as in the second impl of <code>Bad1</code>) and issuing errors. But as explained
above, we cannot catch them all.</p>

<p>On the other hand, consider this case:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span></span><span class="k">trait</span><span class="w"> </span><span class="n">MustBeStatic</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">&#39;static</span><span class="o">&gt;</span><span class="w"> </span><span class="n">MustBeStatic</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">&#39;static</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Clone</span><span class="o">&gt;</span><span class="w"> </span><span class="n">MustBeStatic</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
</code></pre></div>
<p>Here, both impls impose <code>&#39;static</code> constraints, so the second impl doesn&rsquo;t impose
any <em>new</em> lifetime constraints, and trans can choose it.</p>

<p>To make this work, in trans, when we query the trait system we replace each
instance of <code>&#39;erased</code> with a <em>distinct, fresh</em> lifetime variable, which is a
simple way to encode that anything we deduce in the query must be valid for
<em>all</em> sets of unerased lifetimes. The <a href="https://github.com/nikomatsakis/chalk/">Chalk</a> approach will make this quite easy
to do.</p>

<p>Even for the cases we&rsquo;re covering, though, it&rsquo;s possible to do better (we&rsquo;ll see
more on that later). That means we might want to &ldquo;improve&rdquo; the behavior of trans
after stabilizing the core of specialization. Fortunately, we should be able to
statically detect all cases where the behavior of trans would change, and issue
a different warning that the behavior will improve. That gives us leverage to
use something like <a href="https://github.com/rust-lang/rfcs/pull/2052">epochs</a> to make trans smarter over time, while still
shipping some version of specialization relatively soon.</p>

<p>The only alternative seems to be to continue to pursue increasingly clever
solutions before shipping anything&mdash;which is a worrying approach to take when
it comes to soundness. Better, in my opinion, to ship a sound 80% of the feature
now, with some rough edges, and improve it over time.</p>

<h2 id="going-deeper">Going deeper</h2>

<p>Before I close out this post, I want to write out some of the further
explorations we&rsquo;ve done, and what we&rsquo;ve learned.</p>

<p>Here&rsquo;s an interesting example:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span></span><span class="k">trait</span><span class="w"> </span><span class="n">Special</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">special</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Special</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">default</span> <span class="k">fn</span><span class="w"> </span><span class="n">special</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;generic&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Special</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">special</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;specialized&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">pair</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">Clone</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">clone</span><span class="p">(),</span><span class="w"> </span><span class="n">t</span><span class="p">).</span><span class="n">special</span><span class="p">()</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">pair</span><span class="p">(</span><span class="s">&quot;hi&quot;</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>Using the strategy outlined above, trans will go from <code>(&amp;&#39;erased str, &amp;&#39;erased
str)</code> to <code>(&amp;&#39;a str, &amp;&#39;b str)</code> and hence use the generic implementation (and
issue a lint that the more specific impl is being ignored). However, <em>type
check</em> could deduce that the more specialized impl always applies when invoking
<code>special</code> in <code>pair</code>, and you could imagine communicating that information down
to trans.</p>

<p>What&rsquo;s going on here is that type check sees things before monomorphization, and
trans sees them afterward. In this particular case, that ends up making trans
more conservative, since it can&rsquo;t tell that two appearances of <code>&#39;erased</code> always
come from the same, single lifetime.</p>

<p>The story changes if we add one layer of &ldquo;indirection&rdquo; around trait dispatch:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span></span><span class="k">trait</span><span class="w"> </span><span class="n">Special</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">special</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Special</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">default</span> <span class="k">fn</span><span class="w"> </span><span class="n">special</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;generic&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Special</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">special</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;specialized&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">use_special</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Special</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">t</span><span class="p">.</span><span class="n">special</span><span class="p">()</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">pair</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">Clone</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">use_special</span><span class="p">((</span><span class="n">t</span><span class="p">.</span><span class="n">clone</span><span class="p">(),</span><span class="w"> </span><span class="n">t</span><span class="p">))</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">pair</span><span class="p">(</span><span class="s">&quot;hi&quot;</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>Now at type checking time, the actual use of <code>special</code> occurs in a context where
we <em>don&rsquo;t</em> know that we&rsquo;ll always be using the more specialized version.</p>

<p>Why harp on this point? Well, for one, it&rsquo;s the main issue in allowing for sound
specialization of associated types. We can see this in a variant of the <code>Bomb</code>
example:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span></span><span class="k">trait</span><span class="w"> </span><span class="n">Bomb</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">Assoc</span>: <span class="nb">Default</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Bomb</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">default</span> <span class="k">type</span><span class="w"> </span><span class="n">Assoc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Bomb</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">Assoc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">build</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Bomb</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="o">&lt;</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">Bomb</span><span class="o">&gt;</span>::<span class="n">Assoc</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="o">&lt;</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">Bomb</span><span class="o">&gt;</span>::<span class="n">Assoc</span>::<span class="n">default</span><span class="p">()</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">s</span>: <span class="nb">String</span> <span class="o">=</span><span class="w"> </span><span class="n">build</span><span class="p">(</span><span class="s">&quot;Uh oh&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">drop</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="c1">// typeck and trans disagree about the type of `s`</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>Here, again, type check knows that the relevant uses of <code>Bomb</code> all involve types
of the form <code>(T, T)</code> and therefore can use the specialized version, and that
could be communicated to trans. But, once more, adding a layer of indirection
makes that much harder:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span></span><span class="k">trait</span><span class="w"> </span><span class="n">Bomb</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">Assoc</span>: <span class="nb">Default</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Bomb</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">default</span> <span class="k">type</span><span class="w"> </span><span class="n">Assoc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Bomb</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span> <span class="nc">Assoc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">indirect</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Bomb</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">T</span>::<span class="n">Assoc</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">T</span>::<span class="n">Assoc</span>::<span class="n">default</span><span class="p">()</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">build</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Bomb</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="o">&lt;</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">Bomb</span><span class="o">&gt;</span>::<span class="n">Assoc</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">indirect</span>::<span class="o">&lt;</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="o">&gt;</span><span class="p">()</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">s</span>: <span class="nb">String</span> <span class="o">=</span><span class="w"> </span><span class="n">build</span><span class="p">(</span><span class="s">&quot;Uh oh&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">drop</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="c1">// typeck and trans disagree about the type of `s`</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>The problem is that type check can no longer tell trans to use the specialized
impl in the call to <code>Assoc::default</code>, <em>but</em> it is still assuming that the
specialized impl is used externally (i.e., in the <code>build</code> function).</p>

<p>To sum up, there are two inter-related places where type check and trans differ:</p>

<ul>
<li>Lifetime erasure</li>
<li>Monomorphization</li>
</ul>

<p>We can partly deal with the first of these by introducing fresh lifetime
variables for each lifetime that appears in type check, just as we do for
trans&mdash;basically asking for the trait system to only find answers that would
apply for arbitrary lifetime choices.</p>

<p>The monomorphization issue, though, appears much harder to cope with. One
possible avenue is to track impl choices in a way that crosses functions, in
other words allowing the knowledge from <code>build</code> that the specialized impl of
<code>Bomb</code> can be used to be used when monomorphizing and generating code for
<code>indirect</code>. Niko tells me that, in ancient times, the compiler used to do
something much like this&mdash;and that it was incredibly painful and complicated.</p>

<p>In any case, taking these further steps would appear to require substantial
additional work, and it seems hard to achieve confidence in their soundness. So
dropping associated type specialization for now, where it&rsquo;s relatively easy to
argue for soundness, seems like the right step to take (@arielb1, here&rsquo;s where
you prove me wrong).</p>

</article>


<aside class="related">
  <h2>Related Posts</h2>
  <ul class="related-posts">
    
      <li>
        <h3>
          <a href="/blog/2018/01/16/libs-mission/">
            Retooling the Rust Libs Team team for 2018
            <small><time datetime="2018-01-16T00:00:00-08:00">16 Jan 2018</time></small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/blog/2018/01/09/rust-2018/">
            Rust in 2018: a people perspective
            <small><time datetime="2018-01-09T00:00:00-08:00">09 Jan 2018</time></small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/blog/2017/08/02/modules-part-2/">
            Revisiting Rust’s modules, part 2
            <small><time datetime="2017-08-02T00:00:00-07:00">02 Aug 2017</time></small>
          </a>
        </h3>
      </li>
    
  </ul>
</aside>


      </main>

      <footer class="footer">
        <small>
          &copy; <time datetime="2018-01-16T16:56:58-08:00">2018</time>. All rights reserved.
        </small>
      </footer>
    </div>

  </body>
</html>
