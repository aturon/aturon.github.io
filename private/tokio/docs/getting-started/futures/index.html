<!DOCTYPE html>
<html lang="en">
  <head>
    
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="x-ua-compatible" content="ie=edge">

    
    <link rel="stylesheet" href="/css/bootstrap-reboot.css">
    <link rel="stylesheet" href="/css/bootstrap.css">
    <link rel="stylesheet" href="/css/font-awesome.min.css">
    <link rel="stylesheet" href="/css/tokio.css">

    <title>Futures</title>
  </head>
  <body>
    <nav class="navbar navbar-light bg-faded">
      <ul class="nav navbar-nav">
        <li class="nav-item">
          <a class="navbar-brand" href="/"><img src="/img/logo.png" width="44"
            height="40" class="align-middle" alt=""></a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="/">Home <span class="sr-only">(current)</span></a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="http://tokio.rs.s3-website-us-east-1.amazonaws.com/docs/getting-started/tokio/">Documentation</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="http://tokio.rs.s3-website-us-east-1.amazonaws.com/community/">Community</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="http://tokio.rs.s3-website-us-east-1.amazonaws.com/blog/tokio-0/">Blog</a>
        </li>
      </ul>
    </nav>


<div class="tk-pageheader">
  <div class="container">
    <h1 class="display-4">Futures</h1>
    <p class="lead">A productive, zero-cost approach to asynchrony</p>
  </div>
</div>

<div class="container">
  <div class="row">
    <div class="col-md-3">

      <nav class="leftnav">
        <div class="" id="">
          <h5>Getting started</h5>
          <hr/>

          <div class="" id="">
            <ul class="nav">
              
              <li class="active">
                <a href="/docs/getting-started/tokio/" class="text-muted">What is Tokio?</a>
              </li>
              
              <li class="active">
                <a href="/docs/getting-started/simple-server/" class="text-muted">Example: an echo server using proto</a>
              </li>
              
              <li class="active">
                <a href="/docs/getting-started/futures/" class="text-muted">Futures</a>
              </li>
              
              <li class="active">
                <a href="/docs/getting-started/db/" class="text-muted">Example: serving database content using proto</a>
              </li>
              
              <li class="active">
                <a href="/docs/getting-started/streams-and-sinks/" class="text-muted">Streams and sinks</a>
              </li>
              
              <li class="active">
                <a href="/docs/getting-started/reactor/" class="text-muted">Understanding event loops</a>
              </li>
              
              <li class="active">
                <a href="/docs/getting-started/core/" class="text-muted">High-level I/O using core</a>
              </li>
              
              <li class="active">
                <a href="/docs/getting-started/pipeline-server/" class="text-muted">Example: a simple pipelined server using core</a>
              </li>
              
              <li class="active">
                <a href="/docs/getting-started/tls/" class="text-muted">Example: a toy HTTP&#43;TLS client using core</a>
              </li>
              
              <li class="active">
                <a href="/docs/getting-started/simple-client/" class="text-muted">Example: a client with proto</a>
              </li>
              
            </ul>
          </div>

          <br/>
          <h5>Going deeper</h5>
          <hr/>

          <div class="" id="">
            <ul class="nav">
              
              <li class="active">
                <a href="/docs/going-deeper/futures-mechanics/" class="text-muted">Essential combinators</a>
              </li>
              
              <li class="active">
                <a href="/docs/going-deeper/returning/" class="text-muted">Returning futures</a>
              </li>
              
              <li class="active">
                <a href="/docs/going-deeper/futures-model/" class="text-muted">The futures-rs model in depth</a>
              </li>
              
              <li class="active">
                <a href="/docs/going-deeper/synchronization/" class="text-muted">Synchronization</a>
              </li>
              
              <li class="active">
                <a href="/docs/going-deeper/core-low-level/" class="text-muted">Low-level I/O using core</a>
              </li>
              
              <li class="active">
                <a href="/docs/going-deeper/multiplex/" class="text-muted">Multiplexed protocols</a>
              </li>
              
              <li class="active">
                <a href="/docs/going-deeper/streaming/" class="text-muted">Streaming protocols</a>
              </li>
              
              <li class="active">
                <a href="/docs/going-deeper/tasks/" class="text-muted">Tasks and executors</a>
              </li>
              
              <li class="active">
                <a href="/docs/going-deeper/examples/" class="text-muted">Larger examples</a>
              </li>
              
              <li class="active">
                <a href="/docs/going-deeper/third-party/" class="text-muted">Third-party crates</a>
              </li>
              
            </ul>
          </div>
        </div>
      </nav>

    </div>
    <div class="col-md-9">
      <div class="tk-content">
        

<p>Tokio is fundamentally based on <em>asynchronous I/O</em>. While you don&rsquo;t need to have
a deep understanding of async I/O to use Tokio, it&rsquo;s good to have the basic picture.</p>

<p>Let&rsquo;s start with a simple piece of I/O you might want to perform: reading a
certain number of bytes from a socket. Rust&rsquo;s standard library provides a
function,
<a href="https://static.rust-lang.org/doc/master/std/io/trait.Read.html#method.read_exact"><code>read_exact</code></a>,
to do this:</p>

<pre><code class="language-rust">// reads 4096 bytes into `my_vec`
socket.read_exact(&amp;mut my_vec[..4096]);
</code></pre>

<p><strong>Quick quiz</strong>: what happens if the socket hasn&rsquo;t received 4096 bytes yet?</p>

<p>Since the standard library is based on <em>synchronous</em> I/O, the answer is that the
calling thread is blocked, sleeping until more bytes are available. While that
works well in some contexts, it can be a problem for scaling up servers: if we
want to serve a large number of clients concurrently, but each request might
involve blocking a thread, then we&rsquo;re going to need a large number of threads.</p>

<p>In the asynchronous world, instead of blocking until requests can be completed,
we register that we <em>want</em> to perform a certain request, and are later notified
when that request can be fulfilled. That means that we can use a single thread
to manage an arbitrary number of connections, with each connection using minimal
resources.</p>

<p>Somehow, though, we&rsquo;ve got to manage all of those in-flight requests. It&rsquo;d be
nice if we could write code in terms of individual connections and operations,
and have all of that tracking and dispatching taken care of for us.</p>

<p>That&rsquo;s where futures come in.</p>

<h2 id="futures">Futures</h2>

<p>A future is a value that&rsquo;s in the process of being computed, but might not be
ready yet. Usually, the future becomes <em>complete</em> (the value is ready) due to an
event happening somewhere else. While we&rsquo;ve been looking at things from the
perspective of basic I/O, you can use a future to represent a wide range of
events, e.g.:</p>

<ul>
<li><p><strong>A database query</strong> that&rsquo;s executing in a thread pool. When the query finishes,
the future is completed, and its value is the result of the query.</p></li>

<li><p><strong>An RPC invocation</strong> to a server. When the server replies, the future is
completed, and its value is the server&rsquo;s response.</p></li>

<li><p><strong>A timeout</strong>. When time is up, the future is completed, and its value is
<code>()</code>.</p></li>

<li><p><strong>A long-running CPU-intensive task</strong>, running on a thread pool. When the task
finishes, the future is completed, and its value is the return value of the
task.</p></li>

<li><p><strong>Reading bytes from a socket</strong>. When the bytes are ready, the future is completed
&ndash; and depending on the buffering strategy, the bytes might be returned
directly, or written as a side-effect into some existing buffer.</p></li>
</ul>

<p>In short, futures are applicable to asynchronous events of all shapes and
sizes. The asynchrony is reflected in the fact that you get a <em>future</em> right
away, without blocking, even though the <em>value</em> the future represents will
become ready only at some unknown time in the&hellip; future.</p>

<h4 id="a-simple-example">A simple example</h4>

<p>Let&rsquo;s make this concrete with an example: we&rsquo;ll take a long-running computation
and add a timeout to it using futures.</p>

<pre><code class="language-shell">cargo new --bin prime-timeout
cd prime-timeout
</code></pre>

<p>Here we&rsquo;ll bring in futures and a couple additional tools on top:</p>

<pre><code class="language-toml">[dependencies]
futures = &quot;0.1.7&quot;
futures-cpupool = &quot;0.1.2&quot;
tokio-timer = { git = &quot;https://github.com/tokio-rs/tokio-timer&quot; }
</code></pre>

<p>For our lengthy computation, we&rsquo;ll inefficiently confirm that a large prime
number is prime:</p>

<pre><code class="language-rust">CONST BIG_PRIME: u64 = 15485867;

// checks whether a number is prime, slowly
fn is_prime(num: u64) -&gt; bool {
    for i in 2..num {
        if i % num == 0 { return false }
    }
    true
}
</code></pre>

<h5 id="synchronous-version">Synchronous version</h5>

<p>Before we use futures, here&rsquo;s how we&rsquo;d run this computation synchronously&mdash;we
just call the function:</p>

<pre><code class="language-rust">// Synchronous version
fn main() {
    if is_prime(BIG_PRIME) {
        println!(&quot;Prime&quot;);
    } else {
        println!(&quot;Not prime&quot;);
    }
}
</code></pre>

<p>The effect is that the main thread is blocked until the computation finishes,
and then it prints out the result.</p>

<h5 id="asynchronous-version">Asynchronous version</h5>

<p>Now let&rsquo;s use futures and a thread pool to launch the computation
asynchronously:</p>

<pre><code class="language-rust">use futures::Future;
use futures_cpupool::CpuPool;

fn main() {
    // set up a thread pool
    let pool = CpuPool::new_num_cpus();

    // spawn our computation, getting back a *future* of the answer
    let prime_future = pool.spawn_fn(|| {
        let prime = is_prime(BIG_PRIME);

        // For reasons we'll see later, we need to return a Result here
        let res: Result&lt;bool, ()&gt; = Ok(prime);
        res
    });

    println!(&quot;Created the future&quot;);
}
</code></pre>

<p>This version of the code pushes work onto a thread pool, and <em>immediately</em>
returns a future, <code>prime_future</code>. Thus, we&rsquo;ll see <code>Created the future</code> on the
console right away, while the primality test is done in the background. Of
course, this isn&rsquo;t so useful&mdash;we&rsquo;ve thrown away the answer!</p>

<p>Even though futures are asynchronous, you always have the option of treating
them synchronously, by <em>waiting</em> for completion:</p>

<pre><code class="language-rust">// ...

println!(&quot;Created the future&quot;);

// unwrap here since we know the result is Ok
if prime_future.wait().unwrap() {
    println!(&quot;Prime&quot;);
} else {
    println!(&quot;Not prime&quot;);
}
</code></pre>

<p>While
<a href="https://docs.rs/futures/0.1.7/futures/future/trait.Future.html#method.wait"><code>wait</code></a>
isn&rsquo;t very commonly used in practice, it&rsquo;s a nice illustration of the difference
between a future (like <code>prime_future</code>) and the value it produces; the future is
returned right away, allowing you to do additional work concurrently (like
printing a message, here), and retrieve the value later on.</p>

<h5 id="adding-a-timeout">Adding a timeout</h5>

<p>So far this example isn&rsquo;t terribly interesting, since there are simpler ways to
work with thread pools. But one strength of futures is their ability to
<em>combine</em>. We&rsquo;ll show this off by combining the thread pool future with a
timeout future:</p>

<pre><code class="language-rust">use tokio_timer::Timer;
use futures::Future;
use std::time::Duration;
use futures_cpupool::CpuPool;

fn main() {
    let pool = CpuPool::new_num_cpus();
    let timer = Timer::default();

    // a future that resolves to Err after a timeout
    let timeout = timer.sleep(Duration::from_millis(750))
        .then(|_| Err(()));

    // a future that resolves to Ok with the primality result
    let prime = pool.spawn_fn(|| {
        Ok(is_prime(BIG_PRIME))
    });

    // a future that resolves to one of the above values -- whichever
    // completes first!
    let winner = timeout.select(prime).map(|(win, _)| win);

    // now block until we have a winner, than print what happened
    match winner.wait() {
        Ok(true) =&gt; println!(&quot;Prime&quot;),
        Ok(false) =&gt; println!(&quot;Not prime&quot;),
        Err(_) =&gt; println!(&quot;Timed out&quot;),
    }
}
</code></pre>

<p>Here, we&rsquo;re using a couple of additional methods on futures:</p>

<ul>
<li><p><a href="https://docs.rs/futures/0.1.7/futures/future/trait.Future.html#method.then"><code>then</code></a>,
which in general allows you to sequence one future to run after getting the
value of another. In this case, we&rsquo;re just using it to change the value
returned from the timeout future to <code>Err(())</code>.</p></li>

<li><p><a href="https://docs.rs/futures/0.1.7/futures/future/trait.Future.html#method.select"><code>select</code></a>,
which combines two futures of the same type, allowing them to &ldquo;race&rdquo; to
completion. It yields a pair, where the first component is the value produced
by the first future to complete, and the second gives you the other future
back. Here, we just take the winning value.</p></li>
</ul>

<p>While this example is simplistic, it gives some sense for how futures scale
up. Once you have a number of basic &ldquo;events&rdquo; set up as futures, you can combine
them in complex ways, and the futures library takes care of tracking all of the
relevant state and synchronization.</p>

<h5 id="whence-i-o">Whence I/O?</h5>

<p>We haven&rsquo;t shown how to work directly with I/O events as futures. That&rsquo;s because
I/O is a bit more complicated, and you often end up working with sibling
abstractions to futures: streams and sinks. These are all covered in subsequent
guides.</p>

<h2 id="the-future-trait">The <code>Future</code> trait</h2>

<p>At this point, we&rsquo;ve seen just a tiny bit of the futures API&mdash;but what actually
<em>is</em> a future?</p>

<p>In the <code>futures-rs</code> library, a future is anything that implements the
<a href="https://docs.rs/futures/0.1.7/futures/future/trait.Future.html"><code>Future</code> trait</a>,
which has a lot of similarities to the
<a href="https://static.rust-lang.org/doc/master/std/iter/trait.Iterator.html"><code>Iterator</code> trait</a>
in the standard library:</p>

<pre><code class="language-rust">trait Future {
    // The type of value that the future yields on successful completion.
    type Item;

    // The type of value that the future yields on failure.
    type Error;

    // The only required method, which attempts to complete the future.
    fn poll(&amp;mut self) -&gt; Poll&lt;Self::Item, Self::Error&gt;;

    // Blocks until completion.
    fn wait(self) -&gt; Result&lt;Self::Item, Self::Error&gt; { ... }

    // Transforms the result of the future using the gives closure.
    fn map&lt;F, U&gt;(self, f: F) -&gt; Map&lt;Self, F&gt;
        where F: FnOnce(Self::Item) -&gt; U { ... }

    // ... and many, many more provided methods
}
</code></pre>

<p>Since futures are primarily motivated by I/O, error handling is an important
concern baked in to the trait and its methods.</p>

<p>The <code>poll</code> method is the heart of the futures trait&mdash;it&rsquo;s how futures actually
do their work. However, it&rsquo;s not generally called directly. Instead, you tend to
work through the other methods of the <code>Future</code> trait (which are all default methods).
You can find an in-depth explanation of <code>poll</code> in TODO.</p>

<p>So that&rsquo;s the quick tour. In the next section, we&rsquo;ll look at a more involved
example: hooking up a database to the <a href="../simple-server">line-based protocol</a> we
developed earlier.</p>

        
        <div class="tk-next"><b>Next up</b>: <a href = /docs/getting-started/db/>
         Example: serving database content using proto</a></div>
      </div>
    </div>
  </div>
</div>

    <footer class="tk-footer">
      <div class="container text-muted">
        <div class="col-md-6">
          Copyright Â© 2016 Tokio Project
        </div>
        <div class="col-md-6">
          <div class="pull-right">
            <a href="https://twitter.com/tokio_rs" class="text-muted"><i class="fa fa-twitter" aria-hidden="true"></i></a>
            <a href="https://github.com/tokio-rs/tokio" class="text-muted"><i class="fa fa-github" aria-hidden="true"></i></a>
          </div>
        </div>
      </div>
    </footer>

    
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js" integrity="sha384-3ceskX3iaEnIogmQchP8opvBy3Mi7Ce34nWjpBIwVTHfGYWQS9jwHDVRnpKKHJg7" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tether/1.3.7/js/tether.min.js" integrity="sha384-XTs3FgkjiBgo8qjEjBk0tGmf3wPrWtA6coPfQDfFEY8AnYJwjalXCiosYRBIBZX8" crossorigin="anonymous"></script>
    <script src="/js/bootstrap.min.js"></script>
    <script src="/js/highlight.js"></script>
    <script>
      $(function () {
        $("pre code").each(function(i, block) {
          
          hljs.highlightBlock(block);
        });
      });
    </script>
  </body>
</html>

