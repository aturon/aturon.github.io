<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="generator" content="rustdoc">
    <title>The Rust Language Tutorial</title>

    <link rel="stylesheet" type="text/css" href="rust.css">

    <link rel="shortcut icon" href="http://www.rust-lang.org/favicon.ico">


</head>
<body>
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <div id="versioninfo">
  <img src="http://www.rust-lang.org/logos/rust-logo-32x32-blk.png" width="32" height="32" alt><br>
  <span class="white-sticker"><a href="http://rust-lang.org">Rust</a> 0.11.0</span><br>
  <a href="http://github.com/rust-lang/rust/commit/305cf1f1098dc87e346003e6bf7e7cca5705a135"
    class="hash white-sticker">305cf1f1</a>
</div>


    <h1 class="title">The Rust Language Tutorial</h1>
    <nav id="TOC"><ul>
<li><a href="#introduction">1 Introduction</a><ul>
<li><a href="#scope">1.1 Scope</a><ul></ul></li>
<li><a href="#conventions">1.2 Conventions</a><ul></ul></li></ul></li>
<li><a href="#getting-started">2 Getting started</a><ul>
<li><a href="#compiling-your-first-program">2.1 Compiling your first program</a><ul></ul></li>
<li><a href="#editing-rust-code">2.2 Editing Rust code</a><ul></ul></li></ul></li>
<li><a href="#syntax-basics">3 Syntax basics</a><ul>
<li><a href="#expressions-and-semicolons">3.1 Expressions and semicolons</a><ul></ul></li>
<li><a href="#primitive-types-and-literals">3.2 Primitive types and literals</a><ul></ul></li>
<li><a href="#operators">3.3 Operators</a><ul></ul></li>
<li><a href="#syntax-extensions">3.4 Syntax extensions</a><ul></ul></li></ul></li>
<li><a href="#control-structures">4 Control structures</a><ul>
<li><a href="#conditionals">4.1 Conditionals</a><ul></ul></li>
<li><a href="#pattern-matching">4.2 Pattern matching</a><ul></ul></li>
<li><a href="#loops">4.3 Loops</a><ul></ul></li></ul></li>
<li><a href="#data-structures">5 Data structures</a><ul>
<li><a href="#structs">5.1 Structs</a><ul></ul></li>
<li><a href="#enums">5.2 Enums</a><ul></ul></li>
<li><a href="#tuples">5.3 Tuples</a><ul></ul></li>
<li><a href="#tuple-structs">5.4 Tuple structs</a><ul></ul></li></ul></li>
<li><a href="#functions">6 Functions</a><ul></ul></li>
<li><a href="#destructors">7 Destructors</a><ul></ul></li>
<li><a href="#ownership">8 Ownership</a><ul></ul></li>
<li><a href="#implementing-a-linked-list">9 Implementing a linked list</a><ul>
<li><a href="#boxes">9.1 Boxes</a><ul></ul></li>
<li><a href="#move-semantics">9.2 Move semantics</a><ul></ul></li>
<li><a href="#references">9.3 References</a><ul></ul></li>
<li><a href="#lists-of-other-types">9.4 Lists of other types</a><ul></ul></li>
<li><a href="#defining-list-equality-with-generics">9.5 Defining list equality with generics</a><ul></ul></li></ul></li>
<li><a href="#more-on-boxes">10 More on boxes</a><ul></ul></li>
<li><a href="#references-1">11 References</a><ul>
<li><a href="#freezing">11.1 Freezing</a><ul></ul></li></ul></li>
<li><a href="#dereferencing-pointers">12 Dereferencing pointers</a><ul></ul></li>
<li><a href="#vectors-and-strings">13 Vectors and strings</a><ul></ul></li>
<li><a href="#ownership-escape-hatches">14 Ownership escape hatches</a><ul></ul></li>
<li><a href="#closures">15 Closures</a><ul>
<li><a href="#owned-closures">15.1 Owned closures</a><ul></ul></li>
<li><a href="#closure-compatibility">15.2 Closure compatibility</a><ul></ul></li></ul></li>
<li><a href="#methods">16 Methods</a><ul></ul></li>
<li><a href="#generics">17 Generics</a><ul>
<li><a href="#traits">17.1 Traits</a><ul></ul></li>
<li><a href="#declaring-and-implementing-traits">17.2 Declaring and implementing traits</a><ul></ul></li>
<li><a href="#default-method-implementations-in-trait-definitions">17.3 Default method implementations in trait definitions</a><ul></ul></li>
<li><a href="#type-parameterized-traits">17.4 Type-parameterized traits</a><ul></ul></li>
<li><a href="#bounded-type-parameters-and-static-method-dispatch">17.5 Bounded type parameters and static method dispatch</a><ul></ul></li>
<li><a href="#trait-objects-and-dynamic-method-dispatch">17.6 Trait objects and dynamic method dispatch</a><ul></ul></li>
<li><a href="#trait-inheritance">17.7 Trait inheritance</a><ul></ul></li>
<li><a href="#deriving-implementations-for-traits">17.8 Deriving implementations for traits</a><ul></ul></li></ul></li>
<li><a href="#crates-and-the-module-system">18 Crates and the module system</a><ul>
<li><a href="#crates">18.1 Crates</a><ul></ul></li>
<li><a href="#the-module-hierarchy">18.2 The module hierarchy</a><ul></ul></li>
<li><a href="#paths-and-visibility">18.3 Paths and visibility</a><ul></ul></li>
<li><a href="#files-and-modules">18.4 Files and modules</a><ul></ul></li>
<li><a href="#importing-names-into-the-local-scope">18.5 Importing names into the local scope</a><ul></ul></li>
<li><a href="#reexporting-names">18.6 Reexporting names</a><ul></ul></li>
<li><a href="#using-libraries">18.7 Using libraries</a><ul></ul></li>
<li><a href="#crate-metadata-and-settings">18.8 Crate metadata and settings</a><ul></ul></li>
<li><a href="#a-minimal-example">18.9 A minimal example</a><ul></ul></li>
<li><a href="#the-standard-library-and-the-prelude">18.10 The standard library and the prelude</a><ul></ul></li></ul></li>
<li><a href="#what-next?">19 What next?</a><ul></ul></li></ul></nav><div style="border: 2px solid red; padding:5px;">
The tutorial is undergoing a complete re-write as <a href="guide.html">the Guide</a>.
Until it's ready, this tutorial is the right place to come to start learning
Rust.  Please submit improvements as pull requests, but understand that
eventually it will be going away.
</div>

<h1 id="introduction" class='section-header'><a
                           href="#introduction">1 Introduction</a></h1>
<p>Rust is a programming language with a focus on type safety, memory
safety, concurrency and performance. It is intended for writing
large-scale, high-performance software that is free from several
classes of common errors. Rust has a sophisticated memory model that
encourages efficient data structures and safe concurrency patterns,
forbidding invalid memory accesses that would otherwise cause
segmentation faults. It is statically typed and compiled ahead of
time.</p>

<p>As a multi-paradigm language, Rust supports writing code in
procedural, functional and object-oriented styles. Some of its
pleasant high-level features include:</p>

<ul>
<li><strong>Type inference.</strong> Type annotations on local variable declarations
are optional.</li>
<li><strong>Safe task-based concurrency.</strong> Rust&#39;s lightweight tasks do not share
memory, instead communicating through messages.</li>
<li><strong>Higher-order functions.</strong> Efficient and flexible closures provide
iteration and other control structures</li>
<li><strong>Pattern matching and algebraic data types.</strong> Pattern matching on
Rust&#39;s enumeration types (a more powerful version of C&#39;s enums,
similar to algebraic data types in functional languages) is a
compact and expressive way to encode program logic.</li>
<li><strong>Polymorphism.</strong> Rust has type-parametric functions and
types, type classes and OO-style interfaces.</li>
</ul>

<h2 id="scope" class='section-header'><a
                           href="#scope">1.1 Scope</a></h2>
<p>This is an introductory tutorial for the Rust programming language. It
covers the fundamentals of the language, including the syntax, the
type system and memory model, generics, and modules. <a href="#what-next?">Additional
tutorials</a> cover specific language features in greater
depth.</p>

<p>This tutorial assumes that the reader is already familiar with one or
more languages in the C family. Understanding of pointers and general
memory management techniques will help.</p>

<h2 id="conventions" class='section-header'><a
                           href="#conventions">1.2 Conventions</a></h2>
<p>Throughout the tutorial, language keywords and identifiers defined in
example code are displayed in <code>code font</code>.</p>

<p>Code snippets are indented, and also shown in a monospaced font. Not
all snippets constitute whole programs. For brevity, we&#39;ll often show
fragments of programs that don&#39;t compile on their own. To try them
out, you might have to wrap them in <code>fn main() { ... }</code>, and make sure
they don&#39;t contain references to names that aren&#39;t actually defined.</p>

<blockquote>
<p><em>Warning:</em> Rust is a language under ongoing development. Notes
about potential changes to the language, implementation
deficiencies, and other caveats appear offset in blockquotes.</p>
</blockquote>

<h1 id="getting-started" class='section-header'><a
                           href="#getting-started">2 Getting started</a></h1>
<p>There are two ways to install the Rust compiler: by building from source or
by downloading prebuilt binaries or installers for your platform. The
<a href="http://www.rust-lang.org/install.html">install page</a> contains links to download binaries for both
the nightly build and the most current Rust major release. For Windows and
OS X, the install page provides links to native installers.</p>

<blockquote>
<p><em>Note:</em> Windows users should read the detailed
<a href="https://github.com/rust-lang/rust/wiki/Note-getting-started-developing-Rust">Getting started</a> notes on the wiki. Even when using
the binary installer, the Windows build requires a MinGW installation,
the precise details of which are not discussed here.</p>
</blockquote>

<p>For Linux and OS X, the install page provides links to binary tarballs.
To install the Rust compiler from the from a binary tarball, download
the binary package, extract it, and execute the <code>install.sh</code> script in
the root directory of the package.</p>

<p>To build the Rust compiler from source, you will need to obtain the source through
<a href="https://github.com/rust-lang/rust.git">Git</a> or by downloading the source package from the <a href="http://www.rust-lang.org/install.html">install page</a>.</p>

<p>Since the Rust compiler is written in Rust, it must be built by
a precompiled &quot;snapshot&quot; version of itself (made in an earlier state
of development). The source build automatically fetches these snapshots
from the Internet on our supported platforms.</p>

<p>Snapshot binaries are currently built and tested on several platforms:</p>

<ul>
<li>Windows (7, 8, Server 2008 R2), x86 only</li>
<li>Linux (2.6.18 or later, various distributions), x86 and x86-64</li>
<li>OSX 10.7 (Lion) or greater, x86 and x86-64</li>
</ul>

<p>You may find that other platforms work, but these are our &quot;tier 1&quot;
supported build environments that are most likely to work.</p>

<p>To build from source you will also need the following prerequisite
packages:</p>

<ul>
<li>g++ 4.7 or clang++ 3.x</li>
<li>python 2.6 or later (but not 3.x)</li>
<li>perl 5.0 or later</li>
<li>gnu make 3.81 or later</li>
<li>curl</li>
</ul>

<p>If you&#39;ve fulfilled those prerequisites, something along these lines
should work.</p>

<pre><code class="language-console">$ curl -O http://static.rust-lang.org/dist/rust-nightly.tar.gz
$ tar -xzf rust-nightly.tar.gz
$ cd rust-nightly
$ ./configure
$ make &amp;&amp; make install</code></pre>

<p>You may need to use <code>sudo make install</code> if you do not normally have
permission to modify the destination directory. The install locations
can be adjusted by passing a <code>--prefix</code> argument to
<code>configure</code>. Various other options are also supported: pass <code>--help</code>
for more information on them.</p>

<p>When complete, <code>make install</code> will place several programs into
<code>/usr/local/bin</code>: <code>rustc</code>, the Rust compiler, and <code>rustdoc</code>, the
API-documentation tool.</p>

<h2 id="compiling-your-first-program" class='section-header'><a
                           href="#compiling-your-first-program">2.1 Compiling your first program</a></h2>
<p>Rust program files are, by convention, given the extension <code>.rs</code>. Say
we have a file <code>hello.rs</code> containing this program:</p>
<span id='rust-example-raw-0' class='rusttest'>fn main() {
    println!(&quot;hello?&quot;);
}</span><pre id='rust-example-rendered-0' class='rust '>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;hello?&quot;</span>);
}
</pre>

<blockquote>
<p><em>Note:</em> An identifier followed by an exclamation point, like
<code>println!</code>, is a macro invocation.  Macros are explained
<a href="#syntax-extensions">later</a>; for now just remember to include the
exclamation point.</p>
</blockquote>

<p>If the Rust compiler was installed successfully, running <code>rustc
hello.rs</code> will produce an executable called <code>hello</code> (or <code>hello.exe</code> on
Windows) which, upon running, will likely do exactly what you expect.</p>

<p>The Rust compiler tries to provide useful information when it encounters an
error. If you introduce an error into the program (for example, by changing
<code>println!</code> to some nonexistent macro), and then compile it, you&#39;ll see
an error message like this:</p>

<pre><code class="language-text">hello.rs:2:5: 2:24 error: macro undefined: &#39;print_with_unicorns&#39;
hello.rs:2     print_with_unicorns!(&quot;hello?&quot;);
               ^~~~~~~~~~~~~~~~~~~</code></pre>

<p>In its simplest form, a Rust program is a <code>.rs</code> file with some types
and functions defined in it. If it has a <code>main</code> function, it can be
compiled to an executable. Rust does not allow code that&#39;s not a
declaration to appear at the top level of the file: all statements must
live inside a function.  Rust programs can also be compiled as
libraries, and included in other programs, even ones not written in Rust.</p>

<h2 id="editing-rust-code" class='section-header'><a
                           href="#editing-rust-code">2.2 Editing Rust code</a></h2>
<p>There are vim highlighting and indentation scripts in the Rust source
distribution under <code>src/etc/vim/</code>. There is an emacs mode under
<code>src/etc/emacs/</code> called <code>rust-mode</code>, but do read the instructions
included in that directory. In particular, if you are running emacs
24, then using emacs&#39;s internal package manager to install <code>rust-mode</code>
is the easiest way to keep it up to date. There is also a package for
Sublime Text 2, available both <a href="http://github.com/jhasse/sublime-rust">standalone</a> and through
<a href="http://wbond.net/sublime_packages/package_control">Sublime Package Control</a>, and support for Kate
under <code>src/etc/kate</code>.</p>

<p>A community-maintained list of available Rust tooling is <a href="https://github.com/rust-lang/rust/wiki/Doc-packages,-editors,-and-other-tools">on the
wiki</a>.</p>

<p>There is ctags support via <code>src/etc/ctags.rust</code>, but many other
tools and editors are not yet supported. If you end up writing a Rust
mode for your favorite editor, let us know so that we can link to it.</p>

<h1 id="syntax-basics" class='section-header'><a
                           href="#syntax-basics">3 Syntax basics</a></h1>
<p>Assuming you&#39;ve programmed in any C-family language (C++, Java,
JavaScript, C#, or PHP), Rust will feel familiar. Code is arranged
in blocks delineated by curly braces; there are control structures
for branching and looping, like the familiar <code>if</code> and <code>while</code>; function
calls are written <code>myfunc(arg1, arg2)</code>; operators are written the same
and mostly have the same precedence as in C; comments are again like C;
module names are separated with double-colon (<code>::</code>) as with C++.</p>

<p>The main surface difference to be aware of is that the condition at
the head of control structures like <code>if</code> and <code>while</code> does not require
parentheses, while their bodies <em>must</em> be wrapped in
braces. Single-statement, unbraced bodies are not allowed.</p>
<span id='rust-example-raw-1' class='rusttest'>mod universe { pub fn recalibrate() -&gt; bool { true } }
fn main() {
    /* A simple loop */
    loop {
        // A tricky calculation
        if universe::recalibrate() {
            return;
        }
    }
}</span><pre id='rust-example-rendered-1' class='rust '>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='comment'>/* A simple loop */</span>
    <span class='kw'>loop</span> {
        <span class='comment'>// A tricky calculation</span>
        <span class='kw'>if</span> <span class='ident'>universe</span>::<span class='ident'>recalibrate</span>() {
            <span class='kw'>return</span>;
        }
    }
}
</pre>

<p>The <code>let</code> keyword introduces a local variable. Variables are immutable by
default. To introduce a local variable that you can re-assign later, use <code>let
mut</code> instead.</p>
<span id='rust-example-raw-2' class='rusttest'>fn main() {
    let hi = &quot;hi&quot;;
    let mut count = 0i;
    
    while count &lt; 10 {
        println!(&quot;count is {}&quot;, count);
        count += 1;
    }
}</span><pre id='rust-example-rendered-2' class='rust '>
<span class='kw'>let</span> <span class='ident'>hi</span> <span class='op'>=</span> <span class='string'>&quot;hi&quot;</span>;
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>count</span> <span class='op'>=</span> <span class='number'>0i</span>;

<span class='kw'>while</span> <span class='ident'>count</span> <span class='op'>&lt;</span> <span class='number'>10</span> {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;count is {}&quot;</span>, <span class='ident'>count</span>);
    <span class='ident'>count</span> <span class='op'>+=</span> <span class='number'>1</span>;
}
</pre>

<p>Although Rust can almost always infer the types of local variables, you can
specify a variable&#39;s type by following it in the <code>let</code> with a colon, then the
type name. Static items, on the other hand, always require a type annotation.</p>
<span id='rust-example-raw-3' class='rusttest'>fn main() {
    static MONSTER_FACTOR: f64 = 57.8;
    let monster_size = MONSTER_FACTOR * 10.0;
    let monster_size: int = 50;
}</span><pre id='rust-example-rendered-3' class='rust '>
<span class='kw'>static</span> <span class='ident'>MONSTER_FACTOR</span>: <span class='ident'>f64</span> <span class='op'>=</span> <span class='number'>57.8</span>;
<span class='kw'>let</span> <span class='ident'>monster_size</span> <span class='op'>=</span> <span class='ident'>MONSTER_FACTOR</span> <span class='op'>*</span> <span class='number'>10.0</span>;
<span class='kw'>let</span> <span class='ident'>monster_size</span>: <span class='ident'>int</span> <span class='op'>=</span> <span class='number'>50</span>;
</pre>

<p>Local variables may shadow earlier declarations, as in the previous example:
<code>monster_size</code> was first declared as a <code>f64</code>, and then a second
<code>monster_size</code> was declared as an <code>int</code>. If you were to actually compile this
example, though, the compiler would determine that the first <code>monster_size</code> is
unused and issue a warning (because this situation is likely to indicate a
programmer error). For occasions where unused variables are intentional, their
names may be prefixed with an underscore to silence the warning, like <code>let
_monster_size = 50;</code>.</p>

<p>Rust identifiers start with an alphabetic
character or an underscore, and after that may contain any sequence of
alphabetic characters, numbers, or underscores. The preferred style is to
write function, variable, and module names with lowercase letters, using
underscores where they help readability, while writing types in camel case.</p>
<span id='rust-example-raw-4' class='rusttest'>fn main() {
    let my_variable = 100i;
    type MyType = int;     // primitive types are _not_ camel case
}</span><pre id='rust-example-rendered-4' class='rust '>
<span class='kw'>let</span> <span class='ident'>my_variable</span> <span class='op'>=</span> <span class='number'>100i</span>;
<span class='kw'>type</span> <span class='ident'>MyType</span> <span class='op'>=</span> <span class='ident'>int</span>;     <span class='comment'>// primitive types are _not_ camel case</span>
</pre>

<h2 id="expressions-and-semicolons" class='section-header'><a
                           href="#expressions-and-semicolons">3.1 Expressions and semicolons</a></h2>
<p>Though it isn&#39;t apparent in all code, there is a fundamental
difference between Rust&#39;s syntax and predecessors like C.
Many constructs that are statements in C are expressions
in Rust, allowing code to be more concise. For example, you might
write a piece of code like this:</p>
<span id='rust-example-raw-5' class='rusttest'>fn main() {
    let item = &quot;salad&quot;;
    let price: f64;
    if item == &quot;salad&quot; {
        price = 3.50;
    } else if item == &quot;muffin&quot; {
        price = 2.25;
    } else {
        price = 2.00;
    }
}</span><pre id='rust-example-rendered-5' class='rust '>
<span class='kw'>let</span> <span class='ident'>price</span>: <span class='ident'>f64</span>;
<span class='kw'>if</span> <span class='ident'>item</span> <span class='op'>==</span> <span class='string'>&quot;salad&quot;</span> {
    <span class='ident'>price</span> <span class='op'>=</span> <span class='number'>3.50</span>;
} <span class='kw'>else</span> <span class='kw'>if</span> <span class='ident'>item</span> <span class='op'>==</span> <span class='string'>&quot;muffin&quot;</span> {
    <span class='ident'>price</span> <span class='op'>=</span> <span class='number'>2.25</span>;
} <span class='kw'>else</span> {
    <span class='ident'>price</span> <span class='op'>=</span> <span class='number'>2.00</span>;
}
</pre>

<p>But, in Rust, you don&#39;t have to repeat the name <code>price</code>:</p>
<span id='rust-example-raw-6' class='rusttest'>fn main() {
    let item = &quot;salad&quot;;
    let price: f64 =
        if item == &quot;salad&quot; {
            3.50
        } else if item == &quot;muffin&quot; {
            2.25
        } else {
            2.00
        };
}</span><pre id='rust-example-rendered-6' class='rust '>
<span class='kw'>let</span> <span class='ident'>price</span>: <span class='ident'>f64</span> <span class='op'>=</span>
    <span class='kw'>if</span> <span class='ident'>item</span> <span class='op'>==</span> <span class='string'>&quot;salad&quot;</span> {
        <span class='number'>3.50</span>
    } <span class='kw'>else</span> <span class='kw'>if</span> <span class='ident'>item</span> <span class='op'>==</span> <span class='string'>&quot;muffin&quot;</span> {
        <span class='number'>2.25</span>
    } <span class='kw'>else</span> {
        <span class='number'>2.00</span>
    };
</pre>

<p>Both pieces of code are exactly equivalent: they assign a value to
<code>price</code> depending on the condition that holds. Note that there
are no semicolons in the blocks of the second snippet. This is
important: the lack of a semicolon after the last statement in a
braced block gives the whole block the value of that last expression.</p>

<p>Put another way, the semicolon in Rust <em>ignores the value of an expression</em>.
Thus, if the branches of the <code>if</code> had looked like <code>{ 4; }</code>, the above example
would simply assign <code>()</code> (unit or void) to <code>price</code>. But without the semicolon, each
branch has a different value, and <code>price</code> gets the value of the branch that
was taken.</p>

<p>In short, everything that&#39;s not a declaration (declarations are <code>let</code> for
variables; <code>fn</code> for functions; and any top-level named items such as
<a href="#traits">traits</a>, <a href="#enums">enum types</a>, and static items) is an
expression, including function bodies.</p>
<span id='rust-example-raw-7' class='rusttest'>fn main() {
    fn is_four(x: int) -&gt; bool {
       // No need for a return statement. The result of the expression
       // is used as the return value.
       x == 4
    }
}</span><pre id='rust-example-rendered-7' class='rust '>
<span class='kw'>fn</span> <span class='ident'>is_four</span>(<span class='ident'>x</span>: <span class='ident'>int</span>) <span class='op'>-&gt;</span> <span class='ident'>bool</span> {
   <span class='comment'>// No need for a return statement. The result of the expression</span>
   <span class='comment'>// is used as the return value.</span>
   <span class='ident'>x</span> <span class='op'>==</span> <span class='number'>4</span>
}
</pre>

<h2 id="primitive-types-and-literals" class='section-header'><a
                           href="#primitive-types-and-literals">3.2 Primitive types and literals</a></h2>
<p>There are general signed and unsigned integer types, <code>int</code> and <code>uint</code>,
as well as 8-, 16-, 32-, and 64-bit variants, <code>i8</code>, <code>u16</code>, etc.
Integers can be written in decimal (<code>144</code>), hexadecimal (<code>0x90</code>), octal (<code>0o70</code>), or
binary (<code>0b10010000</code>) base. Each integral type has a corresponding literal
suffix that can be used to indicate the type of a literal: <code>i</code> for <code>int</code>,
<code>u</code> for <code>uint</code>, <code>i8</code> for the <code>i8</code> type.</p>

<p>In the absence of an integer literal suffix, Rust will infer the
integer type based on type annotations and function signatures in the
surrounding program. In the absence of any type information at all,
Rust will report an error and request that the type be specified explicitly.</p>
<span id='rust-example-raw-8' class='rusttest'>fn main() {
    let a: int = 1;  // `a` is an `int`
    let b = 10i;     // `b` is an `int`, due to the `i` suffix
    let c = 100u;    // `c` is a `uint`
    let d = 1000i32; // `d` is an `i32`
}</span><pre id='rust-example-rendered-8' class='rust '>
<span class='kw'>let</span> <span class='ident'>a</span>: <span class='ident'>int</span> <span class='op'>=</span> <span class='number'>1</span>;  <span class='comment'>// `a` is an `int`</span>
<span class='kw'>let</span> <span class='ident'>b</span> <span class='op'>=</span> <span class='number'>10i</span>;     <span class='comment'>// `b` is an `int`, due to the `i` suffix</span>
<span class='kw'>let</span> <span class='ident'>c</span> <span class='op'>=</span> <span class='number'>100u</span>;    <span class='comment'>// `c` is a `uint`</span>
<span class='kw'>let</span> <span class='ident'>d</span> <span class='op'>=</span> <span class='number'>1000i32</span>; <span class='comment'>// `d` is an `i32`</span>
</pre>

<p>There are two floating-point types: <code>f32</code>, and <code>f64</code>.
Floating-point numbers are written <code>0.0</code>, <code>1e6</code>, or <code>2.1e-4</code>.
Like integers, floating-point literals are inferred to the correct type.
Suffixes <code>f32</code>, and <code>f64</code> can be used to create literals of a specific type.</p>

<p>The keywords <code>true</code> and <code>false</code> produce literals of type <code>bool</code>.</p>

<p>Characters, the <code>char</code> type, are four-byte Unicode codepoints,
whose literals are written between single quotes, as in <code>&#39;x&#39;</code>.
Just like C, Rust understands a number of character escapes, using the backslash
character, such as <code>\n</code>, <code>\r</code>, and <code>\t</code>. String literals,
written between double quotes, allow the same escape sequences, and do no
other processing, unlike languages such as PHP or shell.</p>

<p>On the other hand, raw string literals do not process any escape sequences.
They are written as <code>r##&quot;blah&quot;##</code>, with a matching number of zero or more <code>#</code>
before the opening and after the closing quote, and can contain any sequence of
characters except their closing delimiter.  More on strings
<a href="#vectors-and-strings">later</a>.</p>

<p>The unit type, written <code>()</code>, has a single value, also written <code>()</code>.</p>

<h2 id="operators" class='section-header'><a
                           href="#operators">3.3 Operators</a></h2>
<p>Rust&#39;s set of operators contains very few surprises. Arithmetic is done with
<code>*</code>, <code>/</code>, <code>%</code>, <code>+</code>, and <code>-</code> (multiply, quotient, remainder, add, and subtract). <code>-</code> is
also a unary prefix operator that negates numbers. As in C, the bitwise operators
<code>&gt;&gt;</code>, <code>&lt;&lt;</code>, <code>&amp;</code>, <code>|</code>, and <code>^</code> are also supported.</p>

<p>Note that, if applied to an integer value, <code>!</code> flips all the bits (bitwise
NOT, like <code>~</code> in C).</p>

<p>The comparison operators are the traditional <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>,
<code>&lt;=</code>, and <code>&gt;=</code>. Short-circuiting (lazy) boolean operators are written
<code>&amp;&amp;</code> (and) and <code>||</code> (or).</p>

<p>For compile-time type casting, Rust uses the binary <code>as</code> operator.  It takes
an expression on the left side and a type on the right side and will, if a
meaningful conversion exists, convert the result of the expression to the
given type. Generally, <code>as</code> is only used with the primitive numeric types or
pointers, and is not overloadable.  <a href="http://doc.rust-lang.org/std/mem/fn.transmute.html"><code>transmute</code></a> can be used for
unsafe C-like casting of same-sized types.</p>
<span id='rust-example-raw-9' class='rusttest'>fn main() {
    let x: f64 = 4.0;
    let y: uint = x as uint;
    assert!(y == 4u);
}</span><pre id='rust-example-rendered-9' class='rust '>
<span class='kw'>let</span> <span class='ident'>x</span>: <span class='ident'>f64</span> <span class='op'>=</span> <span class='number'>4.0</span>;
<span class='kw'>let</span> <span class='ident'>y</span>: <span class='ident'>uint</span> <span class='op'>=</span> <span class='ident'>x</span> <span class='kw'>as</span> <span class='ident'>uint</span>;
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>y</span> <span class='op'>==</span> <span class='number'>4u</span>);
</pre>

<h2 id="syntax-extensions" class='section-header'><a
                           href="#syntax-extensions">3.4 Syntax extensions</a></h2>
<p><em>Syntax extensions</em> are special forms that are not built into the language,
but are instead provided by the libraries. To make it clear to the reader when
a name refers to a syntax extension, the names of all syntax extensions end
with <code>!</code>. The standard library defines a few syntax extensions, the most
useful of which is <a href="http://doc.rust-lang.org/std/fmt/"><code>format!</code></a>, a <code>sprintf</code>-like text formatter that you
will often see in examples, and its related family of macros: <code>print!</code>,
<code>println!</code>, and <code>write!</code>.</p>

<p><code>format!</code> draws syntax from Python, but contains many of the same principles
that <a href="http://en.cppreference.com/w/cpp/io/c/fprintf">printf</a> has. Unlike printf, <code>format!</code> will give you a compile-time
error when the types of the directives don&#39;t match the types of the arguments.</p>
<span id='rust-example-raw-10' class='rusttest'>fn main() {
    // `{}` will print the &quot;default format&quot; of a type
    println!(&quot;{} is {}&quot;, &quot;the answer&quot;, 43i);
}</span><pre id='rust-example-rendered-10' class='rust '>
<span class='comment'>// `{}` will print the &quot;default format&quot; of a type</span>
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{} is {}&quot;</span>, <span class='string'>&quot;the answer&quot;</span>, <span class='number'>43i</span>);
</pre>
<span id='rust-example-raw-11' class='rusttest'>extern crate debug;

fn main() {
let mystery_object = ();
// `{:?}` will conveniently print any type,
// but requires the `debug` crate to be linked in
println!(&quot;what is this thing: {:?}&quot;, mystery_object);
}</span><pre id='rust-example-rendered-11' class='rust '>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>debug</span>;

<span class='comment'>// `{:?}` will conveniently print any type,</span>
<span class='comment'>// but requires the `debug` crate to be linked in</span>
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;what is this thing: {:?}&quot;</span>, <span class='ident'>mystery_object</span>);
</pre>

<p>You can define your own syntax extensions with the macro system. For details,
see the <a href="guide-macros.html">macro tutorial</a>. Note that macro definition is currently
considered an unstable feature.</p>

<h1 id="control-structures" class='section-header'><a
                           href="#control-structures">4 Control structures</a></h1>
<h2 id="conditionals" class='section-header'><a
                           href="#conditionals">4.1 Conditionals</a></h2>
<p>We&#39;ve seen <code>if</code> expressions a few times already. To recap, braces are
compulsory, an <code>if</code> can have an optional <code>else</code> clause, and multiple
<code>if</code>/<code>else</code> constructs can be chained together:</p>
<span id='rust-example-raw-12' class='rusttest'>fn main() {
    if false {
        println!(&quot;that&#39;s odd&quot;);
    } else if true {
        println!(&quot;right&quot;);
    } else {
        println!(&quot;neither true nor false&quot;);
    }
}</span><pre id='rust-example-rendered-12' class='rust '>
<span class='kw'>if</span> <span class='boolval'>false</span> {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;that&#39;s odd&quot;</span>);
} <span class='kw'>else</span> <span class='kw'>if</span> <span class='boolval'>true</span> {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;right&quot;</span>);
} <span class='kw'>else</span> {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;neither true nor false&quot;</span>);
}
</pre>

<p>The condition given to an <code>if</code> construct <em>must</em> be of type <code>bool</code> (no
implicit conversion happens). If the arms are blocks that have a
value, this value must be of the same type for every arm in which
control reaches the end of the block:</p>
<span id='rust-example-raw-13' class='rusttest'>fn main() {
    fn signum(x: int) -&gt; int {
        if x &lt; 0 { -1 }
        else if x &gt; 0 { 1 }
        else { 0 }
    }
}</span><pre id='rust-example-rendered-13' class='rust '>
<span class='kw'>fn</span> <span class='ident'>signum</span>(<span class='ident'>x</span>: <span class='ident'>int</span>) <span class='op'>-&gt;</span> <span class='ident'>int</span> {
    <span class='kw'>if</span> <span class='ident'>x</span> <span class='op'>&lt;</span> <span class='number'>0</span> { <span class='op'>-</span><span class='number'>1</span> }
    <span class='kw'>else</span> <span class='kw'>if</span> <span class='ident'>x</span> <span class='op'>&gt;</span> <span class='number'>0</span> { <span class='number'>1</span> }
    <span class='kw'>else</span> { <span class='number'>0</span> }
}
</pre>

<h2 id="pattern-matching" class='section-header'><a
                           href="#pattern-matching">4.2 Pattern matching</a></h2>
<p>Rust&#39;s <code>match</code> construct is a generalized, cleaned-up version of C&#39;s
<code>switch</code> construct. You provide it with a value and a number of
<em>arms</em>, each labeled with a pattern, and the code compares the value
against each pattern in order until one matches. The matching pattern
executes its corresponding arm.</p>
<span id='rust-example-raw-14' class='rusttest'>fn main() {
    let my_number = 1i;
    match my_number {
      0     =&gt; println!(&quot;zero&quot;),
      1 | 2 =&gt; println!(&quot;one or two&quot;),
      3..10 =&gt; println!(&quot;three to ten&quot;),
      _     =&gt; println!(&quot;something else&quot;)
    }
}</span><pre id='rust-example-rendered-14' class='rust '>
<span class='kw'>let</span> <span class='ident'>my_number</span> <span class='op'>=</span> <span class='number'>1i</span>;
<span class='kw'>match</span> <span class='ident'>my_number</span> {
  <span class='number'>0</span>     <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;zero&quot;</span>),
  <span class='number'>1</span> <span class='op'>|</span> <span class='number'>2</span> <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;one or two&quot;</span>),
  <span class='number'>3</span>..<span class='number'>10</span> <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;three to ten&quot;</span>),
  _     <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;something else&quot;</span>)
}
</pre>

<p>Unlike in C, there is no &quot;falling through&quot; between arms: only one arm
executes, and it doesn&#39;t have to explicitly <code>break</code> out of the
construct when it is finished.</p>

<p>A <code>match</code> arm consists of a <em>pattern</em>, then a fat arrow <code>=&gt;</code>, followed
by an <em>action</em> (expression). Each case is separated by commas. It is
often convenient to use a block expression for each case, in which case
the commas are optional as shown below. Literals are valid patterns and
match only their own value. A single arm may match multiple different
patterns by combining them with the pipe operator (<code>|</code>), so long as
every pattern binds the same set of variables (see &quot;destructuring&quot;
below). Ranges of numeric literal patterns can be expressed with two
dots, as in <code>M..N</code>. The underscore (<code>_</code>) is a wildcard pattern that
matches any single value. (<code>..</code>) is a different wildcard that can match
one or more fields in an <code>enum</code> variant.</p>
<span id='rust-example-raw-15' class='rusttest'>fn main() {
    let my_number = 1i;
    match my_number {
      0 =&gt; { println!(&quot;zero&quot;) }
      _ =&gt; { println!(&quot;something else&quot;) }
    }
}</span><pre id='rust-example-rendered-15' class='rust '>
<span class='kw'>match</span> <span class='ident'>my_number</span> {
  <span class='number'>0</span> <span class='op'>=&gt;</span> { <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;zero&quot;</span>) }
  _ <span class='op'>=&gt;</span> { <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;something else&quot;</span>) }
}
</pre>

<p><code>match</code> constructs must be <em>exhaustive</em>: they must have an arm
covering every possible case. For example, the typechecker would
reject the previous example if the arm with the wildcard pattern was
omitted.</p>

<p>A powerful application of pattern matching is <em>destructuring</em>:
matching in order to bind names to the contents of data types.</p>

<blockquote>
<p><em>Note:</em> The following code makes use of tuples (<code>(f64, f64)</code>) which
are explained in section 5.3. For now you can think of tuples as a list of
items.</p>
</blockquote>
<span id='rust-example-raw-16' class='rusttest'>fn main() {
    use std::f64;
    fn angle(vector: (f64, f64)) -&gt; f64 {
        let pi = f64::consts::PI;
        match vector {
          (0.0, y) if y &lt; 0.0 =&gt; 1.5 * pi,
          (0.0, _) =&gt; 0.5 * pi,
          (x, y) =&gt; (y / x).atan()
        }
    }
}</span><pre id='rust-example-rendered-16' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>f64</span>;
<span class='kw'>fn</span> <span class='ident'>angle</span>(<span class='ident'>vector</span>: (<span class='ident'>f64</span>, <span class='ident'>f64</span>)) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
    <span class='kw'>let</span> <span class='ident'>pi</span> <span class='op'>=</span> <span class='ident'>f64</span>::<span class='ident'>consts</span>::<span class='ident'>PI</span>;
    <span class='kw'>match</span> <span class='ident'>vector</span> {
      (<span class='number'>0.0</span>, <span class='ident'>y</span>) <span class='kw'>if</span> <span class='ident'>y</span> <span class='op'>&lt;</span> <span class='number'>0.0</span> <span class='op'>=&gt;</span> <span class='number'>1.5</span> <span class='op'>*</span> <span class='ident'>pi</span>,
      (<span class='number'>0.0</span>, _) <span class='op'>=&gt;</span> <span class='number'>0.5</span> <span class='op'>*</span> <span class='ident'>pi</span>,
      (<span class='ident'>x</span>, <span class='ident'>y</span>) <span class='op'>=&gt;</span> (<span class='ident'>y</span> <span class='op'>/</span> <span class='ident'>x</span>).<span class='ident'>atan</span>()
    }
}
</pre>

<p>A variable name in a pattern matches any value, <em>and</em> binds that name
to the value of the matched value inside of the arm&#39;s action. Thus, <code>(0.0,
y)</code> matches any tuple whose first element is zero, and binds <code>y</code> to
the second element. <code>(x, y)</code> matches any two-element tuple, and binds both
elements to variables. <code>(0.0,_)</code> matches any tuple whose first element is zero
and does not bind anything to the second element.</p>

<p>A subpattern can also be bound to a variable, using <code>variable @ pattern</code>. For
example:</p>
<span id='rust-example-raw-17' class='rusttest'>fn main() {
    let age = 23i;
    match age {
        a @ 0..20 =&gt; println!(&quot;{} years old&quot;, a),
        _ =&gt; println!(&quot;older than 21&quot;)
    }
}</span><pre id='rust-example-rendered-17' class='rust '>
<span class='kw'>match</span> <span class='ident'>age</span> {
    <span class='ident'>a</span> <span class='kw-2'>@</span> <span class='number'>0</span>..<span class='number'>20</span> <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{} years old&quot;</span>, <span class='ident'>a</span>),
    _ <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;older than 21&quot;</span>)
}
</pre>

<p>Any <code>match</code> arm can have a guard clause (written <code>if EXPR</code>), called a
<em>pattern guard</em>, which is an expression of type <code>bool</code> that
determines, after the pattern is found to match, whether the arm is
taken or not. The variables bound by the pattern are in scope in this
guard expression. The first arm in the <code>angle</code> example shows an
example of a pattern guard.</p>

<p>You&#39;ve already seen simple <code>let</code> bindings, but <code>let</code> is a little
fancier than you&#39;ve been led to believe. It, too, supports destructuring
patterns. For example, you can write this to extract the fields from a
tuple, introducing two variables at once: <code>a</code> and <code>b</code>.</p>
<span id='rust-example-raw-18' class='rusttest'>fn main() {
    fn get_tuple_of_two_ints() -&gt; (int, int) { (1, 1) }
    let (a, b) = get_tuple_of_two_ints();
}</span><pre id='rust-example-rendered-18' class='rust '>
<span class='kw'>let</span> (<span class='ident'>a</span>, <span class='ident'>b</span>) <span class='op'>=</span> <span class='ident'>get_tuple_of_two_ints</span>();
</pre>

<p>Let bindings only work with <em>irrefutable</em> patterns: that is, patterns that can
never fail to match. This excludes <code>let</code> from matching literals and most <code>enum</code>
variants as binding patterns, since most such patterns are not irrefutable. For
example, this will not compile:</p>
<span id='rust-example-raw-19' class='rusttest'>fn main() {
    let (a, 2) = (1, 2);
}</span><pre id='rust-example-rendered-19' class='rust '>
<span class='kw'>let</span> (<span class='ident'>a</span>, <span class='number'>2</span>) <span class='op'>=</span> (<span class='number'>1</span>, <span class='number'>2</span>);
</pre>

<h2 id="loops" class='section-header'><a
                           href="#loops">4.3 Loops</a></h2>
<p><code>while</code> denotes a loop that iterates as long as its given condition
(which must have type <code>bool</code>) evaluates to <code>true</code>. Inside a loop, the
keyword <code>break</code> aborts the loop, and <code>continue</code> aborts the current
iteration and continues with the next.</p>
<span id='rust-example-raw-20' class='rusttest'>fn main() {
    let mut cake_amount = 8i;
    while cake_amount &gt; 0 {
        cake_amount -= 1;
    }
}</span><pre id='rust-example-rendered-20' class='rust '>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>cake_amount</span> <span class='op'>=</span> <span class='number'>8i</span>;
<span class='kw'>while</span> <span class='ident'>cake_amount</span> <span class='op'>&gt;</span> <span class='number'>0</span> {
    <span class='ident'>cake_amount</span> <span class='op'>-=</span> <span class='number'>1</span>;
}
</pre>

<p><code>loop</code> denotes an infinite loop, and is the preferred way of writing <code>while true</code>:</p>
<span id='rust-example-raw-21' class='rusttest'>fn main() {
    let mut x = 5u;
    loop {
        x += x - 3;
        if x % 5 == 0 { break; }
        println!(&quot;{}&quot;, x);
    }
}</span><pre id='rust-example-rendered-21' class='rust '>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5u</span>;
<span class='kw'>loop</span> {
    <span class='ident'>x</span> <span class='op'>+=</span> <span class='ident'>x</span> <span class='op'>-</span> <span class='number'>3</span>;
    <span class='kw'>if</span> <span class='ident'>x</span> <span class='op'>%</span> <span class='number'>5</span> <span class='op'>==</span> <span class='number'>0</span> { <span class='kw'>break</span>; }
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>x</span>);
}
</pre>

<p>This code prints out a weird sequence of numbers and stops as soon as
it finds one that can be divided by five.</p>

<p>There is also a for-loop that can be used to iterate over a range of numbers:</p>
<span id='rust-example-raw-22' class='rusttest'>fn main() {
    for n in range(0u, 5) {
        println!(&quot;{}&quot;, n);
    }
}</span><pre id='rust-example-rendered-22' class='rust '>
<span class='kw'>for</span> <span class='ident'>n</span> <span class='kw'>in</span> <span class='ident'>range</span>(<span class='number'>0u</span>, <span class='number'>5</span>) {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>n</span>);
}
</pre>

<p>The snippet above prints integer numbers under 5 starting at 0.</p>

<p>More generally, a for loop works with anything implementing the <code>Iterator</code> trait.
Data structures can provide one or more methods that return iterators over
their contents. For example, strings support iteration over their contents in
various ways:</p>
<span id='rust-example-raw-23' class='rusttest'>fn main() {
    let s = &quot;Hello&quot;;
    for c in s.chars() {
        println!(&quot;{}&quot;, c);
    }
}</span><pre id='rust-example-rendered-23' class='rust '>
<span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='string'>&quot;Hello&quot;</span>;
<span class='kw'>for</span> <span class='ident'>c</span> <span class='kw'>in</span> <span class='ident'>s</span>.<span class='ident'>chars</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>c</span>);
}
</pre>

<p>The snippet above prints the characters in &quot;Hello&quot; vertically, adding a new
line after each character.</p>

<h1 id="data-structures" class='section-header'><a
                           href="#data-structures">5 Data structures</a></h1>
<h2 id="structs" class='section-header'><a
                           href="#structs">5.1 Structs</a></h2>
<p>Rust struct types must be declared before they are used using the <code>struct</code>
syntax: <code>struct Name { field1: T1, field2: T2 [, ...] }</code>, where <code>T1</code>, <code>T2</code>,
... denote types. To construct a struct, use the same syntax, but leave off
the <code>struct</code>: for example: <code>Point { x: 1.0, y: 2.0 }</code>.</p>

<p>Structs are quite similar to C structs and are even laid out the same way in
memory (so you can read from a Rust struct in C, and vice-versa). Use the dot
operator to access struct fields, as in <code>mypoint.x</code>.</p>
<span id='rust-example-raw-24' class='rusttest'>fn main() {
    struct Point {
        x: f64,
        y: f64
    }
}</span><pre id='rust-example-rendered-24' class='rust '>
<span class='kw'>struct</span> <span class='ident'>Point</span> {
    <span class='ident'>x</span>: <span class='ident'>f64</span>,
    <span class='ident'>y</span>: <span class='ident'>f64</span>
}
</pre>

<p>Structs have &quot;inherited mutability&quot;, which means that any field of a struct
may be mutable, if the struct is in a mutable slot.</p>

<p>With a value (say, <code>mypoint</code>) of such a type in a mutable location, you can do
<code>mypoint.y += 1.0</code>. But in an immutable location, such an assignment to a
struct without inherited mutability would result in a type error.</p>
<span id='rust-example-raw-25' class='rusttest'>fn main() {
    struct Point { x: f64, y: f64 }
    let mut mypoint = Point { x: 1.0, y: 1.0 };
    let origin = Point { x: 0.0, y: 0.0 };
    
    mypoint.y += 1.0; // `mypoint` is mutable, and its fields as well
    origin.y += 1.0; // ERROR: assigning to immutable field
}</span><pre id='rust-example-rendered-25' class='rust '>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>mypoint</span> <span class='op'>=</span> <span class='ident'>Point</span> { <span class='ident'>x</span>: <span class='number'>1.0</span>, <span class='ident'>y</span>: <span class='number'>1.0</span> };
<span class='kw'>let</span> <span class='ident'>origin</span> <span class='op'>=</span> <span class='ident'>Point</span> { <span class='ident'>x</span>: <span class='number'>0.0</span>, <span class='ident'>y</span>: <span class='number'>0.0</span> };

<span class='ident'>mypoint</span>.<span class='ident'>y</span> <span class='op'>+=</span> <span class='number'>1.0</span>; <span class='comment'>// `mypoint` is mutable, and its fields as well</span>
<span class='ident'>origin</span>.<span class='ident'>y</span> <span class='op'>+=</span> <span class='number'>1.0</span>; <span class='comment'>// ERROR: assigning to immutable field</span>
</pre>

<p><code>match</code> patterns destructure structs. The basic syntax is
<code>Name { fieldname: pattern, ... }</code>:</p>
<span id='rust-example-raw-26' class='rusttest'>fn main() {
    struct Point { x: f64, y: f64 }
    let mypoint = Point { x: 0.0, y: 0.0 };
    match mypoint {
        Point { x: 0.0, y: yy } =&gt; println!(&quot;{}&quot;, yy),
        Point { x: xx,  y: yy } =&gt; println!(&quot;{} {}&quot;, xx, yy)
    }
}</span><pre id='rust-example-rendered-26' class='rust '>
<span class='kw'>match</span> <span class='ident'>mypoint</span> {
    <span class='ident'>Point</span> { <span class='ident'>x</span>: <span class='number'>0.0</span>, <span class='ident'>y</span>: <span class='ident'>yy</span> } <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>yy</span>),
    <span class='ident'>Point</span> { <span class='ident'>x</span>: <span class='ident'>xx</span>,  <span class='ident'>y</span>: <span class='ident'>yy</span> } <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{} {}&quot;</span>, <span class='ident'>xx</span>, <span class='ident'>yy</span>)
}
</pre>

<p>In general, the field names of a struct do not have to appear in the same
order they appear in the type. When you are not interested in all
the fields of a struct, a struct pattern may end with <code>, ..</code> (as in
<code>Name { field1, .. }</code>) to indicate that you&#39;re ignoring all other fields.
Additionally, struct fields have a shorthand matching form that simply
reuses the field name as the binding name.</p>
<span id='rust-example-raw-27' class='rusttest'>fn main() {
    struct Point { x: f64, y: f64 }
    let mypoint = Point { x: 0.0, y: 0.0 };
    match mypoint {
        Point { x, .. } =&gt; println!(&quot;{}&quot;, x)
    }
}</span><pre id='rust-example-rendered-27' class='rust '>
<span class='kw'>match</span> <span class='ident'>mypoint</span> {
    <span class='ident'>Point</span> { <span class='ident'>x</span>, .. } <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>x</span>)
}
</pre>

<h2 id="enums" class='section-header'><a
                           href="#enums">5.2 Enums</a></h2>
<p>Enums are datatypes with several alternate representations. A simple <code>enum</code>
defines one or more constants, all of which have the same type:</p>
<span id='rust-example-raw-28' class='rusttest'>fn main() {
    enum Direction {
        North,
        East,
        South,
        West
    }
}</span><pre id='rust-example-rendered-28' class='rust '>
<span class='kw'>enum</span> <span class='ident'>Direction</span> {
    <span class='ident'>North</span>,
    <span class='ident'>East</span>,
    <span class='ident'>South</span>,
    <span class='ident'>West</span>
}
</pre>

<p>Each variant of this enum has a unique and constant integral discriminator
value. If no explicit discriminator is specified for a variant, the value
defaults to the value of the previous variant plus one. If the first variant
does not have a discriminator, it defaults to 0. For example, the value of
<code>North</code> is 0, <code>East</code> is 1, <code>South</code> is 2, and <code>West</code> is 3.</p>

<p>When an enum has simple integer discriminators, you can apply the <code>as</code> cast
operator to convert a variant to its discriminator value as an <code>int</code>:</p>
<span id='rust-example-raw-29' class='rusttest'>fn main() {
    #[deriving(Show)] enum Direction { North }
    println!( &quot;{} =&gt; {}&quot;, North, North as int );
}</span><pre id='rust-example-rendered-29' class='rust '>
<span class='macro'>println</span><span class='macro'>!</span>( <span class='string'>&quot;{} =&gt; {}&quot;</span>, <span class='ident'>North</span>, <span class='ident'>North</span> <span class='kw'>as</span> <span class='ident'>int</span> );
</pre>

<p>It is possible to set the discriminator values to chosen constant values:</p>
<span id='rust-example-raw-30' class='rusttest'>fn main() {
    enum Color {
      Red = 0xff0000,
      Green = 0x00ff00,
      Blue = 0x0000ff
    }
}</span><pre id='rust-example-rendered-30' class='rust '>
<span class='kw'>enum</span> <span class='ident'>Color</span> {
  <span class='ident'>Red</span> <span class='op'>=</span> <span class='number'>0xff0000</span>,
  <span class='ident'>Green</span> <span class='op'>=</span> <span class='number'>0x00ff00</span>,
  <span class='ident'>Blue</span> <span class='op'>=</span> <span class='number'>0x0000ff</span>
}
</pre>

<p>Variants do not have to be simple values; they may be more complex:</p>
<span id='rust-example-raw-31' class='rusttest'>fn main() {
    struct Point { x: f64, y: f64 }
    enum Shape {
        Circle(Point, f64),
        Rectangle(Point, Point)
    }
}</span><pre id='rust-example-rendered-31' class='rust '>
<span class='kw'>enum</span> <span class='ident'>Shape</span> {
    <span class='ident'>Circle</span>(<span class='ident'>Point</span>, <span class='ident'>f64</span>),
    <span class='ident'>Rectangle</span>(<span class='ident'>Point</span>, <span class='ident'>Point</span>)
}
</pre>

<p>A value of this type is either a <code>Circle</code>, in which case it contains a
<code>Point</code> struct and a f64, or a <code>Rectangle</code>, in which case it contains
two <code>Point</code> structs. The run-time representation of such a value
includes an identifier of the actual form that it holds, much like the
&quot;tagged union&quot; pattern in C, but with better static guarantees.</p>

<p>This declaration defines a type <code>Shape</code> that can refer to such shapes, and two
functions, <code>Circle</code> and <code>Rectangle</code>, which can be used to construct values of
the type. To create a new Circle, write <code>Circle(Point { x: 0.0, y: 0.0 },
10.0)</code>.</p>

<p>All of these variant constructors may be used as patterns. The only way to
access the contents of an enum instance is the destructuring of a match. For
example:</p>
<span id='rust-example-raw-32' class='rusttest'>fn main() {
    use std::f64;
    struct Point {x: f64, y: f64}
    enum Shape { Circle(Point, f64), Rectangle(Point, Point) }
    fn area(sh: Shape) -&gt; f64 {
        match sh {
            Circle(_, size) =&gt; f64::consts::PI * size * size,
            Rectangle(Point { x, y }, Point { x: x2, y: y2 }) =&gt; (x2 - x) * (y2 - y)
        }
    }
}</span><pre id='rust-example-rendered-32' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>f64</span>;
<span class='kw'>fn</span> <span class='ident'>area</span>(<span class='ident'>sh</span>: <span class='ident'>Shape</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
    <span class='kw'>match</span> <span class='ident'>sh</span> {
        <span class='ident'>Circle</span>(_, <span class='ident'>size</span>) <span class='op'>=&gt;</span> <span class='ident'>f64</span>::<span class='ident'>consts</span>::<span class='ident'>PI</span> <span class='op'>*</span> <span class='ident'>size</span> <span class='op'>*</span> <span class='ident'>size</span>,
        <span class='ident'>Rectangle</span>(<span class='ident'>Point</span> { <span class='ident'>x</span>, <span class='ident'>y</span> }, <span class='ident'>Point</span> { <span class='ident'>x</span>: <span class='ident'>x2</span>, <span class='ident'>y</span>: <span class='ident'>y2</span> }) <span class='op'>=&gt;</span> (<span class='ident'>x2</span> <span class='op'>-</span> <span class='ident'>x</span>) <span class='op'>*</span> (<span class='ident'>y2</span> <span class='op'>-</span> <span class='ident'>y</span>)
    }
}
</pre>

<p>Use a lone <code>_</code> to ignore an individual field. Ignore all fields of a variant
like: <code>Circle(..)</code>. Nullary enum patterns are written without parentheses:</p>
<span id='rust-example-raw-33' class='rusttest'>fn main() {
    struct Point { x: f64, y: f64 }
    enum Direction { North, East, South, West }
    fn point_from_direction(dir: Direction) -&gt; Point {
        match dir {
            North =&gt; Point { x:  0.0, y:  1.0 },
            East  =&gt; Point { x:  1.0, y:  0.0 },
            South =&gt; Point { x:  0.0, y: -1.0 },
            West  =&gt; Point { x: -1.0, y:  0.0 }
        }
    }
}</span><pre id='rust-example-rendered-33' class='rust '>
<span class='kw'>fn</span> <span class='ident'>point_from_direction</span>(<span class='ident'>dir</span>: <span class='ident'>Direction</span>) <span class='op'>-&gt;</span> <span class='ident'>Point</span> {
    <span class='kw'>match</span> <span class='ident'>dir</span> {
        <span class='ident'>North</span> <span class='op'>=&gt;</span> <span class='ident'>Point</span> { <span class='ident'>x</span>:  <span class='number'>0.0</span>, <span class='ident'>y</span>:  <span class='number'>1.0</span> },
        <span class='ident'>East</span>  <span class='op'>=&gt;</span> <span class='ident'>Point</span> { <span class='ident'>x</span>:  <span class='number'>1.0</span>, <span class='ident'>y</span>:  <span class='number'>0.0</span> },
        <span class='ident'>South</span> <span class='op'>=&gt;</span> <span class='ident'>Point</span> { <span class='ident'>x</span>:  <span class='number'>0.0</span>, <span class='ident'>y</span>: <span class='op'>-</span><span class='number'>1.0</span> },
        <span class='ident'>West</span>  <span class='op'>=&gt;</span> <span class='ident'>Point</span> { <span class='ident'>x</span>: <span class='op'>-</span><span class='number'>1.0</span>, <span class='ident'>y</span>:  <span class='number'>0.0</span> }
    }
}
</pre>

<p>Enum variants may also be structs. For example:</p>
<span id='rust-example-raw-34' class='rusttest'>#![feature(struct_variant)]
use std::f64;
struct Point { x: f64, y: f64 }
fn square(x: f64) -&gt; f64 { x * x }
enum Shape {
    Circle { center: Point, radius: f64 },
    Rectangle { top_left: Point, bottom_right: Point }
}
fn area(sh: Shape) -&gt; f64 {
    match sh {
        Circle { radius: radius, .. } =&gt; f64::consts::PI * square(radius),
        Rectangle { top_left: top_left, bottom_right: bottom_right } =&gt; {
            (bottom_right.x - top_left.x) * (top_left.y - bottom_right.y)
        }
    }
}
fn main() {}</span><pre id='rust-example-rendered-34' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>f64</span>;
<span class='kw'>enum</span> <span class='ident'>Shape</span> {
    <span class='ident'>Circle</span> { <span class='ident'>center</span>: <span class='ident'>Point</span>, <span class='ident'>radius</span>: <span class='ident'>f64</span> },
    <span class='ident'>Rectangle</span> { <span class='ident'>top_left</span>: <span class='ident'>Point</span>, <span class='ident'>bottom_right</span>: <span class='ident'>Point</span> }
}
<span class='kw'>fn</span> <span class='ident'>area</span>(<span class='ident'>sh</span>: <span class='ident'>Shape</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
    <span class='kw'>match</span> <span class='ident'>sh</span> {
        <span class='ident'>Circle</span> { <span class='ident'>radius</span>: <span class='ident'>radius</span>, .. } <span class='op'>=&gt;</span> <span class='ident'>f64</span>::<span class='ident'>consts</span>::<span class='ident'>PI</span> <span class='op'>*</span> <span class='ident'>square</span>(<span class='ident'>radius</span>),
        <span class='ident'>Rectangle</span> { <span class='ident'>top_left</span>: <span class='ident'>top_left</span>, <span class='ident'>bottom_right</span>: <span class='ident'>bottom_right</span> } <span class='op'>=&gt;</span> {
            (<span class='ident'>bottom_right</span>.<span class='ident'>x</span> <span class='op'>-</span> <span class='ident'>top_left</span>.<span class='ident'>x</span>) <span class='op'>*</span> (<span class='ident'>top_left</span>.<span class='ident'>y</span> <span class='op'>-</span> <span class='ident'>bottom_right</span>.<span class='ident'>y</span>)
        }
    }
}
</pre>

<blockquote>
<p><em>Note:</em> This feature of the compiler is currently gated behind the
<code>#[feature(struct_variant)]</code> directive. More about these directives can be
found in the manual.</p>
</blockquote>

<h2 id="tuples" class='section-header'><a
                           href="#tuples">5.3 Tuples</a></h2>
<p>Tuples in Rust behave exactly like structs, except that their fields do not
have names. Thus, you cannot access their fields with dot notation.  Tuples
can have any arity (number of elements) except for 0 (though you may consider
unit, <code>()</code>, as the empty tuple if you like).</p>
<span id='rust-example-raw-35' class='rusttest'>fn main() {
    let mytup: (int, int, f64) = (10, 20, 30.0);
    match mytup {
      (a, b, c) =&gt; println!(&quot;{}&quot;, a + b + (c as int))
    }
}</span><pre id='rust-example-rendered-35' class='rust '>
<span class='kw'>let</span> <span class='ident'>mytup</span>: (<span class='ident'>int</span>, <span class='ident'>int</span>, <span class='ident'>f64</span>) <span class='op'>=</span> (<span class='number'>10</span>, <span class='number'>20</span>, <span class='number'>30.0</span>);
<span class='kw'>match</span> <span class='ident'>mytup</span> {
  (<span class='ident'>a</span>, <span class='ident'>b</span>, <span class='ident'>c</span>) <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>a</span> <span class='op'>+</span> <span class='ident'>b</span> <span class='op'>+</span> (<span class='ident'>c</span> <span class='kw'>as</span> <span class='ident'>int</span>))
}
</pre>

<h2 id="tuple-structs" class='section-header'><a
                           href="#tuple-structs">5.4 Tuple structs</a></h2>
<p>Rust also has <em>tuple structs</em>, which behave like both structs and tuples,
except that, unlike tuples, tuple structs have names (so <code>Foo(1, 2)</code> has a
different type from <code>Bar(1, 2)</code>), and tuple structs&#39; <em>fields</em> do not have
names.</p>

<p>For example:</p>
<span id='rust-example-raw-36' class='rusttest'>fn main() {
    struct MyTup(int, int, f64);
    let mytup: MyTup = MyTup(10, 20, 30.0);
    match mytup {
      MyTup(a, b, c) =&gt; println!(&quot;{}&quot;, a + b + (c as int))
    }
}</span><pre id='rust-example-rendered-36' class='rust '>
<span class='kw'>struct</span> <span class='ident'>MyTup</span>(<span class='ident'>int</span>, <span class='ident'>int</span>, <span class='ident'>f64</span>);
<span class='kw'>let</span> <span class='ident'>mytup</span>: <span class='ident'>MyTup</span> <span class='op'>=</span> <span class='ident'>MyTup</span>(<span class='number'>10</span>, <span class='number'>20</span>, <span class='number'>30.0</span>);
<span class='kw'>match</span> <span class='ident'>mytup</span> {
  <span class='ident'>MyTup</span>(<span class='ident'>a</span>, <span class='ident'>b</span>, <span class='ident'>c</span>) <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>a</span> <span class='op'>+</span> <span class='ident'>b</span> <span class='op'>+</span> (<span class='ident'>c</span> <span class='kw'>as</span> <span class='ident'>int</span>))
}
</pre>

<p><a name="newtype"></a></p>

<p>There is a special case for tuple structs with a single field, which are
sometimes called &quot;newtypes&quot; (after Haskell&#39;s &quot;newtype&quot; feature). These are
used to define new types in such a way that the new name is not just a
synonym for an existing type but is rather its own distinct type.</p>
<span id='rust-example-raw-37' class='rusttest'>fn main() {
    struct GizmoId(int);
}</span><pre id='rust-example-rendered-37' class='rust '>
<span class='kw'>struct</span> <span class='ident'>GizmoId</span>(<span class='ident'>int</span>);
</pre>

<p>Types like this can be useful to differentiate between data that have
the same underlying type but must be used in different ways.</p>
<span id='rust-example-raw-38' class='rusttest'>fn main() {
    struct Inches(int);
    struct Centimeters(int);
}</span><pre id='rust-example-rendered-38' class='rust '>
<span class='kw'>struct</span> <span class='ident'>Inches</span>(<span class='ident'>int</span>);
<span class='kw'>struct</span> <span class='ident'>Centimeters</span>(<span class='ident'>int</span>);
</pre>

<p>The above definitions allow for a simple way for programs to avoid
confusing numbers that correspond to different units. Their integer
values can be extracted with pattern matching:</p>
<span id='rust-example-raw-39' class='rusttest'>fn main() {
    struct Inches(int);
    let length_with_unit = Inches(10);
    let Inches(integer_length) = length_with_unit;
    println!(&quot;length is {} inches&quot;, integer_length);
}</span><pre id='rust-example-rendered-39' class='rust '>
<span class='kw'>let</span> <span class='ident'>length_with_unit</span> <span class='op'>=</span> <span class='ident'>Inches</span>(<span class='number'>10</span>);
<span class='kw'>let</span> <span class='ident'>Inches</span>(<span class='ident'>integer_length</span>) <span class='op'>=</span> <span class='ident'>length_with_unit</span>;
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;length is {} inches&quot;</span>, <span class='ident'>integer_length</span>);
</pre>

<h1 id="functions" class='section-header'><a
                           href="#functions">6 Functions</a></h1>
<p>We&#39;ve already seen several function definitions. Like all other static
declarations, such as <code>type</code>, functions can be declared both at the
top level and inside other functions (or in modules, which we&#39;ll come
back to <a href="#crates-and-the-module-system">later</a>). The <code>fn</code> keyword introduces a
function. A function has an argument list, which is a parenthesized
list of <code>name: type</code> pairs separated by commas. An arrow <code>-&gt;</code>
separates the argument list and the function&#39;s return type.</p>
<span id='rust-example-raw-40' class='rusttest'>fn main() {
    fn line(a: int, b: int, x: int) -&gt; int {
        return a * x + b;
    }
}</span><pre id='rust-example-rendered-40' class='rust '>
<span class='kw'>fn</span> <span class='ident'>line</span>(<span class='ident'>a</span>: <span class='ident'>int</span>, <span class='ident'>b</span>: <span class='ident'>int</span>, <span class='ident'>x</span>: <span class='ident'>int</span>) <span class='op'>-&gt;</span> <span class='ident'>int</span> {
    <span class='kw'>return</span> <span class='ident'>a</span> <span class='op'>*</span> <span class='ident'>x</span> <span class='op'>+</span> <span class='ident'>b</span>;
}
</pre>

<p>The <code>return</code> keyword immediately returns from the body of a function. It
is optionally followed by an expression to return. A function can
also return a value by having its top-level block produce an
expression.</p>
<span id='rust-example-raw-41' class='rusttest'>fn main() {
    fn line(a: int, b: int, x: int) -&gt; int {
        a * x + b
    }
}</span><pre id='rust-example-rendered-41' class='rust '>
<span class='kw'>fn</span> <span class='ident'>line</span>(<span class='ident'>a</span>: <span class='ident'>int</span>, <span class='ident'>b</span>: <span class='ident'>int</span>, <span class='ident'>x</span>: <span class='ident'>int</span>) <span class='op'>-&gt;</span> <span class='ident'>int</span> {
    <span class='ident'>a</span> <span class='op'>*</span> <span class='ident'>x</span> <span class='op'>+</span> <span class='ident'>b</span>
}
</pre>

<p>It&#39;s better Rust style to write a return value this way instead of
writing an explicit <code>return</code>. The utility of <code>return</code> comes in when
returning early from a function. Functions that do not return a value
are said to return unit, <code>()</code>, and both the return type and the return
value may be omitted from the definition. The following two functions
are equivalent.</p>
<span id='rust-example-raw-42' class='rusttest'>fn main() {
    fn do_nothing_the_hard_way() -&gt; () { return (); }
    
    fn do_nothing_the_easy_way() { }
}</span><pre id='rust-example-rendered-42' class='rust '>
<span class='kw'>fn</span> <span class='ident'>do_nothing_the_hard_way</span>() <span class='op'>-&gt;</span> () { <span class='kw'>return</span> (); }

<span class='kw'>fn</span> <span class='ident'>do_nothing_the_easy_way</span>() { }
</pre>

<p>Ending the function with a semicolon like so is equivalent to returning <code>()</code>.</p>
<span id='rust-example-raw-43' class='rusttest'>fn main() {
    fn line(a: int, b: int, x: int) -&gt; int { a * x + b  }
    fn oops(a: int, b: int, x: int) -&gt; ()  { a * x + b; }
    
    assert!(8 == line(5, 3, 1));
    assert!(() == oops(5, 3, 1));
}</span><pre id='rust-example-rendered-43' class='rust '>
<span class='kw'>fn</span> <span class='ident'>line</span>(<span class='ident'>a</span>: <span class='ident'>int</span>, <span class='ident'>b</span>: <span class='ident'>int</span>, <span class='ident'>x</span>: <span class='ident'>int</span>) <span class='op'>-&gt;</span> <span class='ident'>int</span> { <span class='ident'>a</span> <span class='op'>*</span> <span class='ident'>x</span> <span class='op'>+</span> <span class='ident'>b</span>  }
<span class='kw'>fn</span> <span class='ident'>oops</span>(<span class='ident'>a</span>: <span class='ident'>int</span>, <span class='ident'>b</span>: <span class='ident'>int</span>, <span class='ident'>x</span>: <span class='ident'>int</span>) <span class='op'>-&gt;</span> ()  { <span class='ident'>a</span> <span class='op'>*</span> <span class='ident'>x</span> <span class='op'>+</span> <span class='ident'>b</span>; }

<span class='macro'>assert</span><span class='macro'>!</span>(<span class='number'>8</span> <span class='op'>==</span> <span class='ident'>line</span>(<span class='number'>5</span>, <span class='number'>3</span>, <span class='number'>1</span>));
<span class='macro'>assert</span><span class='macro'>!</span>(() <span class='op'>==</span> <span class='ident'>oops</span>(<span class='number'>5</span>, <span class='number'>3</span>, <span class='number'>1</span>));
</pre>

<p>As with <code>match</code> expressions and <code>let</code> bindings, function arguments support
pattern destructuring. Like <code>let</code>, argument patterns must be irrefutable,
as in this example that unpacks the first value from a tuple and returns it.</p>
<span id='rust-example-raw-44' class='rusttest'>fn main() {
    fn first((value, _): (int, f64)) -&gt; int { value }
}</span><pre id='rust-example-rendered-44' class='rust '>
<span class='kw'>fn</span> <span class='ident'>first</span>((<span class='ident'>value</span>, _): (<span class='ident'>int</span>, <span class='ident'>f64</span>)) <span class='op'>-&gt;</span> <span class='ident'>int</span> { <span class='ident'>value</span> }
</pre>

<h1 id="destructors" class='section-header'><a
                           href="#destructors">7 Destructors</a></h1>
<p>A <em>destructor</em> is a function responsible for cleaning up the resources used by
an object when it is no longer accessible. Destructors can be defined to handle
the release of resources like files, sockets and heap memory.</p>

<p>Objects are never accessible after their destructor has been called, so no
dynamic failures are possible from accessing freed resources. When a task
fails, destructors of all objects in the task are called.</p>

<p>The <code>box</code> operator performs memory allocation on the heap:</p>
<span id='rust-example-raw-45' class='rusttest'>fn main() {
    {
        // an integer allocated on the heap
        let y = box 10i;
    }
    // the destructor frees the heap memory as soon as `y` goes out of scope
}</span><pre id='rust-example-rendered-45' class='rust '>
{
    <span class='comment'>// an integer allocated on the heap</span>
    <span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='kw'>box</span> <span class='number'>10i</span>;
}
<span class='comment'>// the destructor frees the heap memory as soon as `y` goes out of scope</span>
</pre>

<p>Rust includes syntax for heap memory allocation in the language since it&#39;s
commonly used, but the same semantics can be implemented by a type with a
custom destructor.</p>

<h1 id="ownership" class='section-header'><a
                           href="#ownership">8 Ownership</a></h1>
<p>Rust formalizes the concept of object ownership to delegate management of an
object&#39;s lifetime to either a variable or a task-local garbage collector. An
object&#39;s owner is responsible for managing the lifetime of the object by
calling the destructor, and the owner determines whether the object is mutable.</p>

<p>Ownership is recursive, so mutability is inherited recursively and a destructor
destroys the contained tree of owned objects. Variables are top-level owners
and destroy the contained object when they go out of scope.</p>
<span id='rust-example-raw-46' class='rusttest'>fn main() {
    // the struct owns the objects contained in the `x` and `y` fields
    struct Foo { x: int, y: Box&lt;int&gt; }
    
    {
        // `a` is the owner of the struct, and thus the owner of the struct&#39;s fields
        let a = Foo { x: 5, y: box 10 };
    }
    // when `a` goes out of scope, the destructor for the `Box&lt;int&gt;` in the struct&#39;s
    // field is called
    
    // `b` is mutable, and the mutability is inherited by the objects it owns
    let mut b = Foo { x: 5, y: box 10 };
    b.x = 10;
}</span><pre id='rust-example-rendered-46' class='rust '>
<span class='comment'>// the struct owns the objects contained in the `x` and `y` fields</span>
<span class='kw'>struct</span> <span class='ident'>Foo</span> { <span class='ident'>x</span>: <span class='ident'>int</span>, <span class='ident'>y</span>: <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>int</span><span class='op'>&gt;</span> }

{
    <span class='comment'>// `a` is the owner of the struct, and thus the owner of the struct&#39;s fields</span>
    <span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> <span class='ident'>Foo</span> { <span class='ident'>x</span>: <span class='number'>5</span>, <span class='ident'>y</span>: <span class='kw'>box</span> <span class='number'>10</span> };
}
<span class='comment'>// when `a` goes out of scope, the destructor for the `Box&lt;int&gt;` in the struct&#39;s</span>
<span class='comment'>// field is called</span>

<span class='comment'>// `b` is mutable, and the mutability is inherited by the objects it owns</span>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>b</span> <span class='op'>=</span> <span class='ident'>Foo</span> { <span class='ident'>x</span>: <span class='number'>5</span>, <span class='ident'>y</span>: <span class='kw'>box</span> <span class='number'>10</span> };
<span class='ident'>b</span>.<span class='ident'>x</span> <span class='op'>=</span> <span class='number'>10</span>;
</pre>

<p>If an object doesn&#39;t contain any non-Send types, it consists of a single
ownership tree and is itself given the <code>Send</code> trait which allows it to be sent
between tasks. Custom destructors can only be implemented directly on types
that are <code>Send</code>, but non-<code>Send</code> types can still <em>contain</em> types with custom
destructors. Example of types which are not <code>Send</code> are <a href="http://doc.rust-lang.org/std/gc/struct.Gc.html"><code>Gc&lt;T&gt;</code></a> and
<a href="http://doc.rust-lang.org/std/rc/struct.Rc.html"><code>Rc&lt;T&gt;</code></a>, the shared-ownership types.</p>

<h1 id="implementing-a-linked-list" class='section-header'><a
                           href="#implementing-a-linked-list">9 Implementing a linked list</a></h1>
<p>An <code>enum</code> is a natural fit for describing a linked list, because it can express
a <code>List</code> type as being <em>either</em> the end of the list (<code>Nil</code>) or another node
(<code>Cons</code>). The full definition of the <code>Cons</code> variant will require some thought.</p>
<span id='rust-example-raw-47' class='rusttest'>fn main() {
    enum List {
        Cons(...), // an incomplete definition of the next element in a List
        Nil        // the end of a List
    }
}</span><pre id='rust-example-rendered-47' class='rust '>
<span class='kw'>enum</span> <span class='ident'>List</span> {
    <span class='ident'>Cons</span>(...), <span class='comment'>// an incomplete definition of the next element in a List</span>
    <span class='ident'>Nil</span>        <span class='comment'>// the end of a List</span>
}
</pre>

<p>The obvious approach is to define <code>Cons</code> as containing an element in the list
along with the next <code>List</code> node. However, this will generate a compiler error.</p>
<span id='rust-example-raw-48' class='rusttest'>fn main() {
    // error: illegal recursive enum type; wrap the inner value in a box to make it
    // representable
    enum List {
        Cons(u32, List), // an element (`u32`) and the next node in the list
        Nil
    }
}</span><pre id='rust-example-rendered-48' class='rust '>
<span class='comment'>// error: illegal recursive enum type; wrap the inner value in a box to make it</span>
<span class='comment'>// representable</span>
<span class='kw'>enum</span> <span class='ident'>List</span> {
    <span class='ident'>Cons</span>(<span class='ident'>u32</span>, <span class='ident'>List</span>), <span class='comment'>// an element (`u32`) and the next node in the list</span>
    <span class='ident'>Nil</span>
}
</pre>

<p>This error message is related to Rust&#39;s precise control over memory layout, and
solving it will require introducing the concept of <em>boxing</em>.</p>

<h2 id="boxes" class='section-header'><a
                           href="#boxes">9.1 Boxes</a></h2>
<p>A value in Rust is stored directly inside the owner. If a <code>struct</code> contains
four <code>u32</code> fields, it will be four times as large as a single <code>u32</code>.</p>
<span id='rust-example-raw-49' class='rusttest'>fn main() {
    use std::mem::size_of; // bring `size_of` into the current scope, for convenience
    
    struct Foo {
        a: u32,
        b: u32,
        c: u32,
        d: u32
    }
    
    assert_eq!(size_of::&lt;Foo&gt;(), size_of::&lt;u32&gt;() * 4);
    
    struct Bar {
        a: Foo,
        b: Foo,
        c: Foo,
        d: Foo
    }
    
    assert_eq!(size_of::&lt;Bar&gt;(), size_of::&lt;u32&gt;() * 16);
}</span><pre id='rust-example-rendered-49' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>mem</span>::<span class='ident'>size_of</span>; <span class='comment'>// bring `size_of` into the current scope, for convenience</span>

<span class='kw'>struct</span> <span class='ident'>Foo</span> {
    <span class='ident'>a</span>: <span class='ident'>u32</span>,
    <span class='ident'>b</span>: <span class='ident'>u32</span>,
    <span class='ident'>c</span>: <span class='ident'>u32</span>,
    <span class='ident'>d</span>: <span class='ident'>u32</span>
}

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>size_of</span>::<span class='op'>&lt;</span><span class='ident'>Foo</span><span class='op'>&gt;</span>(), <span class='ident'>size_of</span>::<span class='op'>&lt;</span><span class='ident'>u32</span><span class='op'>&gt;</span>() <span class='op'>*</span> <span class='number'>4</span>);

<span class='kw'>struct</span> <span class='ident'>Bar</span> {
    <span class='ident'>a</span>: <span class='ident'>Foo</span>,
    <span class='ident'>b</span>: <span class='ident'>Foo</span>,
    <span class='ident'>c</span>: <span class='ident'>Foo</span>,
    <span class='ident'>d</span>: <span class='ident'>Foo</span>
}

<span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>size_of</span>::<span class='op'>&lt;</span><span class='ident'>Bar</span><span class='op'>&gt;</span>(), <span class='ident'>size_of</span>::<span class='op'>&lt;</span><span class='ident'>u32</span><span class='op'>&gt;</span>() <span class='op'>*</span> <span class='number'>16</span>);
</pre>

<p>Our previous attempt at defining the <code>List</code> type included an <code>u32</code> and a <code>List</code>
directly inside <code>Cons</code>, making it at least as big as the sum of both types. The
type was invalid because the size was infinite!</p>

<p>An <em>owned box</em> (<code>Box</code>, located in the <code>std::owned</code> module) uses a dynamic memory
allocation to provide the invariant of always being the size of a pointer,
regardless of the contained type. This can be leveraged to create a valid <code>List</code>
definition:</p>
<span id='rust-example-raw-50' class='rusttest'>fn main() {
    
    enum List {
        Cons(u32, Box&lt;List&gt;),
        Nil
    }
}</span><pre id='rust-example-rendered-50' class='rust '>

<span class='kw'>enum</span> <span class='ident'>List</span> {
    <span class='ident'>Cons</span>(<span class='ident'>u32</span>, <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>List</span><span class='op'>&gt;</span>),
    <span class='ident'>Nil</span>
}
</pre>

<p>Defining a recursive data structure like this is the canonical example of an
owned box. Much like an unboxed value, an owned box has a single owner and is
therefore limited to expressing a tree-like data structure.</p>

<p>Consider an instance of our <code>List</code> type:</p>
<span id='rust-example-raw-51' class='rusttest'>fn main() {
    enum List {
        Cons(u32, Box&lt;List&gt;),
        Nil
    }
    let list = Cons(1, box Cons(2, box Cons(3, box Nil)));
}</span><pre id='rust-example-rendered-51' class='rust '>
<span class='kw'>let</span> <span class='ident'>list</span> <span class='op'>=</span> <span class='ident'>Cons</span>(<span class='number'>1</span>, <span class='kw'>box</span> <span class='ident'>Cons</span>(<span class='number'>2</span>, <span class='kw'>box</span> <span class='ident'>Cons</span>(<span class='number'>3</span>, <span class='kw'>box</span> <span class='ident'>Nil</span>)));
</pre>

<p>It represents an owned tree of values, inheriting mutability down the tree and
being destroyed along with the owner. Since the <code>list</code> variable above is
immutable, the whole list is immutable. The memory allocation itself is the
box, while the owner holds onto a pointer to it:</p>

<pre><code class="language-text">            List box            List box            List box          List box
        +--------------+    +--------------+    +--------------+    +----------+
list -&gt; | Cons | 1 |   | -&gt; | Cons | 2 |   | -&gt; | Cons | 3 |   | -&gt; | Nil      |
        +--------------+    +--------------+    +--------------+    +----------+</code></pre>

<blockquote>
<p><em>Note:</em> the above diagram shows the logical contents of the enum. The actual
memory layout of the enum may vary. For example, for the <code>List</code> enum shown
above, Rust guarantees that there will be no enum tag field in the actual
structure. See the language reference for more details.</p>
</blockquote>

<p>An owned box is a common example of a type with a destructor. The allocated
memory is cleaned up when the box is destroyed.</p>

<h2 id="move-semantics" class='section-header'><a
                           href="#move-semantics">9.2 Move semantics</a></h2>
<p>Rust uses a shallow copy for parameter passing, assignment and returning from
functions. Passing around the <code>List</code> will copy only as deep as the pointer to
the box rather than doing an implicit heap allocation.</p>
<span id='rust-example-raw-52' class='rusttest'>fn main() {
    enum List {
        Cons(u32, Box&lt;List&gt;),
        Nil
    }
    let xs = Cons(1, box Cons(2, box Cons(3, box Nil)));
    let ys = xs; // copies `Cons(u32, pointer)` shallowly
}</span><pre id='rust-example-rendered-52' class='rust '>
<span class='kw'>let</span> <span class='ident'>xs</span> <span class='op'>=</span> <span class='ident'>Cons</span>(<span class='number'>1</span>, <span class='kw'>box</span> <span class='ident'>Cons</span>(<span class='number'>2</span>, <span class='kw'>box</span> <span class='ident'>Cons</span>(<span class='number'>3</span>, <span class='kw'>box</span> <span class='ident'>Nil</span>)));
<span class='kw'>let</span> <span class='ident'>ys</span> <span class='op'>=</span> <span class='ident'>xs</span>; <span class='comment'>// copies `Cons(u32, pointer)` shallowly</span>
</pre>

<p>Rust will consider a shallow copy of a type with a destructor like <code>List</code> to
<em>move ownership</em> of the value. After a value has been moved, the source
location cannot be used unless it is reinitialized.</p>
<span id='rust-example-raw-53' class='rusttest'>fn main() {
    enum List {
        Cons(u32, Box&lt;List&gt;),
        Nil
    }
    let mut xs = Nil;
    let ys = xs;
    
    // attempting to use `xs` will result in an error here
    
    xs = Nil;
    
    // `xs` can be used again
}</span><pre id='rust-example-rendered-53' class='rust '>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>xs</span> <span class='op'>=</span> <span class='ident'>Nil</span>;
<span class='kw'>let</span> <span class='ident'>ys</span> <span class='op'>=</span> <span class='ident'>xs</span>;

<span class='comment'>// attempting to use `xs` will result in an error here</span>

<span class='ident'>xs</span> <span class='op'>=</span> <span class='ident'>Nil</span>;

<span class='comment'>// `xs` can be used again</span>
</pre>

<p>A destructor call will only occur for a variable that has not been moved from,
as it is only called a single time.</p>

<p>Avoiding a move can be done with the library-defined <code>clone</code> method:</p>
<span id='rust-example-raw-54' class='rusttest'>fn main() {
    let x = box 5i;
    let y = x.clone(); // `y` is a newly allocated box
    let z = x; // no new memory allocated, `x` can no longer be used
}</span><pre id='rust-example-rendered-54' class='rust '>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='kw'>box</span> <span class='number'>5i</span>;
<span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='ident'>x</span>.<span class='ident'>clone</span>(); <span class='comment'>// `y` is a newly allocated box</span>
<span class='kw'>let</span> <span class='ident'>z</span> <span class='op'>=</span> <span class='ident'>x</span>; <span class='comment'>// no new memory allocated, `x` can no longer be used</span>
</pre>

<p>The <code>clone</code> method is provided by the <code>Clone</code> trait, and can be derived for
our <code>List</code> type. Traits will be explained in detail <a href="#traits">later</a>.</p>
<span id='rust-example-raw-55' class='rusttest'>fn main() {
    #[deriving(Clone)]
    enum List {
        Cons(u32, Box&lt;List&gt;),
        Nil
    }
    
    let x = Cons(5, box Nil);
    let y = x.clone();
    
    // `x` can still be used!
    
    let z = x;
    
    // and now, it can no longer be used since it has been moved
}</span><pre id='rust-example-rendered-55' class='rust '>
<span class='attribute'>#[<span class='ident'>deriving</span>(<span class='ident'>Clone</span>)]</span>
<span class='kw'>enum</span> <span class='ident'>List</span> {
    <span class='ident'>Cons</span>(<span class='ident'>u32</span>, <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>List</span><span class='op'>&gt;</span>),
    <span class='ident'>Nil</span>
}

<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>Cons</span>(<span class='number'>5</span>, <span class='kw'>box</span> <span class='ident'>Nil</span>);
<span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='ident'>x</span>.<span class='ident'>clone</span>();

<span class='comment'>// `x` can still be used!</span>

<span class='kw'>let</span> <span class='ident'>z</span> <span class='op'>=</span> <span class='ident'>x</span>;

<span class='comment'>// and now, it can no longer be used since it has been moved</span>
</pre>

<p>The mutability of a value may be changed by moving it to a new owner:</p>
<span id='rust-example-raw-56' class='rusttest'>fn main() {
    let r = box 13i;
    let mut s = r; // box becomes mutable
    *s += 1;
    let t = s; // box becomes immutable
}</span><pre id='rust-example-rendered-56' class='rust '>
<span class='kw'>let</span> <span class='ident'>r</span> <span class='op'>=</span> <span class='kw'>box</span> <span class='number'>13i</span>;
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='ident'>r</span>; <span class='comment'>// box becomes mutable</span>
<span class='op'>*</span><span class='ident'>s</span> <span class='op'>+=</span> <span class='number'>1</span>;
<span class='kw'>let</span> <span class='ident'>t</span> <span class='op'>=</span> <span class='ident'>s</span>; <span class='comment'>// box becomes immutable</span>
</pre>

<p>A simple way to define a function prepending to the <code>List</code> type is to take
advantage of moves:</p>
<span id='rust-example-raw-57' class='rusttest'>fn main() {
    enum List {
        Cons(u32, Box&lt;List&gt;),
        Nil
    }
    
    fn prepend(xs: List, value: u32) -&gt; List {
        Cons(value, box xs)
    }
    
    let mut xs = Nil;
    xs = prepend(xs, 1);
    xs = prepend(xs, 2);
    xs = prepend(xs, 3);
}</span><pre id='rust-example-rendered-57' class='rust '>
<span class='kw'>enum</span> <span class='ident'>List</span> {
    <span class='ident'>Cons</span>(<span class='ident'>u32</span>, <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>List</span><span class='op'>&gt;</span>),
    <span class='ident'>Nil</span>
}

<span class='kw'>fn</span> <span class='ident'>prepend</span>(<span class='ident'>xs</span>: <span class='ident'>List</span>, <span class='ident'>value</span>: <span class='ident'>u32</span>) <span class='op'>-&gt;</span> <span class='ident'>List</span> {
    <span class='ident'>Cons</span>(<span class='ident'>value</span>, <span class='kw'>box</span> <span class='ident'>xs</span>)
}

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>xs</span> <span class='op'>=</span> <span class='ident'>Nil</span>;
<span class='ident'>xs</span> <span class='op'>=</span> <span class='ident'>prepend</span>(<span class='ident'>xs</span>, <span class='number'>1</span>);
<span class='ident'>xs</span> <span class='op'>=</span> <span class='ident'>prepend</span>(<span class='ident'>xs</span>, <span class='number'>2</span>);
<span class='ident'>xs</span> <span class='op'>=</span> <span class='ident'>prepend</span>(<span class='ident'>xs</span>, <span class='number'>3</span>);
</pre>

<p>However, this is not a very flexible definition of <code>prepend</code> as it requires
ownership of a list to be passed in rather than just mutating it in-place.</p>

<h2 id="references" class='section-header'><a
                           href="#references">9.3 References</a></h2>
<p>The obvious signature for a <code>List</code> equality comparison is the following:</p>
<span id='rust-example-raw-58' class='rusttest'>fn main() {
    fn eq(xs: List, ys: List) -&gt; bool { /* ... */ }
}</span><pre id='rust-example-rendered-58' class='rust '>
<span class='kw'>fn</span> <span class='ident'>eq</span>(<span class='ident'>xs</span>: <span class='ident'>List</span>, <span class='ident'>ys</span>: <span class='ident'>List</span>) <span class='op'>-&gt;</span> <span class='ident'>bool</span> { <span class='comment'>/* ... */</span> }
</pre>

<p>However, this will cause both lists to be moved into the function. Ownership
isn&#39;t required to compare the lists, so the function should take <em>references</em>
(&amp;T) instead.</p>
<span id='rust-example-raw-59' class='rusttest'>fn main() {
    fn eq(xs: &amp;List, ys: &amp;List) -&gt; bool { /* ... */ }
}</span><pre id='rust-example-rendered-59' class='rust '>
<span class='kw'>fn</span> <span class='ident'>eq</span>(<span class='ident'>xs</span>: <span class='kw-2'>&amp;</span><span class='ident'>List</span>, <span class='ident'>ys</span>: <span class='kw-2'>&amp;</span><span class='ident'>List</span>) <span class='op'>-&gt;</span> <span class='ident'>bool</span> { <span class='comment'>/* ... */</span> }
</pre>

<p>A reference is a <em>non-owning</em> view of a value. A reference can be obtained with the <code>&amp;</code> (address-of)
operator. It can be dereferenced by using the <code>*</code> operator. In a pattern, such as <code>match</code> expression
branches, the <code>ref</code> keyword can be used to bind to a variable name by-reference rather than
by-value. A recursive definition of equality using references is as follows:</p>
<span id='rust-example-raw-60' class='rusttest'>fn main() {
    enum List {
        Cons(u32, Box&lt;List&gt;),
        Nil
    }
    fn eq(xs: &amp;List, ys: &amp;List) -&gt; bool {
        // Match on the next node in both lists.
        match (xs, ys) {
            // If we have reached the end of both lists, they are equal.
            (&amp;Nil, &amp;Nil) =&gt; true,
            // If the current elements of both lists are equal, keep going.
            (&amp;Cons(x, box ref next_xs), &amp;Cons(y, box ref next_ys))
                    if x == y =&gt; eq(next_xs, next_ys),
            // If the current elements are not equal, the lists are not equal.
            _ =&gt; false
        }
    }
    
    let xs = Cons(5, box Cons(10, box Nil));
    let ys = Cons(5, box Cons(10, box Nil));
    assert!(eq(&amp;xs, &amp;ys));
}</span><pre id='rust-example-rendered-60' class='rust '>
<span class='kw'>fn</span> <span class='ident'>eq</span>(<span class='ident'>xs</span>: <span class='kw-2'>&amp;</span><span class='ident'>List</span>, <span class='ident'>ys</span>: <span class='kw-2'>&amp;</span><span class='ident'>List</span>) <span class='op'>-&gt;</span> <span class='ident'>bool</span> {
    <span class='comment'>// Match on the next node in both lists.</span>
    <span class='kw'>match</span> (<span class='ident'>xs</span>, <span class='ident'>ys</span>) {
        <span class='comment'>// If we have reached the end of both lists, they are equal.</span>
        (<span class='kw-2'>&amp;</span><span class='ident'>Nil</span>, <span class='kw-2'>&amp;</span><span class='ident'>Nil</span>) <span class='op'>=&gt;</span> <span class='boolval'>true</span>,
        <span class='comment'>// If the current elements of both lists are equal, keep going.</span>
        (<span class='kw-2'>&amp;</span><span class='ident'>Cons</span>(<span class='ident'>x</span>, <span class='kw'>box</span> <span class='kw-2'>ref</span> <span class='ident'>next_xs</span>), <span class='kw-2'>&amp;</span><span class='ident'>Cons</span>(<span class='ident'>y</span>, <span class='kw'>box</span> <span class='kw-2'>ref</span> <span class='ident'>next_ys</span>))
                <span class='kw'>if</span> <span class='ident'>x</span> <span class='op'>==</span> <span class='ident'>y</span> <span class='op'>=&gt;</span> <span class='ident'>eq</span>(<span class='ident'>next_xs</span>, <span class='ident'>next_ys</span>),
        <span class='comment'>// If the current elements are not equal, the lists are not equal.</span>
        _ <span class='op'>=&gt;</span> <span class='boolval'>false</span>
    }
}

<span class='kw'>let</span> <span class='ident'>xs</span> <span class='op'>=</span> <span class='ident'>Cons</span>(<span class='number'>5</span>, <span class='kw'>box</span> <span class='ident'>Cons</span>(<span class='number'>10</span>, <span class='kw'>box</span> <span class='ident'>Nil</span>));
<span class='kw'>let</span> <span class='ident'>ys</span> <span class='op'>=</span> <span class='ident'>Cons</span>(<span class='number'>5</span>, <span class='kw'>box</span> <span class='ident'>Cons</span>(<span class='number'>10</span>, <span class='kw'>box</span> <span class='ident'>Nil</span>));
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>eq</span>(<span class='kw-2'>&amp;</span><span class='ident'>xs</span>, <span class='kw-2'>&amp;</span><span class='ident'>ys</span>));
</pre>

<blockquote>
<p><em>Note:</em> Rust doesn&#39;t guarantee <a href="http://en.wikipedia.org/wiki/Tail_call">tail-call</a> optimization,
but LLVM is able to handle a simple case like this with optimizations enabled.</p>
</blockquote>

<h2 id="lists-of-other-types" class='section-header'><a
                           href="#lists-of-other-types">9.4 Lists of other types</a></h2>
<p>Our <code>List</code> type is currently always a list of 32-bit unsigned integers. By
leveraging Rust&#39;s support for generics, it can be extended to work for any
element type.</p>

<p>The <code>u32</code> in the previous definition can be substituted with a type parameter:</p>

<blockquote>
<p><em>Note:</em> The following code introduces generics, which are explained in a
<a href="#generics">dedicated section</a>.</p>
</blockquote>
<span id='rust-example-raw-61' class='rusttest'>fn main() {
    enum List&lt;T&gt; {
        Cons(T, Box&lt;List&lt;T&gt;&gt;),
        Nil
    }
}</span><pre id='rust-example-rendered-61' class='rust '>
<span class='kw'>enum</span> <span class='ident'>List</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='ident'>Cons</span>(<span class='ident'>T</span>, <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>List</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;&gt;</span>),
    <span class='ident'>Nil</span>
}
</pre>

<p>The old <code>List</code> of <code>u32</code> is now available as <code>List&lt;u32&gt;</code>. The <code>prepend</code>
definition has to be updated too:</p>
<span id='rust-example-raw-62' class='rusttest'>fn main() {
    enum List&lt;T&gt; {
        Cons(T, Box&lt;List&lt;T&gt;&gt;),
        Nil
    }
    fn prepend&lt;T&gt;(xs: List&lt;T&gt;, value: T) -&gt; List&lt;T&gt; {
        Cons(value, box xs)
    }
}</span><pre id='rust-example-rendered-62' class='rust '>
<span class='kw'>fn</span> <span class='ident'>prepend</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>(<span class='ident'>xs</span>: <span class='ident'>List</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>, <span class='ident'>value</span>: <span class='ident'>T</span>) <span class='op'>-&gt;</span> <span class='ident'>List</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='ident'>Cons</span>(<span class='ident'>value</span>, <span class='kw'>box</span> <span class='ident'>xs</span>)
}
</pre>

<p>Generic functions and types like this are equivalent to defining specialized
versions for each set of type parameters.</p>

<p>Using the generic <code>List&lt;T&gt;</code> works much like before, thanks to type inference:</p>
<span id='rust-example-raw-63' class='rusttest'>fn main() {
    enum List&lt;T&gt; {
        Cons(T, Box&lt;List&lt;T&gt;&gt;),
        Nil
    }
    fn prepend&lt;T&gt;(xs: List&lt;T&gt;, value: T) -&gt; List&lt;T&gt; {
        Cons(value, box xs)
    }
    let mut xs = Nil; // Unknown type! This is a `List&lt;T&gt;`, but `T` can be anything.
    xs = prepend(xs, 10i); // Here the compiler infers `xs`&#39;s type as `List&lt;int&gt;`.
    xs = prepend(xs, 15i);
    xs = prepend(xs, 20i);
}</span><pre id='rust-example-rendered-63' class='rust '>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>xs</span> <span class='op'>=</span> <span class='ident'>Nil</span>; <span class='comment'>// Unknown type! This is a `List&lt;T&gt;`, but `T` can be anything.</span>
<span class='ident'>xs</span> <span class='op'>=</span> <span class='ident'>prepend</span>(<span class='ident'>xs</span>, <span class='number'>10i</span>); <span class='comment'>// Here the compiler infers `xs`&#39;s type as `List&lt;int&gt;`.</span>
<span class='ident'>xs</span> <span class='op'>=</span> <span class='ident'>prepend</span>(<span class='ident'>xs</span>, <span class='number'>15i</span>);
<span class='ident'>xs</span> <span class='op'>=</span> <span class='ident'>prepend</span>(<span class='ident'>xs</span>, <span class='number'>20i</span>);
</pre>

<p>The code sample above demonstrates type inference making most type annotations optional. It is
equivalent to the following type-annotated code:</p>
<span id='rust-example-raw-64' class='rusttest'>fn main() {
    enum List&lt;T&gt; {
        Cons(T, Box&lt;List&lt;T&gt;&gt;),
        Nil
    }
    fn prepend&lt;T&gt;(xs: List&lt;T&gt;, value: T) -&gt; List&lt;T&gt; {
        Cons(value, box xs)
    }
    let mut xs: List&lt;int&gt; = Nil::&lt;int&gt;;
    xs = prepend::&lt;int&gt;(xs, 10);
    xs = prepend::&lt;int&gt;(xs, 15);
    xs = prepend::&lt;int&gt;(xs, 20);
}</span><pre id='rust-example-rendered-64' class='rust '>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>xs</span>: <span class='ident'>List</span><span class='op'>&lt;</span><span class='ident'>int</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>Nil</span>::<span class='op'>&lt;</span><span class='ident'>int</span><span class='op'>&gt;</span>;
<span class='ident'>xs</span> <span class='op'>=</span> <span class='ident'>prepend</span>::<span class='op'>&lt;</span><span class='ident'>int</span><span class='op'>&gt;</span>(<span class='ident'>xs</span>, <span class='number'>10</span>);
<span class='ident'>xs</span> <span class='op'>=</span> <span class='ident'>prepend</span>::<span class='op'>&lt;</span><span class='ident'>int</span><span class='op'>&gt;</span>(<span class='ident'>xs</span>, <span class='number'>15</span>);
<span class='ident'>xs</span> <span class='op'>=</span> <span class='ident'>prepend</span>::<span class='op'>&lt;</span><span class='ident'>int</span><span class='op'>&gt;</span>(<span class='ident'>xs</span>, <span class='number'>20</span>);
</pre>

<p>In declarations, the language uses <code>Type&lt;T, U, V&gt;</code> to describe a list of type
parameters, but expressions use <code>identifier::&lt;T, U, V&gt;</code>, to disambiguate the
<code>&lt;</code> operator.</p>

<h2 id="defining-list-equality-with-generics" class='section-header'><a
                           href="#defining-list-equality-with-generics">9.5 Defining list equality with generics</a></h2>
<p>Generic functions are type-checked from the definition, so any necessary properties of the type must
be specified up-front. Our previous definition of list equality relied on the element type having
the <code>==</code> operator available, and took advantage of the lack of a destructor on <code>u32</code> to copy it
without a move of ownership.</p>

<p>We can add a <em>trait bound</em> on the <code>PartialEq</code> trait to require that the type implement the <code>==</code> operator.
Two more <code>ref</code> annotations need to be added to avoid attempting to move out the element types:</p>
<span id='rust-example-raw-65' class='rusttest'>fn main() {
    enum List&lt;T&gt; {
        Cons(T, Box&lt;List&lt;T&gt;&gt;),
        Nil
    }
    fn eq&lt;T: PartialEq&gt;(xs: &amp;List&lt;T&gt;, ys: &amp;List&lt;T&gt;) -&gt; bool {
        // Match on the next node in both lists.
        match (xs, ys) {
            // If we have reached the end of both lists, they are equal.
            (&amp;Nil, &amp;Nil) =&gt; true,
            // If the current elements of both lists are equal, keep going.
            (&amp;Cons(ref x, box ref next_xs), &amp;Cons(ref y, box ref next_ys))
                    if x == y =&gt; eq(next_xs, next_ys),
            // If the current elements are not equal, the lists are not equal.
            _ =&gt; false
        }
    }
    
    let xs = Cons(&#39;c&#39;, box Cons(&#39;a&#39;, box Cons(&#39;t&#39;, box Nil)));
    let ys = Cons(&#39;c&#39;, box Cons(&#39;a&#39;, box Cons(&#39;t&#39;, box Nil)));
    assert!(eq(&amp;xs, &amp;ys));
}</span><pre id='rust-example-rendered-65' class='rust '>
<span class='kw'>fn</span> <span class='ident'>eq</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>PartialEq</span><span class='op'>&gt;</span>(<span class='ident'>xs</span>: <span class='kw-2'>&amp;</span><span class='ident'>List</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>, <span class='ident'>ys</span>: <span class='kw-2'>&amp;</span><span class='ident'>List</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>) <span class='op'>-&gt;</span> <span class='ident'>bool</span> {
    <span class='comment'>// Match on the next node in both lists.</span>
    <span class='kw'>match</span> (<span class='ident'>xs</span>, <span class='ident'>ys</span>) {
        <span class='comment'>// If we have reached the end of both lists, they are equal.</span>
        (<span class='kw-2'>&amp;</span><span class='ident'>Nil</span>, <span class='kw-2'>&amp;</span><span class='ident'>Nil</span>) <span class='op'>=&gt;</span> <span class='boolval'>true</span>,
        <span class='comment'>// If the current elements of both lists are equal, keep going.</span>
        (<span class='kw-2'>&amp;</span><span class='ident'>Cons</span>(<span class='kw-2'>ref</span> <span class='ident'>x</span>, <span class='kw'>box</span> <span class='kw-2'>ref</span> <span class='ident'>next_xs</span>), <span class='kw-2'>&amp;</span><span class='ident'>Cons</span>(<span class='kw-2'>ref</span> <span class='ident'>y</span>, <span class='kw'>box</span> <span class='kw-2'>ref</span> <span class='ident'>next_ys</span>))
                <span class='kw'>if</span> <span class='ident'>x</span> <span class='op'>==</span> <span class='ident'>y</span> <span class='op'>=&gt;</span> <span class='ident'>eq</span>(<span class='ident'>next_xs</span>, <span class='ident'>next_ys</span>),
        <span class='comment'>// If the current elements are not equal, the lists are not equal.</span>
        _ <span class='op'>=&gt;</span> <span class='boolval'>false</span>
    }
}

<span class='kw'>let</span> <span class='ident'>xs</span> <span class='op'>=</span> <span class='ident'>Cons</span>(<span class='string'>&#39;c&#39;</span>, <span class='kw'>box</span> <span class='ident'>Cons</span>(<span class='string'>&#39;a&#39;</span>, <span class='kw'>box</span> <span class='ident'>Cons</span>(<span class='string'>&#39;t&#39;</span>, <span class='kw'>box</span> <span class='ident'>Nil</span>)));
<span class='kw'>let</span> <span class='ident'>ys</span> <span class='op'>=</span> <span class='ident'>Cons</span>(<span class='string'>&#39;c&#39;</span>, <span class='kw'>box</span> <span class='ident'>Cons</span>(<span class='string'>&#39;a&#39;</span>, <span class='kw'>box</span> <span class='ident'>Cons</span>(<span class='string'>&#39;t&#39;</span>, <span class='kw'>box</span> <span class='ident'>Nil</span>)));
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>eq</span>(<span class='kw-2'>&amp;</span><span class='ident'>xs</span>, <span class='kw-2'>&amp;</span><span class='ident'>ys</span>));
</pre>

<p>This would be a good opportunity to implement the <code>PartialEq</code> trait for our list type, making the <code>==</code> and
<code>!=</code> operators available. We&#39;ll need to provide an <code>impl</code> for the <code>PartialEq</code> trait and a definition of the
<code>eq</code> method. In a method, the <code>self</code> parameter refers to an instance of the type we&#39;re implementing
on.</p>
<span id='rust-example-raw-66' class='rusttest'>fn main() {
    enum List&lt;T&gt; {
        Cons(T, Box&lt;List&lt;T&gt;&gt;),
        Nil
    }
    impl&lt;T: PartialEq&gt; PartialEq for List&lt;T&gt; {
        fn eq(&amp;self, ys: &amp;List&lt;T&gt;) -&gt; bool {
            // Match on the next node in both lists.
            match (self, ys) {
                // If we have reached the end of both lists, they are equal.
                (&amp;Nil, &amp;Nil) =&gt; true,
                // If the current elements of both lists are equal, keep going.
                (&amp;Cons(ref x, box ref next_xs), &amp;Cons(ref y, box ref next_ys))
                        if x == y =&gt; next_xs == next_ys,
                // If the current elements are not equal, the lists are not equal.
                _ =&gt; false
            }
        }
    }
    
    let xs = Cons(5i, box Cons(10i, box Nil));
    let ys = Cons(5i, box Cons(10i, box Nil));
    // The methods below are part of the PartialEq trait,
    // which we implemented on our linked list.
    assert!(xs.eq(&amp;ys));
    assert!(!xs.ne(&amp;ys));
    
    // The PartialEq trait also allows us to use the shorthand infix operators.
    assert!(xs == ys);    // `xs == ys` is short for `xs.eq(&amp;ys)`
    assert!(!(xs != ys)); // `xs != ys` is short for `xs.ne(&amp;ys)`
}</span><pre id='rust-example-rendered-66' class='rust '>
<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>PartialEq</span><span class='op'>&gt;</span> <span class='ident'>PartialEq</span> <span class='kw'>for</span> <span class='ident'>List</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>fn</span> <span class='ident'>eq</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>ys</span>: <span class='kw-2'>&amp;</span><span class='ident'>List</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>) <span class='op'>-&gt;</span> <span class='ident'>bool</span> {
        <span class='comment'>// Match on the next node in both lists.</span>
        <span class='kw'>match</span> (<span class='self'>self</span>, <span class='ident'>ys</span>) {
            <span class='comment'>// If we have reached the end of both lists, they are equal.</span>
            (<span class='kw-2'>&amp;</span><span class='ident'>Nil</span>, <span class='kw-2'>&amp;</span><span class='ident'>Nil</span>) <span class='op'>=&gt;</span> <span class='boolval'>true</span>,
            <span class='comment'>// If the current elements of both lists are equal, keep going.</span>
            (<span class='kw-2'>&amp;</span><span class='ident'>Cons</span>(<span class='kw-2'>ref</span> <span class='ident'>x</span>, <span class='kw'>box</span> <span class='kw-2'>ref</span> <span class='ident'>next_xs</span>), <span class='kw-2'>&amp;</span><span class='ident'>Cons</span>(<span class='kw-2'>ref</span> <span class='ident'>y</span>, <span class='kw'>box</span> <span class='kw-2'>ref</span> <span class='ident'>next_ys</span>))
                    <span class='kw'>if</span> <span class='ident'>x</span> <span class='op'>==</span> <span class='ident'>y</span> <span class='op'>=&gt;</span> <span class='ident'>next_xs</span> <span class='op'>==</span> <span class='ident'>next_ys</span>,
            <span class='comment'>// If the current elements are not equal, the lists are not equal.</span>
            _ <span class='op'>=&gt;</span> <span class='boolval'>false</span>
        }
    }
}

<span class='kw'>let</span> <span class='ident'>xs</span> <span class='op'>=</span> <span class='ident'>Cons</span>(<span class='number'>5i</span>, <span class='kw'>box</span> <span class='ident'>Cons</span>(<span class='number'>10i</span>, <span class='kw'>box</span> <span class='ident'>Nil</span>));
<span class='kw'>let</span> <span class='ident'>ys</span> <span class='op'>=</span> <span class='ident'>Cons</span>(<span class='number'>5i</span>, <span class='kw'>box</span> <span class='ident'>Cons</span>(<span class='number'>10i</span>, <span class='kw'>box</span> <span class='ident'>Nil</span>));
<span class='comment'>// The methods below are part of the PartialEq trait,</span>
<span class='comment'>// which we implemented on our linked list.</span>
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>xs</span>.<span class='ident'>eq</span>(<span class='kw-2'>&amp;</span><span class='ident'>ys</span>));
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='op'>!</span><span class='ident'>xs</span>.<span class='ident'>ne</span>(<span class='kw-2'>&amp;</span><span class='ident'>ys</span>));

<span class='comment'>// The PartialEq trait also allows us to use the shorthand infix operators.</span>
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>xs</span> <span class='op'>==</span> <span class='ident'>ys</span>);    <span class='comment'>// `xs == ys` is short for `xs.eq(&amp;ys)`</span>
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='op'>!</span>(<span class='ident'>xs</span> <span class='op'>!=</span> <span class='ident'>ys</span>)); <span class='comment'>// `xs != ys` is short for `xs.ne(&amp;ys)`</span>
</pre>

<h1 id="more-on-boxes" class='section-header'><a
                           href="#more-on-boxes">10 More on boxes</a></h1>
<p>The most common use case for owned boxes is creating recursive data structures
like a binary search tree. Rust&#39;s trait-based generics system (covered later in
the tutorial) is usually used for static dispatch, but also provides dynamic
dispatch via boxing. Values of different types may have different sizes, but a
box is able to <em>erase</em> the difference via the layer of indirection they
provide.</p>

<p>In uncommon cases, the indirection can provide a performance gain or memory
reduction by making values smaller. However, unboxed values should almost
always be preferred when they are usable.</p>

<p>Note that returning large unboxed values via boxes is unnecessary. A large
value is returned via a hidden output parameter, and the decision on where to
place the return value should be left to the caller:</p>
<span id='rust-example-raw-67' class='rusttest'>fn main() {
    fn foo() -&gt; (u64, u64, u64, u64, u64, u64) {
        (5, 5, 5, 5, 5, 5)
    }
    
    let x = box foo(); // allocates a box, and writes the integers directly to it
}</span><pre id='rust-example-rendered-67' class='rust '>
<span class='kw'>fn</span> <span class='ident'>foo</span>() <span class='op'>-&gt;</span> (<span class='ident'>u64</span>, <span class='ident'>u64</span>, <span class='ident'>u64</span>, <span class='ident'>u64</span>, <span class='ident'>u64</span>, <span class='ident'>u64</span>) {
    (<span class='number'>5</span>, <span class='number'>5</span>, <span class='number'>5</span>, <span class='number'>5</span>, <span class='number'>5</span>, <span class='number'>5</span>)
}

<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='kw'>box</span> <span class='ident'>foo</span>(); <span class='comment'>// allocates a box, and writes the integers directly to it</span>
</pre>

<p>Beyond the properties granted by the size, an owned box behaves as a regular
value by inheriting the mutability and lifetime of the owner:</p>
<span id='rust-example-raw-68' class='rusttest'>fn main() {
    let x = 5i; // immutable
    let mut y = 5i; // mutable
    y += 2;
    
    let x = box 5i; // immutable
    let mut y = box 5i; // mutable
    *y += 2; // the `*` operator is needed to access the contained value
}</span><pre id='rust-example-rendered-68' class='rust '>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5i</span>; <span class='comment'>// immutable</span>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='number'>5i</span>; <span class='comment'>// mutable</span>
<span class='ident'>y</span> <span class='op'>+=</span> <span class='number'>2</span>;

<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='kw'>box</span> <span class='number'>5i</span>; <span class='comment'>// immutable</span>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='kw'>box</span> <span class='number'>5i</span>; <span class='comment'>// mutable</span>
<span class='op'>*</span><span class='ident'>y</span> <span class='op'>+=</span> <span class='number'>2</span>; <span class='comment'>// the `*` operator is needed to access the contained value</span>
</pre>

<h1 id="references-1" class='section-header'><a
                           href="#references-1">11 References</a></h1>
<p>In contrast with
owned boxes, where the holder of an owned box is the owner of the pointed-to
memory, references never imply ownership - they are &quot;borrowed&quot;.
You can borrow a reference to
any object, and the compiler verifies that it cannot outlive the lifetime of
the object.</p>

<p>As an example, consider a simple struct type, <code>Point</code>:</p>
<span id='rust-example-raw-69' class='rusttest'>fn main() {
    struct Point {
        x: f64,
        y: f64
    }
}</span><pre id='rust-example-rendered-69' class='rust '>
<span class='kw'>struct</span> <span class='ident'>Point</span> {
    <span class='ident'>x</span>: <span class='ident'>f64</span>,
    <span class='ident'>y</span>: <span class='ident'>f64</span>
}
</pre>

<p>We can use this simple definition to allocate points in many different
ways. For example, in this code, each of these local variables
contains a point, but allocated in a different location:</p>
<span id='rust-example-raw-70' class='rusttest'>fn main() {
    struct Point { x: f64, y: f64 }
    let on_the_stack :     Point  =     Point { x: 3.0, y: 4.0 };
    let on_the_heap  : Box&lt;Point&gt; = box Point { x: 7.0, y: 9.0 };
}</span><pre id='rust-example-rendered-70' class='rust '>
<span class='kw'>let</span> <span class='ident'>on_the_stack</span> :     <span class='ident'>Point</span>  <span class='op'>=</span>     <span class='ident'>Point</span> { <span class='ident'>x</span>: <span class='number'>3.0</span>, <span class='ident'>y</span>: <span class='number'>4.0</span> };
<span class='kw'>let</span> <span class='ident'>on_the_heap</span>  : <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>Point</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='kw'>box</span> <span class='ident'>Point</span> { <span class='ident'>x</span>: <span class='number'>7.0</span>, <span class='ident'>y</span>: <span class='number'>9.0</span> };
</pre>

<p>Suppose we want to write a procedure that computes the distance
between any two points, no matter where they are stored. One option is
to define a function that takes two arguments of type pointthat is,
it takes the points by value. But this will cause the points to be
copied when we call the function. For points, this is probably not so
bad, but often copies are expensive. So wed like to define a function
that takes the points by pointer. We can use references to do this:</p>
<span id='rust-example-raw-71' class='rusttest'>fn main() {
    struct Point { x: f64, y: f64 }
    fn compute_distance(p1: &amp;Point, p2: &amp;Point) -&gt; f64 {
        let x_d = p1.x - p2.x;
        let y_d = p1.y - p2.y;
        (x_d * x_d + y_d * y_d).sqrt()
    }
}</span><pre id='rust-example-rendered-71' class='rust '>
<span class='kw'>fn</span> <span class='ident'>compute_distance</span>(<span class='ident'>p1</span>: <span class='kw-2'>&amp;</span><span class='ident'>Point</span>, <span class='ident'>p2</span>: <span class='kw-2'>&amp;</span><span class='ident'>Point</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
    <span class='kw'>let</span> <span class='ident'>x_d</span> <span class='op'>=</span> <span class='ident'>p1</span>.<span class='ident'>x</span> <span class='op'>-</span> <span class='ident'>p2</span>.<span class='ident'>x</span>;
    <span class='kw'>let</span> <span class='ident'>y_d</span> <span class='op'>=</span> <span class='ident'>p1</span>.<span class='ident'>y</span> <span class='op'>-</span> <span class='ident'>p2</span>.<span class='ident'>y</span>;
    (<span class='ident'>x_d</span> <span class='op'>*</span> <span class='ident'>x_d</span> <span class='op'>+</span> <span class='ident'>y_d</span> <span class='op'>*</span> <span class='ident'>y_d</span>).<span class='ident'>sqrt</span>()
}
</pre>

<p>Now we can call <code>compute_distance()</code> in various ways:</p>
<span id='rust-example-raw-72' class='rusttest'>fn main() {
    struct Point{ x: f64, y: f64 };
    let on_the_stack :     Point  =     Point { x: 3.0, y: 4.0 };
    let on_the_heap  : Box&lt;Point&gt; = box Point { x: 7.0, y: 9.0 };
    fn compute_distance(p1: &amp;Point, p2: &amp;Point) -&gt; f64 { 0.0 }
    compute_distance(&amp;on_the_stack, on_the_heap);
}</span><pre id='rust-example-rendered-72' class='rust '>
<span class='ident'>compute_distance</span>(<span class='kw-2'>&amp;</span><span class='ident'>on_the_stack</span>, <span class='ident'>on_the_heap</span>);
</pre>

<p>Here the <code>&amp;</code> operator is used to take the address of the variable
<code>on_the_stack</code>; this is because <code>on_the_stack</code> has the type <code>Point</code>
(that is, a struct value) and we have to take its address to get a
reference. We also call this <em>borrowing</em> the local variable
<code>on_the_stack</code>, because we are creating an alias: that is, another
route to the same data.</p>

<p>In the case of <code>owned_box</code>, however, no
explicit action is necessary. The compiler will automatically convert
a box <code>box point</code> to a reference like
<code>&amp;point</code>. This is another form of borrowing; in this case, the
contents of the owned box are being lent out.</p>

<p>Whenever a value is borrowed, there are some limitations on what you
can do with the original. For example, if the contents of a variable
have been lent out, you cannot send that variable to another task, nor
will you be permitted to take actions that might cause the borrowed
value to be freed or to change its type. This rule should make
intuitive sense: you must wait for a borrowed value to be returned
(that is, for the reference to go out of scope) before you can
make full use of it again.</p>

<p>For a more in-depth explanation of references and lifetimes, read the
<a href="guide-lifetimes.html">references and lifetimes guide</a>.</p>

<h2 id="freezing" class='section-header'><a
                           href="#freezing">11.1 Freezing</a></h2>
<p>Lending an &amp;-pointer to an object freezes the pointed-to object and prevents
mutationeven if the object was declared as <code>mut</code>.  <code>Freeze</code> objects have
freezing enforced statically at compile-time. An example of a non-<code>Freeze</code> type
is <a href="http://doc.rust-lang.org/std/cell/struct.RefCell.html"><code>RefCell&lt;T&gt;</code></a>.</p>
<span id='rust-example-raw-73' class='rusttest'>fn main() {
    let mut x = 5i;
    {
        let y = &amp;x; // `x` is now frozen. It cannot be modified or re-assigned.
    }
    // `x` is now unfrozen again
    x = 3;
}</span><pre id='rust-example-rendered-73' class='rust '>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>5i</span>;
{
    <span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>x</span>; <span class='comment'>// `x` is now frozen. It cannot be modified or re-assigned.</span>
}
<span class='comment'>// `x` is now unfrozen again</span>
</pre>

<h1 id="dereferencing-pointers" class='section-header'><a
                           href="#dereferencing-pointers">12 Dereferencing pointers</a></h1>
<p>Rust uses the unary star operator (<code>*</code>) to access the contents of a
box or pointer, similarly to C.</p>
<span id='rust-example-raw-74' class='rusttest'>fn main() {
    let owned = box 10i;
    let borrowed = &amp;20i;
    
    let sum = *owned + *borrowed;
}</span><pre id='rust-example-rendered-74' class='rust '>
<span class='kw'>let</span> <span class='ident'>owned</span> <span class='op'>=</span> <span class='kw'>box</span> <span class='number'>10i</span>;
<span class='kw'>let</span> <span class='ident'>borrowed</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='number'>20i</span>;

<span class='kw'>let</span> <span class='ident'>sum</span> <span class='op'>=</span> <span class='op'>*</span><span class='ident'>owned</span> <span class='op'>+</span> <span class='op'>*</span><span class='ident'>borrowed</span>;
</pre>

<p>Dereferenced mutable pointers may appear on the left hand side of
assignments. Such an assignment modifies the value that the pointer
points to.</p>
<span id='rust-example-raw-75' class='rusttest'>fn main() {
    let mut owned = box 10i;
    
    let mut value = 20i;
    let borrowed = &amp;mut value;
    
    *owned = *borrowed + 100;
    *borrowed = *owned + 1000;
}</span><pre id='rust-example-rendered-75' class='rust '>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>owned</span> <span class='op'>=</span> <span class='kw'>box</span> <span class='number'>10i</span>;

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>value</span> <span class='op'>=</span> <span class='number'>20i</span>;
<span class='kw'>let</span> <span class='ident'>borrowed</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>value</span>;

<span class='op'>*</span><span class='ident'>owned</span> <span class='op'>=</span> <span class='op'>*</span><span class='ident'>borrowed</span> <span class='op'>+</span> <span class='number'>100</span>;
<span class='op'>*</span><span class='ident'>borrowed</span> <span class='op'>=</span> <span class='op'>*</span><span class='ident'>owned</span> <span class='op'>+</span> <span class='number'>1000</span>;
</pre>

<p>Pointers have high operator precedence, but lower precedence than the
dot operator used for field and method access. This precedence order
can sometimes make code awkward and parenthesis-filled.</p>
<span id='rust-example-raw-76' class='rusttest'>fn main() {
    struct Point { x: f64, y: f64 }
    enum Shape { Rectangle(Point, Point) }
    impl Shape { fn area(&amp;self) -&gt; int { 0 } }
    let start = box Point { x: 10.0, y: 20.0 };
    let end = box Point { x: (*start).x + 100.0, y: (*start).y + 100.0 };
    let rect = &amp;Rectangle(*start, *end);
    let area = (*rect).area();
}</span><pre id='rust-example-rendered-76' class='rust '>
<span class='kw'>let</span> <span class='ident'>start</span> <span class='op'>=</span> <span class='kw'>box</span> <span class='ident'>Point</span> { <span class='ident'>x</span>: <span class='number'>10.0</span>, <span class='ident'>y</span>: <span class='number'>20.0</span> };
<span class='kw'>let</span> <span class='ident'>end</span> <span class='op'>=</span> <span class='kw'>box</span> <span class='ident'>Point</span> { <span class='ident'>x</span>: (<span class='op'>*</span><span class='ident'>start</span>).<span class='ident'>x</span> <span class='op'>+</span> <span class='number'>100.0</span>, <span class='ident'>y</span>: (<span class='op'>*</span><span class='ident'>start</span>).<span class='ident'>y</span> <span class='op'>+</span> <span class='number'>100.0</span> };
<span class='kw'>let</span> <span class='ident'>rect</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>Rectangle</span>(<span class='op'>*</span><span class='ident'>start</span>, <span class='op'>*</span><span class='ident'>end</span>);
<span class='kw'>let</span> <span class='ident'>area</span> <span class='op'>=</span> (<span class='op'>*</span><span class='ident'>rect</span>).<span class='ident'>area</span>();
</pre>

<p>To combat this ugliness the dot operator applies <em>automatic pointer
dereferencing</em> to the receiver (the value on the left-hand side of the
dot), so in most cases, explicitly dereferencing the receiver is not necessary.</p>
<span id='rust-example-raw-77' class='rusttest'>fn main() {
    struct Point { x: f64, y: f64 }
    enum Shape { Rectangle(Point, Point) }
    impl Shape { fn area(&amp;self) -&gt; int { 0 } }
    let start = box Point { x: 10.0, y: 20.0 };
    let end = box Point { x: start.x + 100.0, y: start.y + 100.0 };
    let rect = &amp;Rectangle(*start, *end);
    let area = rect.area();
}</span><pre id='rust-example-rendered-77' class='rust '>
<span class='kw'>let</span> <span class='ident'>start</span> <span class='op'>=</span> <span class='kw'>box</span> <span class='ident'>Point</span> { <span class='ident'>x</span>: <span class='number'>10.0</span>, <span class='ident'>y</span>: <span class='number'>20.0</span> };
<span class='kw'>let</span> <span class='ident'>end</span> <span class='op'>=</span> <span class='kw'>box</span> <span class='ident'>Point</span> { <span class='ident'>x</span>: <span class='ident'>start</span>.<span class='ident'>x</span> <span class='op'>+</span> <span class='number'>100.0</span>, <span class='ident'>y</span>: <span class='ident'>start</span>.<span class='ident'>y</span> <span class='op'>+</span> <span class='number'>100.0</span> };
<span class='kw'>let</span> <span class='ident'>rect</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>Rectangle</span>(<span class='op'>*</span><span class='ident'>start</span>, <span class='op'>*</span><span class='ident'>end</span>);
<span class='kw'>let</span> <span class='ident'>area</span> <span class='op'>=</span> <span class='ident'>rect</span>.<span class='ident'>area</span>();
</pre>

<p>You can write an expression that dereferences any number of pointers
automatically. For example, if you feel inclined, you could write
something silly like</p>
<span id='rust-example-raw-78' class='rusttest'>fn main() {
    struct Point { x: f64, y: f64 }
    let point = &amp;box Point { x: 10.0, y: 20.0 };
    println!(&quot;{:f}&quot;, point.x);
}</span><pre id='rust-example-rendered-78' class='rust '>
<span class='kw'>let</span> <span class='ident'>point</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='kw'>box</span> <span class='ident'>Point</span> { <span class='ident'>x</span>: <span class='number'>10.0</span>, <span class='ident'>y</span>: <span class='number'>20.0</span> };
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{:f}&quot;</span>, <span class='ident'>point</span>.<span class='ident'>x</span>);
</pre>

<p>The indexing operator (<code>[]</code>) also auto-dereferences.</p>

<h1 id="vectors-and-strings" class='section-header'><a
                           href="#vectors-and-strings">13 Vectors and strings</a></h1>
<p>A vector is a contiguous block of memory containing zero or more values of the
same type. Rust also supports vector reference types, called slices, which are
a view into a block of memory represented as a pointer and a length.</p>

<p>Strings are represented as vectors of <code>u8</code>, with the guarantee of containing a
valid UTF-8 sequence.</p>

<p>Fixed-size vectors are an unboxed block of memory, with the element length as
part of the type. A fixed-size vector owns the elements it contains, so the
elements are mutable if the vector is mutable. Fixed-size strings do not exist.</p>
<span id='rust-example-raw-79' class='rusttest'>fn main() {
    // A fixed-size vector
    let numbers = [1i, 2, 3];
    let more_numbers = numbers;
    
    // The type of a fixed-size vector is written as `[Type, ..length]`
    let five_zeroes: [int, ..5] = [0, ..5];
}</span><pre id='rust-example-rendered-79' class='rust '>
<span class='comment'>// A fixed-size vector</span>
<span class='kw'>let</span> <span class='ident'>numbers</span> <span class='op'>=</span> [<span class='number'>1i</span>, <span class='number'>2</span>, <span class='number'>3</span>];
<span class='kw'>let</span> <span class='ident'>more_numbers</span> <span class='op'>=</span> <span class='ident'>numbers</span>;

<span class='comment'>// The type of a fixed-size vector is written as `[Type, ..length]`</span>
<span class='kw'>let</span> <span class='ident'>five_zeroes</span>: [<span class='ident'>int</span>, ..<span class='number'>5</span>] <span class='op'>=</span> [<span class='number'>0</span>, ..<span class='number'>5</span>];
</pre>

<p>A unique vector is dynamically sized, and has a destructor to clean up
allocated memory on the heap. A unique vector owns the elements it contains, so
the elements are mutable if the vector is mutable.</p>
<span id='rust-example-raw-80' class='rusttest'>fn main() {
    use std::string::String;
    
    // A dynamically sized vector (unique vector)
    let mut numbers = vec![1i, 2, 3];
    numbers.push(4);
    numbers.push(5);
    
    // The type of a unique vector is written as `Vec&lt;int&gt;`
    let more_numbers: Vec&lt;int&gt; = numbers.move_iter().map(|i| i+1).collect();
    
    // The original `numbers` value can no longer be used, due to move semantics.
    
    let mut string = String::from_str(&quot;fo&quot;);
    string.push_char(&#39;o&#39;);
}</span><pre id='rust-example-rendered-80' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>string</span>::<span class='ident'>String</span>;

<span class='comment'>// A dynamically sized vector (unique vector)</span>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>numbers</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='number'>1i</span>, <span class='number'>2</span>, <span class='number'>3</span>];
<span class='ident'>numbers</span>.<span class='ident'>push</span>(<span class='number'>4</span>);
<span class='ident'>numbers</span>.<span class='ident'>push</span>(<span class='number'>5</span>);

<span class='comment'>// The type of a unique vector is written as `Vec&lt;int&gt;`</span>
<span class='kw'>let</span> <span class='ident'>more_numbers</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>int</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>numbers</span>.<span class='ident'>move_iter</span>().<span class='ident'>map</span>(<span class='op'>|</span><span class='ident'>i</span><span class='op'>|</span> <span class='ident'>i</span><span class='op'>+</span><span class='number'>1</span>).<span class='ident'>collect</span>();

<span class='comment'>// The original `numbers` value can no longer be used, due to move semantics.</span>

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>string</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>from_str</span>(<span class='string'>&quot;fo&quot;</span>);
<span class='ident'>string</span>.<span class='ident'>push_char</span>(<span class='string'>&#39;o&#39;</span>);
</pre>

<p>Slices are similar to fixed-size vectors, but the length is not part of the
type. They simply point into a block of memory and do not have ownership over
the elements.</p>
<span id='rust-example-raw-81' class='rusttest'>fn main() {
    // A slice
    let xs = &amp;[1, 2, 3];
    
    // Slices have their type written as `&amp;[int]`
    let ys: &amp;[int] = xs;
    
    // Other vector types coerce to slices
    let three = [1, 2, 3];
    let zs: &amp;[int] = three;
    
    // An unadorned string literal is an immutable string slice
    let string = &quot;foobar&quot;;
    
    // A string slice type is written as `&amp;str`
    let view: &amp;str = string.slice(0, 3);
}</span><pre id='rust-example-rendered-81' class='rust '>
<span class='comment'>// A slice</span>
<span class='kw'>let</span> <span class='ident'>xs</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];

<span class='comment'>// Slices have their type written as `&amp;[int]`</span>
<span class='kw'>let</span> <span class='ident'>ys</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>int</span>] <span class='op'>=</span> <span class='ident'>xs</span>;

<span class='comment'>// Other vector types coerce to slices</span>
<span class='kw'>let</span> <span class='ident'>three</span> <span class='op'>=</span> [<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];
<span class='kw'>let</span> <span class='ident'>zs</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>int</span>] <span class='op'>=</span> <span class='ident'>three</span>;

<span class='comment'>// An unadorned string literal is an immutable string slice</span>
<span class='kw'>let</span> <span class='ident'>string</span> <span class='op'>=</span> <span class='string'>&quot;foobar&quot;</span>;

<span class='comment'>// A string slice type is written as `&amp;str`</span>
<span class='kw'>let</span> <span class='ident'>view</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span> <span class='op'>=</span> <span class='ident'>string</span>.<span class='ident'>slice</span>(<span class='number'>0</span>, <span class='number'>3</span>);
</pre>

<p>Mutable slices also exist, just as there are mutable references. However, there
are no mutable string slices. Strings are a multi-byte encoding (UTF-8) of
Unicode code points, so they cannot be freely mutated without the ability to
alter the length.</p>
<span id='rust-example-raw-82' class='rusttest'>fn main() {
    let mut xs = [1i, 2i, 3i];
    let view = xs.mut_slice(0, 2);
    view[0] = 5;
    
    // The type of a mutable slice is written as `&amp;mut [T]`
    let ys: &amp;mut [int] = &amp;mut [1i, 2i, 3i];
}</span><pre id='rust-example-rendered-82' class='rust '>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>xs</span> <span class='op'>=</span> [<span class='number'>1i</span>, <span class='number'>2i</span>, <span class='number'>3i</span>];
<span class='kw'>let</span> <span class='ident'>view</span> <span class='op'>=</span> <span class='ident'>xs</span>.<span class='ident'>mut_slice</span>(<span class='number'>0</span>, <span class='number'>2</span>);
<span class='ident'>view</span>[<span class='number'>0</span>] <span class='op'>=</span> <span class='number'>5</span>;

<span class='comment'>// The type of a mutable slice is written as `&amp;mut [T]`</span>
<span class='kw'>let</span> <span class='ident'>ys</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> [<span class='ident'>int</span>] <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> [<span class='number'>1i</span>, <span class='number'>2i</span>, <span class='number'>3i</span>];
</pre>

<p>Square brackets denote indexing into a slice or fixed-size vector:</p>
<span id='rust-example-raw-83' class='rusttest'>fn main() {
    enum Crayon { Almond, AntiqueBrass, Apricot,
                  Aquamarine, Asparagus, AtomicTangerine,
                  BananaMania, Beaver, Bittersweet };
    fn draw_scene(c: Crayon) { }
    let crayons: [Crayon, ..3] = [BananaMania, Beaver, Bittersweet];
    match crayons[0] {
        Bittersweet =&gt; draw_scene(crayons[0]),
        _ =&gt; ()
    }
}</span><pre id='rust-example-rendered-83' class='rust '>
<span class='kw'>let</span> <span class='ident'>crayons</span>: [<span class='ident'>Crayon</span>, ..<span class='number'>3</span>] <span class='op'>=</span> [<span class='ident'>BananaMania</span>, <span class='ident'>Beaver</span>, <span class='ident'>Bittersweet</span>];
<span class='kw'>match</span> <span class='ident'>crayons</span>[<span class='number'>0</span>] {
    <span class='ident'>Bittersweet</span> <span class='op'>=&gt;</span> <span class='ident'>draw_scene</span>(<span class='ident'>crayons</span>[<span class='number'>0</span>]),
    _ <span class='op'>=&gt;</span> ()
}
</pre>

<p>A slice or fixed-size vector can be destructured using pattern matching:</p>
<span id='rust-example-raw-84' class='rusttest'>fn main() {
    let numbers: &amp;[int] = &amp;[1, 2, 3];
    let score = match numbers {
        [] =&gt; 0,
        [a] =&gt; a * 10,
        [a, b] =&gt; a * 6 + b * 4,
        [a, b, c, ..rest] =&gt; a * 5 + b * 3 + c * 2 + rest.len() as int
    };
}</span><pre id='rust-example-rendered-84' class='rust '>
<span class='kw'>let</span> <span class='ident'>numbers</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>int</span>] <span class='op'>=</span> <span class='kw-2'>&amp;</span>[<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>];
<span class='kw'>let</span> <span class='ident'>score</span> <span class='op'>=</span> <span class='kw'>match</span> <span class='ident'>numbers</span> {
    [] <span class='op'>=&gt;</span> <span class='number'>0</span>,
    [<span class='ident'>a</span>] <span class='op'>=&gt;</span> <span class='ident'>a</span> <span class='op'>*</span> <span class='number'>10</span>,
    [<span class='ident'>a</span>, <span class='ident'>b</span>] <span class='op'>=&gt;</span> <span class='ident'>a</span> <span class='op'>*</span> <span class='number'>6</span> <span class='op'>+</span> <span class='ident'>b</span> <span class='op'>*</span> <span class='number'>4</span>,
    [<span class='ident'>a</span>, <span class='ident'>b</span>, <span class='ident'>c</span>, ..<span class='ident'>rest</span>] <span class='op'>=&gt;</span> <span class='ident'>a</span> <span class='op'>*</span> <span class='number'>5</span> <span class='op'>+</span> <span class='ident'>b</span> <span class='op'>*</span> <span class='number'>3</span> <span class='op'>+</span> <span class='ident'>c</span> <span class='op'>*</span> <span class='number'>2</span> <span class='op'>+</span> <span class='ident'>rest</span>.<span class='ident'>len</span>() <span class='kw'>as</span> <span class='ident'>int</span>
};
</pre>

<p>Both vectors and strings support a number of useful <a href="#methods">methods</a>,
defined in <a href="std/vec/index.html"><code>std::vec</code></a>, <a href="std/slice/index.html"><code>std::slice</code></a>, and <a href="std/str/index.html"><code>std::str</code></a>.</p>

<h1 id="ownership-escape-hatches" class='section-header'><a
                           href="#ownership-escape-hatches">14 Ownership escape hatches</a></h1>
<p>Ownership can cleanly describe tree-like data structures, and references provide non-owning pointers. However, more flexibility is often desired and Rust provides ways to escape from strict
single parent ownership.</p>

<p>The standard library provides the <code>std::rc::Rc</code> pointer type to express <em>shared ownership</em> over a
reference counted box. As soon as all of the <code>Rc</code> pointers go out of scope, the box and the
contained value are destroyed.</p>
<span id='rust-example-raw-85' class='rusttest'>fn main() {
    use std::rc::Rc;
    
    // A fixed-size array allocated in a reference-counted box
    let x = Rc::new([1i, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
    let y = x.clone(); // a new owner
    let z = x; // this moves `x` into `z`, rather than creating a new owner
    
    assert!(*z == [1i, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
    
    // the variable is mutable, but not the contents of the box
    let mut a = Rc::new([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]);
    a = z;
}</span><pre id='rust-example-rendered-85' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>rc</span>::<span class='ident'>Rc</span>;

<span class='comment'>// A fixed-size array allocated in a reference-counted box</span>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='ident'>Rc</span>::<span class='ident'>new</span>([<span class='number'>1i</span>, <span class='number'>2</span>, <span class='number'>3</span>, <span class='number'>4</span>, <span class='number'>5</span>, <span class='number'>6</span>, <span class='number'>7</span>, <span class='number'>8</span>, <span class='number'>9</span>, <span class='number'>10</span>]);
<span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='ident'>x</span>.<span class='ident'>clone</span>(); <span class='comment'>// a new owner</span>
<span class='kw'>let</span> <span class='ident'>z</span> <span class='op'>=</span> <span class='ident'>x</span>; <span class='comment'>// this moves `x` into `z`, rather than creating a new owner</span>

<span class='macro'>assert</span><span class='macro'>!</span>(<span class='op'>*</span><span class='ident'>z</span> <span class='op'>==</span> [<span class='number'>1i</span>, <span class='number'>2</span>, <span class='number'>3</span>, <span class='number'>4</span>, <span class='number'>5</span>, <span class='number'>6</span>, <span class='number'>7</span>, <span class='number'>8</span>, <span class='number'>9</span>, <span class='number'>10</span>]);

<span class='comment'>// the variable is mutable, but not the contents of the box</span>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>a</span> <span class='op'>=</span> <span class='ident'>Rc</span>::<span class='ident'>new</span>([<span class='number'>10</span>, <span class='number'>9</span>, <span class='number'>8</span>, <span class='number'>7</span>, <span class='number'>6</span>, <span class='number'>5</span>, <span class='number'>4</span>, <span class='number'>3</span>, <span class='number'>2</span>, <span class='number'>1</span>]);
<span class='ident'>a</span> <span class='op'>=</span> <span class='ident'>z</span>;
</pre>

<p>A garbage collected pointer is provided via <code>std::gc::Gc</code>, with a task-local garbage collector
having ownership of the box. It allows the creation of cycles, and the individual <code>Gc</code> pointers do
not have a destructor.</p>
<span id='rust-example-raw-86' class='rusttest'>fn main() {
    use std::gc::GC;
    
    // A fixed-size array allocated in a garbage-collected box
    let x = box(GC) [1i, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    let y = x; // does not perform a move, unlike with `Rc`
    let z = x;
    
    assert!(*z == [1i, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
}</span><pre id='rust-example-rendered-86' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>gc</span>::<span class='ident'>GC</span>;

<span class='comment'>// A fixed-size array allocated in a garbage-collected box</span>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='kw'>box</span>(<span class='ident'>GC</span>) [<span class='number'>1i</span>, <span class='number'>2</span>, <span class='number'>3</span>, <span class='number'>4</span>, <span class='number'>5</span>, <span class='number'>6</span>, <span class='number'>7</span>, <span class='number'>8</span>, <span class='number'>9</span>, <span class='number'>10</span>];
<span class='kw'>let</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='ident'>x</span>; <span class='comment'>// does not perform a move, unlike with `Rc`</span>
<span class='kw'>let</span> <span class='ident'>z</span> <span class='op'>=</span> <span class='ident'>x</span>;

<span class='macro'>assert</span><span class='macro'>!</span>(<span class='op'>*</span><span class='ident'>z</span> <span class='op'>==</span> [<span class='number'>1i</span>, <span class='number'>2</span>, <span class='number'>3</span>, <span class='number'>4</span>, <span class='number'>5</span>, <span class='number'>6</span>, <span class='number'>7</span>, <span class='number'>8</span>, <span class='number'>9</span>, <span class='number'>10</span>]);
</pre>

<p>With shared ownership, mutability cannot be inherited so the boxes are always immutable. However,
it&#39;s possible to use <em>dynamic</em> mutability via types like <code>std::cell::Cell</code> where freezing is handled
via dynamic checks and can fail at runtime.</p>

<p>The <code>Rc</code> and <code>Gc</code> types are not sendable, so they cannot be used to share memory between tasks. Safe
immutable and mutable shared memory is provided by the <code>sync::arc</code> module.</p>

<h1 id="closures" class='section-header'><a
                           href="#closures">15 Closures</a></h1>
<p>Named functions, like those we&#39;ve seen so far, may not refer to local
variables declared outside the function: they do not close over their
environment (sometimes referred to as &quot;capturing&quot; variables in their
environment). For example, you couldn&#39;t write the following:</p>
<span id='rust-example-raw-87' class='rusttest'>fn main() {
    let x = 3;
    
    // `fun` cannot refer to `x`
    fn fun() -&gt; () { println!(&quot;{}&quot;, x); }
}</span><pre id='rust-example-rendered-87' class='rust '>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>3</span>;

<span class='comment'>// `fun` cannot refer to `x`</span>
<span class='kw'>fn</span> <span class='ident'>fun</span>() <span class='op'>-&gt;</span> () { <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>x</span>); }
</pre>

<p>A <em>closure</em> does support accessing the enclosing scope; below we will create
2 <em>closures</em> (nameless functions). Compare how <code>||</code> replaces <code>()</code> and how
they try to access <code>x</code>:</p>
<span id='rust-example-raw-88' class='rusttest'>fn main() {
    let x = 3;
    
    // `fun` is an invalid definition
    fn  fun       () -&gt; () { println!(&quot;{}&quot;, x) }  // cannot capture from enclosing scope
    let closure = || -&gt; () { println!(&quot;{}&quot;, x) }; // can capture from enclosing scope
    
    // `fun_arg` is an invalid definition
    fn  fun_arg       (arg: int) -&gt; () { println!(&quot;{}&quot;, arg + x) }  // cannot capture
    let closure_arg = |arg: int| -&gt; () { println!(&quot;{}&quot;, arg + x) }; // can capture
    //                      ^
    // Requires a type because the implementation needs to know which `+` to use.
    // In the future, the implementation may not need the help.
    
    fun();          // Still won&#39;t work
    closure();      // Prints: 3
    
    fun_arg(7);     // Still won&#39;t work
    closure_arg(7); // Prints: 10
}</span><pre id='rust-example-rendered-88' class='rust '>
<span class='kw'>let</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>3</span>;

<span class='comment'>// `fun` is an invalid definition</span>
<span class='kw'>fn</span>  <span class='ident'>fun</span>       () <span class='op'>-&gt;</span> () { <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>x</span>) }  <span class='comment'>// cannot capture from enclosing scope</span>
<span class='kw'>let</span> <span class='ident'>closure</span> <span class='op'>=</span> <span class='op'>||</span> <span class='op'>-&gt;</span> () { <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>x</span>) }; <span class='comment'>// can capture from enclosing scope</span>

<span class='comment'>// `fun_arg` is an invalid definition</span>
<span class='kw'>fn</span>  <span class='ident'>fun_arg</span>       (<span class='ident'>arg</span>: <span class='ident'>int</span>) <span class='op'>-&gt;</span> () { <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>arg</span> <span class='op'>+</span> <span class='ident'>x</span>) }  <span class='comment'>// cannot capture</span>
<span class='kw'>let</span> <span class='ident'>closure_arg</span> <span class='op'>=</span> <span class='op'>|</span><span class='ident'>arg</span>: <span class='ident'>int</span><span class='op'>|</span> <span class='op'>-&gt;</span> () { <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>arg</span> <span class='op'>+</span> <span class='ident'>x</span>) }; <span class='comment'>// can capture</span>
<span class='comment'>//                      ^</span>
<span class='comment'>// Requires a type because the implementation needs to know which `+` to use.</span>
<span class='comment'>// In the future, the implementation may not need the help.</span>

<span class='ident'>fun</span>();          <span class='comment'>// Still won&#39;t work</span>
<span class='ident'>closure</span>();      <span class='comment'>// Prints: 3</span>

<span class='ident'>fun_arg</span>(<span class='number'>7</span>);     <span class='comment'>// Still won&#39;t work</span>
<span class='ident'>closure_arg</span>(<span class='number'>7</span>); <span class='comment'>// Prints: 10</span>
</pre>

<p>Closures begin with the argument list between vertical bars and are followed by
a single expression. Remember that a block, <code>{ &lt;expr1&gt;; &lt;expr2&gt;; ... }</code>, is
considered a single expression: it evaluates to the result of the last
expression it contains if that expression is not followed by a semicolon,
otherwise the block evaluates to <code>()</code>, the unit value.</p>

<p>In general, return types and all argument types must be specified
explicitly for function definitions.  (As previously mentioned in the
<a href="#functions">Functions section</a>, omitting the return type from a
function declaration is synonymous with an explicit declaration of
return type unit, <code>()</code>.)</p>
<span id='rust-example-raw-89' class='rusttest'>fn main() {
    fn  fun   (x: int)         { println!(&quot;{}&quot;, x) } // this is same as saying `-&gt; ()`
    fn  square(x: int) -&gt; uint { (x * x) as uint }   // other return types are explicit
    
    // Error: mismatched types: expected `()` but found `uint`
    fn  badfun(x: int)         { (x * x) as uint }
}</span><pre id='rust-example-rendered-89' class='rust '>
<span class='kw'>fn</span>  <span class='ident'>fun</span>   (<span class='ident'>x</span>: <span class='ident'>int</span>)         { <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>x</span>) } <span class='comment'>// this is same as saying `-&gt; ()`</span>
<span class='kw'>fn</span>  <span class='ident'>square</span>(<span class='ident'>x</span>: <span class='ident'>int</span>) <span class='op'>-&gt;</span> <span class='ident'>uint</span> { (<span class='ident'>x</span> <span class='op'>*</span> <span class='ident'>x</span>) <span class='kw'>as</span> <span class='ident'>uint</span> }   <span class='comment'>// other return types are explicit</span>

<span class='comment'>// Error: mismatched types: expected `()` but found `uint`</span>
<span class='kw'>fn</span>  <span class='ident'>badfun</span>(<span class='ident'>x</span>: <span class='ident'>int</span>)         { (<span class='ident'>x</span> <span class='op'>*</span> <span class='ident'>x</span>) <span class='kw'>as</span> <span class='ident'>uint</span> }
</pre>

<p>On the other hand, the compiler can usually infer both the argument
and return types for a closure expression; therefore they are often
omitted, since both a human reader and the compiler can deduce the
types from the immediate context.  This is in contrast to function
declarations, which require types to be specified and are not subject
to type inference. Compare:</p>
<span id='rust-example-raw-90' class='rusttest'>fn main() {
    // `fun` as a function declaration cannot infer the type of `x`, so it must be provided
    fn  fun       (x: int) { println!(&quot;{}&quot;, x) }
    let closure = |x     | { println!(&quot;{}&quot;, x) }; // infers `x: int`, return type `()`
    
    // For closures, omitting a return type is *not* synonymous with `-&gt; ()`
    let add_3   = |y     | { 3i + y }; // infers `y: int`, return type `int`.
    
    fun(10);            // Prints 10
    closure(20);        // Prints 20
    closure(add_3(30)); // Prints 33
    
    fun(&quot;String&quot;); // Error: mismatched types
    
    // Error: mismatched types
    // inference already assigned `closure` the type `|int| -&gt; ()`
    closure(&quot;String&quot;);
}</span><pre id='rust-example-rendered-90' class='rust '>
<span class='comment'>// `fun` as a function declaration cannot infer the type of `x`, so it must be provided</span>
<span class='kw'>fn</span>  <span class='ident'>fun</span>       (<span class='ident'>x</span>: <span class='ident'>int</span>) { <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>x</span>) }
<span class='kw'>let</span> <span class='ident'>closure</span> <span class='op'>=</span> <span class='op'>|</span><span class='ident'>x</span>     <span class='op'>|</span> { <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>x</span>) }; <span class='comment'>// infers `x: int`, return type `()`</span>

<span class='comment'>// For closures, omitting a return type is *not* synonymous with `-&gt; ()`</span>
<span class='kw'>let</span> <span class='ident'>add_3</span>   <span class='op'>=</span> <span class='op'>|</span><span class='ident'>y</span>     <span class='op'>|</span> { <span class='number'>3i</span> <span class='op'>+</span> <span class='ident'>y</span> }; <span class='comment'>// infers `y: int`, return type `int`.</span>

<span class='ident'>fun</span>(<span class='number'>10</span>);            <span class='comment'>// Prints 10</span>
<span class='ident'>closure</span>(<span class='number'>20</span>);        <span class='comment'>// Prints 20</span>
<span class='ident'>closure</span>(<span class='ident'>add_3</span>(<span class='number'>30</span>)); <span class='comment'>// Prints 33</span>

<span class='ident'>fun</span>(<span class='string'>&quot;String&quot;</span>); <span class='comment'>// Error: mismatched types</span>

<span class='comment'>// Error: mismatched types</span>
<span class='comment'>// inference already assigned `closure` the type `|int| -&gt; ()`</span>
<span class='ident'>closure</span>(<span class='string'>&quot;String&quot;</span>);
</pre>

<p>In cases where the compiler needs assistance, the arguments and return
types may be annotated on closures, using the same notation as shown
earlier.  In the example below, since different types provide an
implementation for the operator <code>*</code>, the argument type for the <code>x</code>
parameter must be explicitly provided.</p>
<span id='rust-example-raw-91' class='rusttest'>fn main() {
    // Error: the type of `x` must be known to be used with `x * x`
    let square = |x     | -&gt; uint { (x * x) as uint };
}</span><pre id='rust-example-rendered-91' class='rust '>
<span class='comment'>// Error: the type of `x` must be known to be used with `x * x`</span>
<span class='kw'>let</span> <span class='ident'>square</span> <span class='op'>=</span> <span class='op'>|</span><span class='ident'>x</span>     <span class='op'>|</span> <span class='op'>-&gt;</span> <span class='ident'>uint</span> { (<span class='ident'>x</span> <span class='op'>*</span> <span class='ident'>x</span>) <span class='kw'>as</span> <span class='ident'>uint</span> };
</pre>

<p>In the corrected version, the argument type is explicitly annotated,
while the return type can still be inferred.</p>
<span id='rust-example-raw-92' class='rusttest'>fn main() {
    let square_explicit = |x: int| -&gt; uint { (x * x) as uint };
    let square_infer    = |x: int|         { (x * x) as uint };
    
    println!(&quot;{}&quot;, square_explicit(20));  // 400
    println!(&quot;{}&quot;, square_infer(-20));    // 400
}</span><pre id='rust-example-rendered-92' class='rust '>
<span class='kw'>let</span> <span class='ident'>square_explicit</span> <span class='op'>=</span> <span class='op'>|</span><span class='ident'>x</span>: <span class='ident'>int</span><span class='op'>|</span> <span class='op'>-&gt;</span> <span class='ident'>uint</span> { (<span class='ident'>x</span> <span class='op'>*</span> <span class='ident'>x</span>) <span class='kw'>as</span> <span class='ident'>uint</span> };
<span class='kw'>let</span> <span class='ident'>square_infer</span>    <span class='op'>=</span> <span class='op'>|</span><span class='ident'>x</span>: <span class='ident'>int</span><span class='op'>|</span>         { (<span class='ident'>x</span> <span class='op'>*</span> <span class='ident'>x</span>) <span class='kw'>as</span> <span class='ident'>uint</span> };

<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>square_explicit</span>(<span class='number'>20</span>));  <span class='comment'>// 400</span>
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>square_infer</span>(<span class='op'>-</span><span class='number'>20</span>));    <span class='comment'>// 400</span>
</pre>

<p>There are several forms of closure, each with its own role. The most
common, called a <em>stack closure</em>, has type <code>||</code> and can directly
access local variables in the enclosing scope.</p>
<span id='rust-example-raw-93' class='rusttest'>fn main() {
    let mut max = 0;
    let f = |x: int| if x &gt; max { max = x };
    for x in [1, 2, 3].iter() {
        f(*x);
    }
}</span><pre id='rust-example-rendered-93' class='rust '>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>max</span> <span class='op'>=</span> <span class='number'>0</span>;
<span class='kw'>let</span> <span class='ident'>f</span> <span class='op'>=</span> <span class='op'>|</span><span class='ident'>x</span>: <span class='ident'>int</span><span class='op'>|</span> <span class='kw'>if</span> <span class='ident'>x</span> <span class='op'>&gt;</span> <span class='ident'>max</span> { <span class='ident'>max</span> <span class='op'>=</span> <span class='ident'>x</span> };
<span class='kw'>for</span> <span class='ident'>x</span> <span class='kw'>in</span> [<span class='number'>1</span>, <span class='number'>2</span>, <span class='number'>3</span>].<span class='ident'>iter</span>() {
    <span class='ident'>f</span>(<span class='op'>*</span><span class='ident'>x</span>);
}
</pre>

<p>Stack closures are very efficient because their environment is
allocated on the call stack and refers by pointer to captured
locals. To ensure that stack closures never outlive the local
variables to which they refer, stack closures are not
first-class. That is, they can only be used in argument position; they
cannot be stored in data structures or returned from
functions. Despite these limitations, stack closures are used
pervasively in Rust code.</p>

<h2 id="owned-closures" class='section-header'><a
                           href="#owned-closures">15.1 Owned closures</a></h2>
<p>Owned closures, written <code>proc</code>,
hold on to things that can safely be sent between
processes. They copy the values they close over,
but they also own them: that is, no other code can access
them. Owned closures are used in concurrent code, particularly
for spawning <a href="guide-tasks.html">tasks</a>.</p>

<p>Closures can be used to spawn tasks.
A practical example of this pattern is found when using the <code>spawn</code> function,
which starts a new task.</p>
<span id='rust-example-raw-94' class='rusttest'>fn main() {
    use std::task::spawn;
    
    // proc is the closure which will be spawned.
    spawn(proc() {
        println!(&quot;I&#39;m a new task&quot;)
    });
}</span><pre id='rust-example-rendered-94' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>task</span>::<span class='ident'>spawn</span>;

<span class='comment'>// proc is the closure which will be spawned.</span>
<span class='ident'>spawn</span>(<span class='kw'>proc</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;I&#39;m a new task&quot;</span>)
});
</pre>

<h2 id="closure-compatibility" class='section-header'><a
                           href="#closure-compatibility">15.2 Closure compatibility</a></h2>
<p>Rust closures have a convenient subtyping property: you can pass any kind of
closure (as long as the arguments and return types match) to functions
that expect a <code>||</code>. Thus, when writing a higher-order function that
only calls its function argument, and does nothing else with it, you
should almost always declare the type of that argument as <code>||</code>. That way,
callers may pass any kind of closure.</p>
<span id='rust-example-raw-95' class='rusttest'>fn main() {
    fn call_twice(f: ||) { f(); f(); }
    let closure = || { &quot;I&#39;m a closure, and it doesn&#39;t matter what type I am&quot;; };
    fn function() { &quot;I&#39;m a normal function&quot;; }
    call_twice(closure);
    call_twice(function);
}</span><pre id='rust-example-rendered-95' class='rust '>
<span class='kw'>fn</span> <span class='ident'>call_twice</span>(<span class='ident'>f</span>: <span class='op'>||</span>) { <span class='ident'>f</span>(); <span class='ident'>f</span>(); }
<span class='kw'>let</span> <span class='ident'>closure</span> <span class='op'>=</span> <span class='op'>||</span> { <span class='string'>&quot;I&#39;m a closure, and it doesn&#39;t matter what type I am&quot;</span>; };
<span class='kw'>fn</span> <span class='ident'>function</span>() { <span class='string'>&quot;I&#39;m a normal function&quot;</span>; }
<span class='ident'>call_twice</span>(<span class='ident'>closure</span>);
<span class='ident'>call_twice</span>(<span class='ident'>function</span>);
</pre>

<blockquote>
<p><em>Note:</em> Both the syntax and the semantics will be changing
in small ways. At the moment they can be unsound in some
scenarios, particularly with non-copyable types.</p>
</blockquote>

<h1 id="methods" class='section-header'><a
                           href="#methods">16 Methods</a></h1>
<p>Methods are like functions except that they always begin with a special argument,
called <code>self</code>,
which has the type of the method&#39;s receiver. The
<code>self</code> argument is like <code>this</code> in C++ and many other languages.
Methods are called with dot notation, as in <code>my_vec.len()</code>.</p>

<p><em>Implementations</em>, written with the <code>impl</code> keyword, can define
methods on most Rust types, including structs and enums.
As an example, let&#39;s define a <code>draw</code> method on our <code>Shape</code> enum.</p>
<span id='rust-example-raw-96' class='rusttest'>fn main() {
    fn draw_circle(p: Point, f: f64) { }
    fn draw_rectangle(p: Point, p: Point) { }
    struct Point {
        x: f64,
        y: f64
    }
    
    enum Shape {
        Circle(Point, f64),
        Rectangle(Point, Point)
    }
    
    impl Shape {
        fn draw(&amp;self) {
            match *self {
                Circle(p, f) =&gt; draw_circle(p, f),
                Rectangle(p1, p2) =&gt; draw_rectangle(p1, p2)
            }
        }
    }
    
    let s = Circle(Point { x: 1.0, y: 2.0 }, 3.0);
    s.draw();
}</span><pre id='rust-example-rendered-96' class='rust '>
<span class='kw'>struct</span> <span class='ident'>Point</span> {
    <span class='ident'>x</span>: <span class='ident'>f64</span>,
    <span class='ident'>y</span>: <span class='ident'>f64</span>
}

<span class='kw'>enum</span> <span class='ident'>Shape</span> {
    <span class='ident'>Circle</span>(<span class='ident'>Point</span>, <span class='ident'>f64</span>),
    <span class='ident'>Rectangle</span>(<span class='ident'>Point</span>, <span class='ident'>Point</span>)
}

<span class='kw'>impl</span> <span class='ident'>Shape</span> {
    <span class='kw'>fn</span> <span class='ident'>draw</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) {
        <span class='kw'>match</span> <span class='op'>*</span><span class='self'>self</span> {
            <span class='ident'>Circle</span>(<span class='ident'>p</span>, <span class='ident'>f</span>) <span class='op'>=&gt;</span> <span class='ident'>draw_circle</span>(<span class='ident'>p</span>, <span class='ident'>f</span>),
            <span class='ident'>Rectangle</span>(<span class='ident'>p1</span>, <span class='ident'>p2</span>) <span class='op'>=&gt;</span> <span class='ident'>draw_rectangle</span>(<span class='ident'>p1</span>, <span class='ident'>p2</span>)
        }
    }
}

<span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='ident'>Circle</span>(<span class='ident'>Point</span> { <span class='ident'>x</span>: <span class='number'>1.0</span>, <span class='ident'>y</span>: <span class='number'>2.0</span> }, <span class='number'>3.0</span>);
<span class='ident'>s</span>.<span class='ident'>draw</span>();
</pre>

<p>This defines an <em>implementation</em> for <code>Shape</code> containing a single
method, <code>draw</code>. In most respects the <code>draw</code> method is defined
like any other function, except for the name <code>self</code>.</p>

<p>The type of <code>self</code> is the type on which the method is implemented,
or a pointer thereof. As an argument it is written either <code>self</code>,
<code>&amp;self</code>, or <code>~self</code>.
A caller must in turn have a compatible pointer type to call the method.</p>
<span id='rust-example-raw-97' class='rusttest'>fn main() {
    fn draw_circle(p: Point, f: f64) { }
    fn draw_rectangle(p: Point, p: Point) { }
    struct Point { x: f64, y: f64 }
    enum Shape {
        Circle(Point, f64),
        Rectangle(Point, Point)
    }
    impl Shape {
        fn draw_reference(&amp;self) { /* ... */ }
        fn draw_owned(~self) { /* ... */ }
        fn draw_value(self) { /* ... */ }
    }
    
    let s = Circle(Point { x: 1.0, y: 2.0 }, 3.0);
    
    (&amp;s).draw_reference();
    (box s).draw_owned();
    s.draw_value();
}</span><pre id='rust-example-rendered-97' class='rust '>
<span class='kw'>impl</span> <span class='ident'>Shape</span> {
    <span class='kw'>fn</span> <span class='ident'>draw_reference</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) { <span class='comment'>/* ... */</span> }
    <span class='kw'>fn</span> <span class='ident'>draw_owned</span>(<span class='kw-2'>~</span><span class='self'>self</span>) { <span class='comment'>/* ... */</span> }
    <span class='kw'>fn</span> <span class='ident'>draw_value</span>(<span class='self'>self</span>) { <span class='comment'>/* ... */</span> }
}

<span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='ident'>Circle</span>(<span class='ident'>Point</span> { <span class='ident'>x</span>: <span class='number'>1.0</span>, <span class='ident'>y</span>: <span class='number'>2.0</span> }, <span class='number'>3.0</span>);

(<span class='kw-2'>&amp;</span><span class='ident'>s</span>).<span class='ident'>draw_reference</span>();
(<span class='kw'>box</span> <span class='ident'>s</span>).<span class='ident'>draw_owned</span>();
<span class='ident'>s</span>.<span class='ident'>draw_value</span>();
</pre>

<p>Methods typically take a reference self type,
so the compiler will go to great lengths to convert a callee
to a reference.</p>
<span id='rust-example-raw-98' class='rusttest'>fn main() {
    fn draw_circle(p: Point, f: f64) { }
    fn draw_rectangle(p: Point, p: Point) { }
    struct Point { x: f64, y: f64 }
    enum Shape {
        Circle(Point, f64),
        Rectangle(Point, Point)
    }
    impl Shape {
       fn draw_reference(&amp;self) { /* ... */ }
       fn draw_owned(~self) { /* ... */ }
       fn draw_value(self) { /* ... */ }
    }
    let s = Circle(Point { x: 1.0, y: 2.0 }, 3.0);
    // As with typical function arguments, owned pointers
    // are automatically converted to references
    
    (box s).draw_reference();
    
    // Unlike typical function arguments, the self value will
    // automatically be referenced ...
    s.draw_reference();
    
    // ... and dereferenced
    (&amp; &amp;s).draw_reference();
    
    // ... and dereferenced and borrowed
    (&amp;box s).draw_reference();
}</span><pre id='rust-example-rendered-98' class='rust '>
<span class='comment'>// As with typical function arguments, owned pointers</span>
<span class='comment'>// are automatically converted to references</span>

(<span class='kw'>box</span> <span class='ident'>s</span>).<span class='ident'>draw_reference</span>();

<span class='comment'>// Unlike typical function arguments, the self value will</span>
<span class='comment'>// automatically be referenced ...</span>
<span class='ident'>s</span>.<span class='ident'>draw_reference</span>();

<span class='comment'>// ... and dereferenced</span>
(<span class='kw-2'>&amp;</span> <span class='kw-2'>&amp;</span><span class='ident'>s</span>).<span class='ident'>draw_reference</span>();

<span class='comment'>// ... and dereferenced and borrowed</span>
(<span class='kw-2'>&amp;</span><span class='kw'>box</span> <span class='ident'>s</span>).<span class='ident'>draw_reference</span>();
</pre>

<p>Implementations may also define standalone (sometimes called &quot;static&quot;)
methods. The absence of a <code>self</code> parameter distinguishes such methods.
These methods are the preferred way to define constructor functions.</p>
<span id='rust-example-raw-99' class='rusttest'>fn main() {
    impl Circle {
        fn area(&amp;self) -&gt; f64 { /* ... */ }
        fn new(area: f64) -&gt; Circle { /* ... */ }
    }
}</span><pre id='rust-example-rendered-99' class='rust '>
<span class='kw'>impl</span> <span class='ident'>Circle</span> {
    <span class='kw'>fn</span> <span class='ident'>area</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> { <span class='comment'>/* ... */</span> }
    <span class='kw'>fn</span> <span class='ident'>new</span>(<span class='ident'>area</span>: <span class='ident'>f64</span>) <span class='op'>-&gt;</span> <span class='ident'>Circle</span> { <span class='comment'>/* ... */</span> }
}
</pre>

<p>To call such a method, just prefix it with the type name and a double colon:</p>
<span id='rust-example-raw-100' class='rusttest'>fn main() {
    use std::f64::consts::PI;
    struct Circle { radius: f64 }
    impl Circle {
        fn new(area: f64) -&gt; Circle { Circle { radius: (area / PI).sqrt() } }
    }
    let c = Circle::new(42.5);
}</span><pre id='rust-example-rendered-100' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>f64</span>::<span class='ident'>consts</span>::<span class='ident'>PI</span>;
<span class='kw'>struct</span> <span class='ident'>Circle</span> { <span class='ident'>radius</span>: <span class='ident'>f64</span> }
<span class='kw'>impl</span> <span class='ident'>Circle</span> {
    <span class='kw'>fn</span> <span class='ident'>new</span>(<span class='ident'>area</span>: <span class='ident'>f64</span>) <span class='op'>-&gt;</span> <span class='ident'>Circle</span> { <span class='ident'>Circle</span> { <span class='ident'>radius</span>: (<span class='ident'>area</span> <span class='op'>/</span> <span class='ident'>PI</span>).<span class='ident'>sqrt</span>() } }
}
<span class='kw'>let</span> <span class='ident'>c</span> <span class='op'>=</span> <span class='ident'>Circle</span>::<span class='ident'>new</span>(<span class='number'>42.5</span>);
</pre>

<h1 id="generics" class='section-header'><a
                           href="#generics">17 Generics</a></h1>
<p>Throughout this tutorial, we&#39;ve been defining functions that act only
on specific data types. With type parameters we can also define
functions whose arguments have generic types, and which can be invoked
with a variety of types. Consider a generic <code>map</code> function, which
takes a function <code>function</code> and a vector <code>vector</code> and returns a new
vector consisting of the result of applying <code>function</code> to each element
of <code>vector</code>:</p>
<span id='rust-example-raw-101' class='rusttest'>fn main() {
    fn map&lt;T, U&gt;(vector: &amp;[T], function: |v: &amp;T| -&gt; U) -&gt; Vec&lt;U&gt; {
        let mut accumulator = Vec::new();
        for element in vector.iter() {
            accumulator.push(function(element));
        }
        return accumulator;
    }
}</span><pre id='rust-example-rendered-101' class='rust '>
<span class='kw'>fn</span> <span class='ident'>map</span><span class='op'>&lt;</span><span class='ident'>T</span>, <span class='ident'>U</span><span class='op'>&gt;</span>(<span class='ident'>vector</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>T</span>], <span class='ident'>function</span>: <span class='op'>|</span><span class='ident'>v</span>: <span class='kw-2'>&amp;</span><span class='ident'>T</span><span class='op'>|</span> <span class='op'>-&gt;</span> <span class='ident'>U</span>) <span class='op'>-&gt;</span> <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>U</span><span class='op'>&gt;</span> {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>accumulator</span> <span class='op'>=</span> <span class='ident'>Vec</span>::<span class='ident'>new</span>();
    <span class='kw'>for</span> <span class='ident'>element</span> <span class='kw'>in</span> <span class='ident'>vector</span>.<span class='ident'>iter</span>() {
        <span class='ident'>accumulator</span>.<span class='ident'>push</span>(<span class='ident'>function</span>(<span class='ident'>element</span>));
    }
    <span class='kw'>return</span> <span class='ident'>accumulator</span>;
}
</pre>

<p>When defined with type parameters, as denoted by <code>&lt;T, U&gt;</code>, this
function can be applied to any type of vector, as long as the type of
<code>function</code>&#39;s argument and the type of the vector&#39;s contents agree with
each other.</p>

<p>Inside a generic function, the names of the type parameters
(capitalized by convention) stand for opaque types. All you can do
with instances of these types is pass them around: you can&#39;t apply any
operations to them or pattern-match on them. Note that instances of
generic types are often passed by pointer. For example, the parameter
<code>function()</code> is supplied with a pointer to a value of type <code>T</code> and not
a value of type <code>T</code> itself. This ensures that the function works with
the broadest set of types possible, since some types are expensive or
illegal to copy and pass by value.</p>

<p>Generic <code>type</code>, <code>struct</code>, and <code>enum</code> declarations follow the same pattern:</p>
<span id='rust-example-raw-102' class='rusttest'>type Set&lt;T&gt; = std::collections::HashMap&lt;T, ()&gt;;

struct Stack&lt;T&gt; {
    elements: Vec&lt;T&gt;
}

enum Option&lt;T&gt; {
    Some(T),
    None
}
fn main() {}</span><pre id='rust-example-rendered-102' class='rust '>
<span class='kw'>type</span> <span class='ident'>Set</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>std</span>::<span class='ident'>collections</span>::<span class='ident'>HashMap</span><span class='op'>&lt;</span><span class='ident'>T</span>, ()<span class='op'>&gt;</span>;

<span class='kw'>struct</span> <span class='ident'>Stack</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='ident'>elements</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>
}

<span class='kw'>enum</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='prelude-val'>Some</span>(<span class='ident'>T</span>),
    <span class='prelude-val'>None</span>
}
</pre>

<p>These declarations can be instantiated to valid types like <code>Set&lt;int&gt;</code>,
<code>Stack&lt;int&gt;</code>, and <code>Option&lt;int&gt;</code>.</p>

<p>The last type in that example, <code>Option</code>, appears frequently in Rust code.
Because Rust does not have null pointers (except in unsafe code), we need
another way to write a function whose result isn&#39;t defined on every possible
combination of arguments of the appropriate types. The usual way is to write
a function that returns <code>Option&lt;T&gt;</code> instead of <code>T</code>.</p>
<span id='rust-example-raw-103' class='rusttest'>fn main() {
    struct Point { x: f64, y: f64 }
    enum Shape { Circle(Point, f64), Rectangle(Point, Point) }
    fn radius(shape: Shape) -&gt; Option&lt;f64&gt; {
        match shape {
            Circle(_, radius) =&gt; Some(radius),
            Rectangle(..)     =&gt; None
        }
    }
}</span><pre id='rust-example-rendered-103' class='rust '>
<span class='kw'>fn</span> <span class='ident'>radius</span>(<span class='ident'>shape</span>: <span class='ident'>Shape</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>f64</span><span class='op'>&gt;</span> {
    <span class='kw'>match</span> <span class='ident'>shape</span> {
        <span class='ident'>Circle</span>(_, <span class='ident'>radius</span>) <span class='op'>=&gt;</span> <span class='prelude-val'>Some</span>(<span class='ident'>radius</span>),
        <span class='ident'>Rectangle</span>(..)     <span class='op'>=&gt;</span> <span class='prelude-val'>None</span>
    }
}
</pre>

<p>The Rust compiler compiles generic functions very efficiently by
<em>monomorphizing</em> them. <em>Monomorphization</em> is a fancy name for a simple
idea: generate a separate copy of each generic function at each call site,
a copy that is specialized to the argument
types and can thus be optimized specifically for them. In this
respect, Rust&#39;s generics have similar performance characteristics to
C++ templates.</p>

<h2 id="traits" class='section-header'><a
                           href="#traits">17.1 Traits</a></h2>
<p>Within a generic functionthat is, a function parameterized by a
type parameter, say, <code>T</code>the operations we can do on arguments of
type <code>T</code> are quite limited.  After all, since we don&#39;t know what type
<code>T</code> will be instantiated with, we can&#39;t safely modify or query values
of type <code>T</code>.  This is where <em>traits</em> come into play. Traits are Rust&#39;s
most powerful tool for writing polymorphic code. Java developers will
see them as similar to Java interfaces, and Haskellers will notice
their similarities to type classes. Rust&#39;s traits give us a way to
express <em>bounded polymorphism</em>: by limiting the set of possible types
that a type parameter could refer to, they expand the number of
operations we can safely perform on arguments of that type.</p>

<p>As motivation, let us consider copying of values in Rust.  The <code>clone</code>
method is not defined for values of every type.  One reason is
user-defined destructors: copying a value of a type that has a
destructor could result in the destructor running multiple times.
Therefore, values of types that have destructors cannot be copied
unless we explicitly implement <code>clone</code> for them.</p>

<p>This complicates handling of generic functions.
If we have a function with a type parameter <code>T</code>,
can we copy values of type <code>T</code> inside that function?
In Rust, we can&#39;t,
and if we try to run the following code the compiler will complain.</p>
<span id='rust-example-raw-104' class='rusttest'>fn main() {
    // This does not compile
    fn head_bad&lt;T&gt;(v: &amp;[T]) -&gt; T {
        v[0] // error: copying a non-copyable value
    }
}</span><pre id='rust-example-rendered-104' class='rust '>
<span class='comment'>// This does not compile</span>
<span class='kw'>fn</span> <span class='ident'>head_bad</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>(<span class='ident'>v</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>T</span>]) <span class='op'>-&gt;</span> <span class='ident'>T</span> {
    <span class='ident'>v</span>[<span class='number'>0</span>] <span class='comment'>// error: copying a non-copyable value</span>
}
</pre>

<p>However, we can tell the compiler
that the <code>head</code> function is only for copyable types.
In Rust, copyable types are those that <em>implement the <code>Clone</code> trait</em>.
We can then explicitly create a second copy of the value we are returning
by calling the <code>clone</code> method:</p>
<span id='rust-example-raw-105' class='rusttest'>fn main() {
    // This does
    fn head&lt;T: Clone&gt;(v: &amp;[T]) -&gt; T {
        v[0].clone()
    }
}</span><pre id='rust-example-rendered-105' class='rust '>
<span class='comment'>// This does</span>
<span class='kw'>fn</span> <span class='ident'>head</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>Clone</span><span class='op'>&gt;</span>(<span class='ident'>v</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>T</span>]) <span class='op'>-&gt;</span> <span class='ident'>T</span> {
    <span class='ident'>v</span>[<span class='number'>0</span>].<span class='ident'>clone</span>()
}
</pre>

<p>The bounded type parameter <code>T: Clone</code> says that <code>head</code>
can be called on an argument of type <code>&amp;[T]</code> for any <code>T</code>,
so long as there is an implementation of the
<code>Clone</code> trait for <code>T</code>.
When instantiating a generic function,
we can only instantiate it with types
that implement the correct trait,
so we could not apply <code>head</code> to a vector whose elements are of some type
that does not implement <code>Clone</code>.</p>

<p>While most traits can be defined and implemented by user code,
three traits are automatically derived and implemented
for all applicable types by the compiler,
and may not be overridden:</p>

<ul>
<li><p><code>Send</code> - Sendable types.
Types are sendable
unless they contain references.</p></li>
<li><p><code>Share</code> - Types that are <em>threadsafe</em>
These are types that are safe to be used across several threads with access to
a <code>&amp;T</code> pointer. <code>Mutex&lt;T&gt;</code> is an example of a <em>sharable</em> type with internal mutable data.</p></li>
<li><p><code>&#39;static</code> - Non-borrowed types.
These are types that do not contain any data whose lifetime is bound to
a particular stack frame. These are types that do not contain any
references, or types where the only contained references
have the <code>&#39;static</code> lifetime. (For more on named lifetimes and their uses,
see the <a href="guide-lifetimes.html">references and lifetimes guide</a>.)</p></li>
</ul>

<blockquote>
<p><em>Note:</em> These built-in traits were referred to as &#39;kinds&#39; in earlier
iterations of the language, and often still are.</p>
</blockquote>

<p>Additionally, the <code>Drop</code> trait is used to define destructors. This
trait provides one method called <code>drop</code>, which is automatically
called when a value of the type that implements this trait is
destroyed, either because the value went out of scope or because the
garbage collector reclaimed it.</p>
<span id='rust-example-raw-106' class='rusttest'>fn main() {
    struct TimeBomb {
        explosivity: uint
    }
    
    impl Drop for TimeBomb {
        fn drop(&amp;mut self) {
            for _ in range(0, self.explosivity) {
                println!(&quot;blam!&quot;);
            }
        }
    }
}</span><pre id='rust-example-rendered-106' class='rust '>
<span class='kw'>struct</span> <span class='ident'>TimeBomb</span> {
    <span class='ident'>explosivity</span>: <span class='ident'>uint</span>
}

<span class='kw'>impl</span> <span class='ident'>Drop</span> <span class='kw'>for</span> <span class='ident'>TimeBomb</span> {
    <span class='kw'>fn</span> <span class='ident'>drop</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) {
        <span class='kw'>for</span> _ <span class='kw'>in</span> <span class='ident'>range</span>(<span class='number'>0</span>, <span class='self'>self</span>.<span class='ident'>explosivity</span>) {
            <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;blam!&quot;</span>);
        }
    }
}
</pre>

<p>It is illegal to call <code>drop</code> directly. Only code inserted by the compiler
may call it.</p>

<h2 id="declaring-and-implementing-traits" class='section-header'><a
                           href="#declaring-and-implementing-traits">17.2 Declaring and implementing traits</a></h2>
<p>At its simplest, a trait is a set of zero or more <em>method signatures</em>.
For example, we could declare the trait
<code>Printable</code> for things that can be printed to the console,
with a single method signature:</p>
<span id='rust-example-raw-107' class='rusttest'>fn main() {
    trait Printable {
        fn print(&amp;self);
    }
}</span><pre id='rust-example-rendered-107' class='rust '>
<span class='kw'>trait</span> <span class='ident'>Printable</span> {
    <span class='kw'>fn</span> <span class='ident'>print</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>);
}
</pre>

<p>We say that the <code>Printable</code> trait <em>provides</em> a <code>print</code> method with the
given signature.  This means that we can call <code>print</code> on an argument
of any type that implements the <code>Printable</code> trait.</p>

<p>Rust&#39;s built-in <code>Send</code> and <code>Share</code> types are examples of traits that
don&#39;t provide any methods.</p>

<p>Traits may be implemented for specific types with <a href="#methods">impls</a>. An impl for
a particular trait gives an implementation of the methods that
trait provides.  For instance, the following impls of
<code>Printable</code> for <code>int</code> and <code>String</code> give implementations of the <code>print</code>
method.</p>
<span id='rust-example-raw-108' class='rusttest'>fn main() {
    trait Printable { fn print(&amp;self); }
    impl Printable for int {
        fn print(&amp;self) { println!(&quot;{}&quot;, *self) }
    }
    
    impl Printable for String {
        fn print(&amp;self) { println!(&quot;{}&quot;, *self) }
    }
    
    1.print();
    (&quot;foo&quot;.to_string()).print();
}</span><pre id='rust-example-rendered-108' class='rust '>
<span class='kw'>impl</span> <span class='ident'>Printable</span> <span class='kw'>for</span> <span class='ident'>int</span> {
    <span class='kw'>fn</span> <span class='ident'>print</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) { <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='op'>*</span><span class='self'>self</span>) }
}

<span class='kw'>impl</span> <span class='ident'>Printable</span> <span class='kw'>for</span> <span class='ident'>String</span> {
    <span class='kw'>fn</span> <span class='ident'>print</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) { <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='op'>*</span><span class='self'>self</span>) }
}
</pre>

<p>Methods defined in an impl for a trait may be called just like
any other method, using dot notation, as in <code>1.print()</code>.</p>

<h2 id="default-method-implementations-in-trait-definitions" class='section-header'><a
                           href="#default-method-implementations-in-trait-definitions">17.3 Default method implementations in trait definitions</a></h2>
<p>Sometimes, a method that a trait provides will have the same
implementation for most or all of the types that implement that trait.
For instance, suppose that we wanted <code>bool</code>s and <code>f32</code>s to be
printable, and that we wanted the implementation of <code>print</code> for those
types to be exactly as it is for <code>int</code>, above:</p>
<span id='rust-example-raw-109' class='rusttest'>fn main() {
    trait Printable { fn print(&amp;self); }
    impl Printable for f32 {
        fn print(&amp;self) { println!(&quot;{}&quot;, *self) }
    }
    
    impl Printable for bool {
        fn print(&amp;self) { println!(&quot;{}&quot;, *self) }
    }
    
    true.print();
    3.14159.print();
}</span><pre id='rust-example-rendered-109' class='rust '>
<span class='kw'>impl</span> <span class='ident'>Printable</span> <span class='kw'>for</span> <span class='ident'>f32</span> {
    <span class='kw'>fn</span> <span class='ident'>print</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) { <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='op'>*</span><span class='self'>self</span>) }
}

<span class='kw'>impl</span> <span class='ident'>Printable</span> <span class='kw'>for</span> <span class='ident'>bool</span> {
    <span class='kw'>fn</span> <span class='ident'>print</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) { <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='op'>*</span><span class='self'>self</span>) }
}
</pre>

<p>This works fine, but we&#39;ve now repeated the same definition of <code>print</code>
in three places.  Instead of doing that, we can simply include the
definition of <code>print</code> right in the trait definition, instead of just
giving its signature.  That is, we can write the following:</p>
<span id='rust-example-raw-110' class='rusttest'>extern crate debug;

fn main() {
trait Printable {
    // Default method implementation
    fn print(&amp;self) { println!(&quot;{:?}&quot;, *self) }
}

impl Printable for int {}

impl Printable for String {
    fn print(&amp;self) { println!(&quot;{}&quot;, *self) }
}

impl Printable for bool {}

impl Printable for f32 {}

1.print();
(&quot;foo&quot;.to_string()).print();
true.print();
3.14159.print();
}</span><pre id='rust-example-rendered-110' class='rust '>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>debug</span>;

<span class='kw'>trait</span> <span class='ident'>Printable</span> {
    <span class='comment'>// Default method implementation</span>
    <span class='kw'>fn</span> <span class='ident'>print</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) { <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{:?}&quot;</span>, <span class='op'>*</span><span class='self'>self</span>) }
}

<span class='kw'>impl</span> <span class='ident'>Printable</span> <span class='kw'>for</span> <span class='ident'>int</span> {}

<span class='kw'>impl</span> <span class='ident'>Printable</span> <span class='kw'>for</span> <span class='ident'>String</span> {
    <span class='kw'>fn</span> <span class='ident'>print</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) { <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='op'>*</span><span class='self'>self</span>) }
}

<span class='kw'>impl</span> <span class='ident'>Printable</span> <span class='kw'>for</span> <span class='ident'>bool</span> {}

<span class='kw'>impl</span> <span class='ident'>Printable</span> <span class='kw'>for</span> <span class='ident'>f32</span> {}
</pre>

<p>Here, the impls of <code>Printable</code> for <code>int</code>, <code>bool</code>, and <code>f32</code> don&#39;t
need to provide an implementation of <code>print</code>, because in the absence
of a specific implementation, Rust just uses the <em>default method</em>
provided in the trait definition.  Depending on the trait, default
methods can save a great deal of boilerplate code from having to be
written in impls.  Of course, individual impls can still override the
default method for <code>print</code>, as is being done above in the impl for
<code>String</code>.</p>

<h2 id="type-parameterized-traits" class='section-header'><a
                           href="#type-parameterized-traits">17.4 Type-parameterized traits</a></h2>
<p>Traits may be parameterized by type variables.  For example, a trait
for generalized sequence types might look like the following:</p>
<span id='rust-example-raw-111' class='rusttest'>fn main() {
    trait Seq&lt;T&gt; {
        fn length(&amp;self) -&gt; uint;
    }
    
    impl&lt;T&gt; Seq&lt;T&gt; for Vec&lt;T&gt; {
        fn length(&amp;self) -&gt; uint { self.len() }
    }
}</span><pre id='rust-example-rendered-111' class='rust '>
<span class='kw'>trait</span> <span class='ident'>Seq</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>fn</span> <span class='ident'>length</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>uint</span>;
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>Seq</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='kw'>for</span> <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>fn</span> <span class='ident'>length</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>uint</span> { <span class='self'>self</span>.<span class='ident'>len</span>() }
}
</pre>

<p>The implementation has to explicitly declare the type parameter that
it binds, <code>T</code>, before using it to specify its trait type. Rust
requires this declaration because the <code>impl</code> could also, for example,
specify an implementation of <code>Seq&lt;int&gt;</code>. The trait type (appearing
between <code>impl</code> and <code>for</code>) <em>refers</em> to a type, rather than
defining one.</p>

<p>The type parameters bound by a trait are in scope in each of the
method declarations. So, re-declaring the type parameter
<code>T</code> as an explicit type parameter for <code>length</code>, in either the trait or
the impl, would be a compile-time error.</p>

<p>Within a trait definition, <code>Self</code> is a special type that you can think
of as a type parameter. An implementation of the trait for any given
type <code>T</code> replaces the <code>Self</code> type parameter with <code>T</code>. The following
trait describes types that support an equality operation:</p>
<span id='rust-example-raw-112' class='rusttest'>fn main() {
    // In a trait, `self` refers to the self argument.
    // `Self` refers to the type implementing the trait.
    trait PartialEq {
        fn equals(&amp;self, other: &amp;Self) -&gt; bool;
    }
    
    // In an impl, `self` refers just to the value of the receiver
    impl PartialEq for int {
        fn equals(&amp;self, other: &amp;int) -&gt; bool { *other == *self }
    }
}</span><pre id='rust-example-rendered-112' class='rust '>
<span class='comment'>// In a trait, `self` refers to the self argument.</span>
<span class='comment'>// `Self` refers to the type implementing the trait.</span>
<span class='kw'>trait</span> <span class='ident'>PartialEq</span> {
    <span class='kw'>fn</span> <span class='ident'>equals</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>other</span>: <span class='kw-2'>&amp;</span><span class='ident'>Self</span>) <span class='op'>-&gt;</span> <span class='ident'>bool</span>;
}

<span class='comment'>// In an impl, `self` refers just to the value of the receiver</span>
<span class='kw'>impl</span> <span class='ident'>PartialEq</span> <span class='kw'>for</span> <span class='ident'>int</span> {
    <span class='kw'>fn</span> <span class='ident'>equals</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>other</span>: <span class='kw-2'>&amp;</span><span class='ident'>int</span>) <span class='op'>-&gt;</span> <span class='ident'>bool</span> { <span class='op'>*</span><span class='ident'>other</span> <span class='op'>==</span> <span class='op'>*</span><span class='self'>self</span> }
}
</pre>

<p>Notice that in the trait definition, <code>equals</code> takes a
second parameter of type <code>Self</code>.
In contrast, in the <code>impl</code>, <code>equals</code> takes a second parameter of
type <code>int</code>, only using <code>self</code> as the name of the receiver.</p>

<p>Just as in type implementations, traits can define standalone (static)
methods.  These methods are called by prefixing the method name with the trait
name and a double colon.  The compiler uses type inference to decide which
implementation to use.</p>
<span id='rust-example-raw-113' class='rusttest'>fn main() {
    use std::f64::consts::PI;
    trait Shape { fn new(area: f64) -&gt; Self; }
    struct Circle { radius: f64 }
    struct Square { length: f64 }
    
    impl Shape for Circle {
        fn new(area: f64) -&gt; Circle { Circle { radius: (area / PI).sqrt() } }
    }
    impl Shape for Square {
        fn new(area: f64) -&gt; Square { Square { length: area.sqrt() } }
    }
    
    let area = 42.5;
    let c: Circle = Shape::new(area);
    let s: Square = Shape::new(area);
}</span><pre id='rust-example-rendered-113' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>f64</span>::<span class='ident'>consts</span>::<span class='ident'>PI</span>;
<span class='kw'>trait</span> <span class='ident'>Shape</span> { <span class='kw'>fn</span> <span class='ident'>new</span>(<span class='ident'>area</span>: <span class='ident'>f64</span>) <span class='op'>-&gt;</span> <span class='ident'>Self</span>; }
<span class='kw'>struct</span> <span class='ident'>Circle</span> { <span class='ident'>radius</span>: <span class='ident'>f64</span> }
<span class='kw'>struct</span> <span class='ident'>Square</span> { <span class='ident'>length</span>: <span class='ident'>f64</span> }

<span class='kw'>impl</span> <span class='ident'>Shape</span> <span class='kw'>for</span> <span class='ident'>Circle</span> {
    <span class='kw'>fn</span> <span class='ident'>new</span>(<span class='ident'>area</span>: <span class='ident'>f64</span>) <span class='op'>-&gt;</span> <span class='ident'>Circle</span> { <span class='ident'>Circle</span> { <span class='ident'>radius</span>: (<span class='ident'>area</span> <span class='op'>/</span> <span class='ident'>PI</span>).<span class='ident'>sqrt</span>() } }
}
<span class='kw'>impl</span> <span class='ident'>Shape</span> <span class='kw'>for</span> <span class='ident'>Square</span> {
    <span class='kw'>fn</span> <span class='ident'>new</span>(<span class='ident'>area</span>: <span class='ident'>f64</span>) <span class='op'>-&gt;</span> <span class='ident'>Square</span> { <span class='ident'>Square</span> { <span class='ident'>length</span>: <span class='ident'>area</span>.<span class='ident'>sqrt</span>() } }
}

<span class='kw'>let</span> <span class='ident'>area</span> <span class='op'>=</span> <span class='number'>42.5</span>;
<span class='kw'>let</span> <span class='ident'>c</span>: <span class='ident'>Circle</span> <span class='op'>=</span> <span class='ident'>Shape</span>::<span class='ident'>new</span>(<span class='ident'>area</span>);
<span class='kw'>let</span> <span class='ident'>s</span>: <span class='ident'>Square</span> <span class='op'>=</span> <span class='ident'>Shape</span>::<span class='ident'>new</span>(<span class='ident'>area</span>);
</pre>

<h2 id="bounded-type-parameters-and-static-method-dispatch" class='section-header'><a
                           href="#bounded-type-parameters-and-static-method-dispatch">17.5 Bounded type parameters and static method dispatch</a></h2>
<p>Traits give us a language for defining predicates on types, or
abstract properties that types can have. We can use this language to
define <em>bounds</em> on type parameters, so that we can then operate on
generic types.</p>
<span id='rust-example-raw-114' class='rusttest'>fn main() {
    trait Printable { fn print(&amp;self); }
    fn print_all&lt;T: Printable&gt;(printable_things: Vec&lt;T&gt;) {
        for thing in printable_things.iter() {
            thing.print();
        }
    }
}</span><pre id='rust-example-rendered-114' class='rust '>
<span class='kw'>fn</span> <span class='ident'>print_all</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>Printable</span><span class='op'>&gt;</span>(<span class='ident'>printable_things</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>) {
    <span class='kw'>for</span> <span class='ident'>thing</span> <span class='kw'>in</span> <span class='ident'>printable_things</span>.<span class='ident'>iter</span>() {
        <span class='ident'>thing</span>.<span class='ident'>print</span>();
    }
}
</pre>

<p>Declaring <code>T</code> as conforming to the <code>Printable</code> trait (as we earlier
did with <code>Clone</code>) makes it possible to call methods from that trait
on values of type <code>T</code> inside the function. It will also cause a
compile-time error when anyone tries to call <code>print_all</code> on a vector
whose element type does not have a <code>Printable</code> implementation.</p>

<p>Type parameters can have multiple bounds by separating them with <code>+</code>,
as in this version of <code>print_all</code> that copies elements.</p>
<span id='rust-example-raw-115' class='rusttest'>fn main() {
    trait Printable { fn print(&amp;self); }
    fn print_all&lt;T: Printable + Clone&gt;(printable_things: Vec&lt;T&gt;) {
        let mut i = 0;
        while i &lt; printable_things.len() {
            let copy_of_thing = printable_things.get(i).clone();
            copy_of_thing.print();
            i += 1;
        }
    }
}</span><pre id='rust-example-rendered-115' class='rust '>
<span class='kw'>fn</span> <span class='ident'>print_all</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>Printable</span> <span class='op'>+</span> <span class='ident'>Clone</span><span class='op'>&gt;</span>(<span class='ident'>printable_things</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>) {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>i</span> <span class='op'>=</span> <span class='number'>0</span>;
    <span class='kw'>while</span> <span class='ident'>i</span> <span class='op'>&lt;</span> <span class='ident'>printable_things</span>.<span class='ident'>len</span>() {
        <span class='kw'>let</span> <span class='ident'>copy_of_thing</span> <span class='op'>=</span> <span class='ident'>printable_things</span>.<span class='ident'>get</span>(<span class='ident'>i</span>).<span class='ident'>clone</span>();
        <span class='ident'>copy_of_thing</span>.<span class='ident'>print</span>();
        <span class='ident'>i</span> <span class='op'>+=</span> <span class='number'>1</span>;
    }
}
</pre>

<p>Method calls to bounded type parameters are <em>statically dispatched</em>,
imposing no more overhead than normal function invocation, so are
the preferred way to use traits polymorphically.</p>

<p>This usage of traits is similar to Haskell type classes.</p>

<h2 id="trait-objects-and-dynamic-method-dispatch" class='section-header'><a
                           href="#trait-objects-and-dynamic-method-dispatch">17.6 Trait objects and dynamic method dispatch</a></h2>
<p>The above allows us to define functions that polymorphically act on
values of a single unknown type that conforms to a given trait.
However, consider this function:</p>
<span id='rust-example-raw-116' class='rusttest'>fn main() {
    type Circle = int; type Rectangle = int;
    impl Drawable for int { fn draw(&amp;self) {} }
    fn new_circle() -&gt; int { 1 }
    trait Drawable { fn draw(&amp;self); }
    
    fn draw_all&lt;T: Drawable&gt;(shapes: Vec&lt;T&gt;) {
        for shape in shapes.iter() { shape.draw(); }
    }
    let c: Circle = new_circle();
    draw_all(vec![c]);
}</span><pre id='rust-example-rendered-116' class='rust '>
<span class='kw'>trait</span> <span class='ident'>Drawable</span> { <span class='kw'>fn</span> <span class='ident'>draw</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>); }

<span class='kw'>fn</span> <span class='ident'>draw_all</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>Drawable</span><span class='op'>&gt;</span>(<span class='ident'>shapes</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>) {
    <span class='kw'>for</span> <span class='ident'>shape</span> <span class='kw'>in</span> <span class='ident'>shapes</span>.<span class='ident'>iter</span>() { <span class='ident'>shape</span>.<span class='ident'>draw</span>(); }
}
</pre>

<p>You can call that on a vector of circles, or a vector of rectangles
(assuming those have suitable <code>Drawable</code> traits defined), but not on
a vector containing both circles and rectangles. When such behavior is
needed, a trait name can alternately be used as a type, called
an <em>object</em>.</p>
<span id='rust-example-raw-117' class='rusttest'>fn main() {
    trait Drawable { fn draw(&amp;self); }
    fn draw_all(shapes: &amp;[Box&lt;Drawable&gt;]) {
        for shape in shapes.iter() { shape.draw(); }
    }
}</span><pre id='rust-example-rendered-117' class='rust '>
<span class='kw'>fn</span> <span class='ident'>draw_all</span>(<span class='ident'>shapes</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>Drawable</span><span class='op'>&gt;</span>]) {
    <span class='kw'>for</span> <span class='ident'>shape</span> <span class='kw'>in</span> <span class='ident'>shapes</span>.<span class='ident'>iter</span>() { <span class='ident'>shape</span>.<span class='ident'>draw</span>(); }
}
</pre>

<p>In this example, there is no type parameter. Instead, the <code>Box&lt;Drawable&gt;</code>
type denotes any owned box value that implements the <code>Drawable</code> trait.
To construct such a value, you use the <code>as</code> operator to cast a value
to an object:</p>
<span id='rust-example-raw-118' class='rusttest'>fn main() {
    type Circle = int; type Rectangle = bool;
    trait Drawable { fn draw(&amp;self); }
    fn new_circle() -&gt; Circle { 1 }
    fn new_rectangle() -&gt; Rectangle { true }
    fn draw_all(shapes: &amp;[Box&lt;Drawable&gt;]) {}
    
    impl Drawable for Circle { fn draw(&amp;self) { /* ... */ } }
    impl Drawable for Rectangle { fn draw(&amp;self) { /* ... */ } }
    
    let c: Box&lt;Circle&gt; = box new_circle();
    let r: Box&lt;Rectangle&gt; = box new_rectangle();
    draw_all([c as Box&lt;Drawable&gt;, r as Box&lt;Drawable&gt;]);
}</span><pre id='rust-example-rendered-118' class='rust '>

<span class='kw'>impl</span> <span class='ident'>Drawable</span> <span class='kw'>for</span> <span class='ident'>Circle</span> { <span class='kw'>fn</span> <span class='ident'>draw</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) { <span class='comment'>/* ... */</span> } }
<span class='kw'>impl</span> <span class='ident'>Drawable</span> <span class='kw'>for</span> <span class='ident'>Rectangle</span> { <span class='kw'>fn</span> <span class='ident'>draw</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) { <span class='comment'>/* ... */</span> } }

<span class='kw'>let</span> <span class='ident'>c</span>: <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>Circle</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='kw'>box</span> <span class='ident'>new_circle</span>();
<span class='kw'>let</span> <span class='ident'>r</span>: <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>Rectangle</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='kw'>box</span> <span class='ident'>new_rectangle</span>();
<span class='ident'>draw_all</span>([<span class='ident'>c</span> <span class='kw'>as</span> <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>Drawable</span><span class='op'>&gt;</span>, <span class='ident'>r</span> <span class='kw'>as</span> <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>Drawable</span><span class='op'>&gt;</span>]);
</pre>

<p>We omit the code for <code>new_circle</code> and <code>new_rectangle</code>; imagine that
these just return <code>Circle</code>s and <code>Rectangle</code>s with a default size. Note
that, like strings and vectors, objects have dynamic size and may
only be referred to via one of the pointer types.
Other pointer types work as well.
Casts to traits may only be done with compatible pointers so,
for example, an <code>&amp;Circle</code> may not be cast to a <code>Box&lt;Drawable&gt;</code>.</p>
<span id='rust-example-raw-119' class='rusttest'>fn main() {
    type Circle = int; type Rectangle = int;
    trait Drawable { fn draw(&amp;self); }
    impl Drawable for int { fn draw(&amp;self) {} }
    fn new_circle() -&gt; int { 1 }
    fn new_rectangle() -&gt; int { 2 }
    // An owned object
    let owny: Box&lt;Drawable&gt; = box new_circle() as Box&lt;Drawable&gt;;
    // A borrowed object
    let stacky: &amp;Drawable = &amp;new_circle() as &amp;Drawable;
}</span><pre id='rust-example-rendered-119' class='rust '>
<span class='comment'>// An owned object</span>
<span class='kw'>let</span> <span class='ident'>owny</span>: <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>Drawable</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='kw'>box</span> <span class='ident'>new_circle</span>() <span class='kw'>as</span> <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>Drawable</span><span class='op'>&gt;</span>;
<span class='comment'>// A borrowed object</span>
<span class='kw'>let</span> <span class='ident'>stacky</span>: <span class='kw-2'>&amp;</span><span class='ident'>Drawable</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span><span class='ident'>new_circle</span>() <span class='kw'>as</span> <span class='kw-2'>&amp;</span><span class='ident'>Drawable</span>;
</pre>

<p>Method calls to trait types are <em>dynamically dispatched</em>. Since the
compiler doesn&#39;t know specifically which functions to call at compile
time, it uses a lookup table (also known as a vtable or dictionary) to
select the method to call at runtime.</p>

<p>This usage of traits is similar to Java interfaces.</p>

<p>There are some built-in bounds, such as <code>Send</code> and <code>Share</code>, which are properties
of the components of types. By design, trait objects don&#39;t know the exact type
of their contents and so the compiler cannot reason about those properties.</p>

<p>You can instruct the compiler, however, that the contents of a trait object must
ascribe to a particular bound with a trailing colon (<code>:</code>). These are examples of
valid types:</p>
<span id='rust-example-raw-120' class='rusttest'>fn main() {
    trait Foo {}
    trait Bar&lt;T&gt; {}
    
    fn sendable_foo(f: Box&lt;Foo + Send&gt;) { /* ... */ }
    fn shareable_bar&lt;T: Share&gt;(b: &amp;Bar&lt;T&gt; + Share) { /* ... */ }
}</span><pre id='rust-example-rendered-120' class='rust '>
<span class='kw'>trait</span> <span class='ident'>Foo</span> {}
<span class='kw'>trait</span> <span class='ident'>Bar</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {}

<span class='kw'>fn</span> <span class='ident'>sendable_foo</span>(<span class='ident'>f</span>: <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>Foo</span> <span class='op'>+</span> <span class='ident'>Send</span><span class='op'>&gt;</span>) { <span class='comment'>/* ... */</span> }
<span class='kw'>fn</span> <span class='ident'>shareable_bar</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>Share</span><span class='op'>&gt;</span>(<span class='ident'>b</span>: <span class='kw-2'>&amp;</span><span class='ident'>Bar</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='op'>+</span> <span class='ident'>Share</span>) { <span class='comment'>/* ... */</span> }
</pre>

<p>When no colon is specified (such as the type <code>Box&lt;Foo&gt;</code>), it is inferred that the
value ascribes to no bounds. They must be added manually if any bounds are
necessary for usage.</p>

<p>Builtin kind bounds can also be specified on closure types in the same way (for
example, by writing <code>fn:Send()</code>), and the default behaviours are the same as
for traits of the same storage class.</p>

<h2 id="trait-inheritance" class='section-header'><a
                           href="#trait-inheritance">17.7 Trait inheritance</a></h2>
<p>We can write a trait declaration that <em>inherits</em> from other traits, called <em>supertraits</em>.
Types that implement a trait must also implement its supertraits.
For example,
we can define a <code>Circle</code> trait that inherits from <code>Shape</code>.</p>
<span id='rust-example-raw-121' class='rusttest'>fn main() {
    trait Shape { fn area(&amp;self) -&gt; f64; }
    trait Circle : Shape { fn radius(&amp;self) -&gt; f64; }
}</span><pre id='rust-example-rendered-121' class='rust '>
<span class='kw'>trait</span> <span class='ident'>Shape</span> { <span class='kw'>fn</span> <span class='ident'>area</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span>; }
<span class='kw'>trait</span> <span class='ident'>Circle</span> : <span class='ident'>Shape</span> { <span class='kw'>fn</span> <span class='ident'>radius</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span>; }
</pre>

<p>Now, we can implement <code>Circle</code> on a type only if we also implement <code>Shape</code>.</p>
<span id='rust-example-raw-122' class='rusttest'>fn main() {
    use std::f64::consts::PI;
    trait Shape { fn area(&amp;self) -&gt; f64; }
    trait Circle : Shape { fn radius(&amp;self) -&gt; f64; }
    struct Point { x: f64, y: f64 }
    fn square(x: f64) -&gt; f64 { x * x }
    struct CircleStruct { center: Point, radius: f64 }
    impl Circle for CircleStruct {
        fn radius(&amp;self) -&gt; f64 { (self.area() / PI).sqrt() }
    }
    impl Shape for CircleStruct {
        fn area(&amp;self) -&gt; f64 { PI * square(self.radius) }
    }
}</span><pre id='rust-example-rendered-122' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>f64</span>::<span class='ident'>consts</span>::<span class='ident'>PI</span>;
<span class='kw'>struct</span> <span class='ident'>CircleStruct</span> { <span class='ident'>center</span>: <span class='ident'>Point</span>, <span class='ident'>radius</span>: <span class='ident'>f64</span> }
<span class='kw'>impl</span> <span class='ident'>Circle</span> <span class='kw'>for</span> <span class='ident'>CircleStruct</span> {
    <span class='kw'>fn</span> <span class='ident'>radius</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> { (<span class='self'>self</span>.<span class='ident'>area</span>() <span class='op'>/</span> <span class='ident'>PI</span>).<span class='ident'>sqrt</span>() }
}
<span class='kw'>impl</span> <span class='ident'>Shape</span> <span class='kw'>for</span> <span class='ident'>CircleStruct</span> {
    <span class='kw'>fn</span> <span class='ident'>area</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> { <span class='ident'>PI</span> <span class='op'>*</span> <span class='ident'>square</span>(<span class='self'>self</span>.<span class='ident'>radius</span>) }
}
</pre>

<p>Notice that methods of <code>Circle</code> can call methods on <code>Shape</code>, as our
<code>radius</code> implementation calls the <code>area</code> method.
This is a silly way to compute the radius of a circle
(since we could just return the <code>radius</code> field), but you get the idea.</p>

<p>In type-parameterized functions,
methods of the supertrait may be called on values of subtrait-bound type parameters.
Referring to the previous example of <code>trait Circle : Shape</code>:</p>
<span id='rust-example-raw-123' class='rusttest'>fn main() {
    trait Shape { fn area(&amp;self) -&gt; f64; }
    trait Circle : Shape { fn radius(&amp;self) -&gt; f64; }
    fn radius_times_area&lt;T: Circle&gt;(c: T) -&gt; f64 {
        // `c` is both a Circle and a Shape
        c.radius() * c.area()
    }
}</span><pre id='rust-example-rendered-123' class='rust '>
<span class='kw'>fn</span> <span class='ident'>radius_times_area</span><span class='op'>&lt;</span><span class='ident'>T</span>: <span class='ident'>Circle</span><span class='op'>&gt;</span>(<span class='ident'>c</span>: <span class='ident'>T</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
    <span class='comment'>// `c` is both a Circle and a Shape</span>
    <span class='ident'>c</span>.<span class='ident'>radius</span>() <span class='op'>*</span> <span class='ident'>c</span>.<span class='ident'>area</span>()
}
</pre>

<p>Likewise, supertrait methods may also be called on trait objects.</p>
<span id='rust-example-raw-124' class='rusttest'>fn main() {
    use std::f64::consts::PI;
    trait Shape { fn area(&amp;self) -&gt; f64; }
    trait Circle : Shape { fn radius(&amp;self) -&gt; f64; }
    struct Point { x: f64, y: f64 }
    struct CircleStruct { center: Point, radius: f64 }
    impl Circle for CircleStruct { fn radius(&amp;self) -&gt; f64 { (self.area() / PI).sqrt() } }
    impl Shape for CircleStruct { fn area(&amp;self) -&gt; f64 { PI * square(self.radius) } }
    fn square(x: f64) -&gt; f64 { x * x }
    
    let concrete = box CircleStruct{center:Point{x:3.0,y:4.0},radius:5.0};
    let mycircle: Box&lt;Circle&gt; = concrete as Box&lt;Circle&gt;;
    let nonsense = mycircle.radius() * mycircle.area();
}</span><pre id='rust-example-rendered-124' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>f64</span>::<span class='ident'>consts</span>::<span class='ident'>PI</span>;

<span class='kw'>let</span> <span class='ident'>concrete</span> <span class='op'>=</span> <span class='kw'>box</span> <span class='ident'>CircleStruct</span>{<span class='ident'>center</span>:<span class='ident'>Point</span>{<span class='ident'>x</span>:<span class='number'>3.0</span>,<span class='ident'>y</span>:<span class='number'>4.0</span>},<span class='ident'>radius</span>:<span class='number'>5.0</span>};
<span class='kw'>let</span> <span class='ident'>mycircle</span>: <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>Circle</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>concrete</span> <span class='kw'>as</span> <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>Circle</span><span class='op'>&gt;</span>;
<span class='kw'>let</span> <span class='ident'>nonsense</span> <span class='op'>=</span> <span class='ident'>mycircle</span>.<span class='ident'>radius</span>() <span class='op'>*</span> <span class='ident'>mycircle</span>.<span class='ident'>area</span>();
</pre>

<blockquote>
<p><em>Note:</em> Trait inheritance does not actually work with objects yet</p>
</blockquote>

<h2 id="deriving-implementations-for-traits" class='section-header'><a
                           href="#deriving-implementations-for-traits">17.8 Deriving implementations for traits</a></h2>
<p>A small number of traits in <code>std</code> and <code>extra</code> can have implementations
that can be automatically derived. These instances are specified by
placing the <code>deriving</code> attribute on a data type declaration. For
example, the following will mean that <code>Circle</code> has an implementation
for <code>PartialEq</code> and can be used with the equality operators, and that a value
of type <code>ABC</code> can be randomly generated and converted to a string:</p>
<span id='rust-example-raw-125' class='rusttest'>extern crate rand;

#[deriving(PartialEq)]
struct Circle { radius: f64 }

#[deriving(Rand, Show)]
enum ABC { A, B, C }

fn main() {
    // Use the Show trait to print &quot;A, B, C.&quot;
    println!(&quot;{}, {}, {}&quot;, A, B, C);
}</span><pre id='rust-example-rendered-125' class='rust '>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>rand</span>;

<span class='attribute'>#[<span class='ident'>deriving</span>(<span class='ident'>PartialEq</span>)]</span>
<span class='kw'>struct</span> <span class='ident'>Circle</span> { <span class='ident'>radius</span>: <span class='ident'>f64</span> }

<span class='attribute'>#[<span class='ident'>deriving</span>(<span class='ident'>Rand</span>, <span class='ident'>Show</span>)]</span>
<span class='kw'>enum</span> <span class='ident'>ABC</span> { <span class='ident'>A</span>, <span class='ident'>B</span>, <span class='ident'>C</span> }

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='comment'>// Use the Show trait to print &quot;A, B, C.&quot;</span>
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}, {}, {}&quot;</span>, <span class='ident'>A</span>, <span class='ident'>B</span>, <span class='ident'>C</span>);
}
</pre>

<p>The full list of derivable traits is <code>PartialEq</code>, <code>Eq</code>, <code>PartialOrd</code>,
<code>Ord</code>, <code>Encodable</code>, <code>Decodable</code>, <code>Clone</code>,
<code>Hash</code>, <code>Rand</code>, <code>Default</code>, <code>Zero</code>, <code>FromPrimitive</code> and <code>Show</code>.</p>

<h1 id="crates-and-the-module-system" class='section-header'><a
                           href="#crates-and-the-module-system">18 Crates and the module system</a></h1>
<p>Rust&#39;s module system is very powerful, but because of that also somewhat complex.
Nevertheless, this section will try to explain every important aspect of it.</p>

<h2 id="crates" class='section-header'><a
                           href="#crates">18.1 Crates</a></h2>
<p>In order to speak about the module system, we first need to define the medium it exists in:</p>

<p>Let&#39;s say you&#39;ve written a program or a library, compiled it, and got the resulting binary.
In Rust, the content of all source code that the compiler directly had to compile in order to end up with
that binary is collectively called a &#39;crate&#39;.</p>

<p>For example, for a simple hello world program your crate only consists of this code:</p>
<span id='rust-example-raw-126' class='rusttest'>// `main.rs`
fn main() {
    println!(&quot;Hello world!&quot;);
}</span><pre id='rust-example-rendered-126' class='rust '>
<span class='comment'>// `main.rs`</span>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Hello world!&quot;</span>);
}
</pre>

<p>A crate is also the unit of independent compilation in Rust: <code>rustc</code> always compiles a single crate at a time,
from which it produces either a library or an executable.</p>

<p>Note that merely using an already compiled library in your code does not make it part of your crate.</p>

<h2 id="the-module-hierarchy" class='section-header'><a
                           href="#the-module-hierarchy">18.2 The module hierarchy</a></h2>
<p>For every crate, all the code in it is arranged in a hierarchy of modules starting with a single
root module. That root module is called the &#39;crate root&#39;.</p>

<p>All modules in a crate below the crate root are declared with the <code>mod</code> keyword:</p>
<span id='rust-example-raw-127' class='rusttest'>// This is the crate root

mod farm {
    // This is the body of module &#39;farm&#39; declared in the crate root.

    fn chicken() { println!(&quot;cluck cluck&quot;); }
    fn cow() { println!(&quot;mooo&quot;); }

    mod barn {
        // Body of module &#39;barn&#39;

        fn hay() { println!(&quot;...&quot;); }
    }
}

fn main() {
    println!(&quot;Hello farm!&quot;);
}</span><pre id='rust-example-rendered-127' class='rust '>
<span class='comment'>// This is the crate root</span>

<span class='kw'>mod</span> <span class='ident'>farm</span> {
    <span class='comment'>// This is the body of module &#39;farm&#39; declared in the crate root.</span>

    <span class='kw'>fn</span> <span class='ident'>chicken</span>() { <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;cluck cluck&quot;</span>); }
    <span class='kw'>fn</span> <span class='ident'>cow</span>() { <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;mooo&quot;</span>); }

    <span class='kw'>mod</span> <span class='ident'>barn</span> {
        <span class='comment'>// Body of module &#39;barn&#39;</span>

        <span class='kw'>fn</span> <span class='ident'>hay</span>() { <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;...&quot;</span>); }
    }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Hello farm!&quot;</span>);
}
</pre>

<p>As you can see, your module hierarchy is now three modules deep: There is the crate root, which contains your <code>main()</code>
function, and the module <code>farm</code>. The module <code>farm</code> also contains two functions and a third module <code>barn</code>,
which contains a function <code>hay</code>.</p>

<h2 id="paths-and-visibility" class='section-header'><a
                           href="#paths-and-visibility">18.3 Paths and visibility</a></h2>
<p>We&#39;ve now defined a nice module hierarchy. But how do we access the items in it from our <code>main</code> function?
One way to do it is to simply fully qualifying it:</p>
<span id='rust-example-raw-128' class='rusttest'>mod farm {
    fn chicken() { println!(&quot;cluck cluck&quot;); }
    // ...
}

fn main() {
    println!(&quot;Hello chicken!&quot;);

    ::farm::chicken(); // Won&#39;t compile yet, see further down
}</span><pre id='rust-example-rendered-128' class='rust '>
<span class='kw'>mod</span> <span class='ident'>farm</span> {
    <span class='kw'>fn</span> <span class='ident'>chicken</span>() { <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;cluck cluck&quot;</span>); }
    <span class='comment'>// ...</span>
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Hello chicken!&quot;</span>);

    ::<span class='ident'>farm</span>::<span class='ident'>chicken</span>(); <span class='comment'>// Won&#39;t compile yet, see further down</span>
}
</pre>

<p>The <code>::farm::chicken</code> construct is what we call a &#39;path&#39;.</p>

<p>Because it&#39;s starting with a <code>::</code>, it&#39;s also a &#39;global path&#39;, which qualifies
an item by its full path in the module hierarchy relative to the crate root.</p>

<p>If the path were to start with a regular identifier, like <code>farm::chicken</code>, it
would be a &#39;local path&#39; instead. We&#39;ll get to them later.</p>

<p>Now, if you actually tried to compile this code example, you&#39;ll notice that you
get a <code>function &#39;chicken&#39; is private</code> error. That&#39;s because by default, items
(<code>fn</code>, <code>struct</code>, <code>static</code>, <code>mod</code>, ...) are private.</p>

<p>To make them visible outside their containing modules, you need to mark them
<em>public</em> with <code>pub</code>:</p>
<span id='rust-example-raw-129' class='rusttest'>mod farm {
    pub fn chicken() { println!(&quot;cluck cluck&quot;); }
    pub fn cow() { println!(&quot;mooo&quot;); }
    // ...
}

fn main() {
    println!(&quot;Hello chicken!&quot;);
    ::farm::chicken(); // This compiles now
}</span><pre id='rust-example-rendered-129' class='rust '>
<span class='kw'>mod</span> <span class='ident'>farm</span> {
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>chicken</span>() { <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;cluck cluck&quot;</span>); }
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>cow</span>() { <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;mooo&quot;</span>); }
    <span class='comment'>// ...</span>
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Hello chicken!&quot;</span>);
    ::<span class='ident'>farm</span>::<span class='ident'>chicken</span>(); <span class='comment'>// This compiles now</span>
}
</pre>

<p>Visibility restrictions in Rust exist only at module boundaries. This
is quite different from most object-oriented languages that also
enforce restrictions on objects themselves. That&#39;s not to say that
Rust doesn&#39;t support encapsulation: both struct fields and methods can
be private. But this encapsulation is at the module level, not the
struct level.</p>

<p>Fields are <em>private</em> by default, and can be made <em>public</em> with
the <code>pub</code> keyword:</p>
<span id='rust-example-raw-130' class='rusttest'>mod farm {
pub type Chicken = int;
struct Human(int);
impl Human { pub fn rest(&amp;self) { } }
pub fn make_me_a_farm() -&gt; Farm { Farm { chickens: vec![], farmer: Human(0) } }
    pub struct Farm {
        chickens: Vec&lt;Chicken&gt;,
        pub farmer: Human
    }

    impl Farm {
        fn feed_chickens(&amp;self) { /* ... */ }
        pub fn add_chicken(&amp;self, c: Chicken) { /* ... */ }
    }

    pub fn feed_animals(farm: &amp;Farm) {
        farm.feed_chickens();
    }
}

fn main() {
    let f = make_me_a_farm();
    f.add_chicken(make_me_a_chicken());
    farm::feed_animals(&amp;f);
    f.farmer.rest();

    // This wouldn&#39;t compile because both are private:
    // `f.feed_chickens();`
    // `let chicken_counter = f.chickens.len();`
}
fn make_me_a_farm() -&gt; farm::Farm { farm::make_me_a_farm() }
fn make_me_a_chicken() -&gt; farm::Chicken { 0 }</span><pre id='rust-example-rendered-130' class='rust '>
<span class='kw'>mod</span> <span class='ident'>farm</span> {
    <span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>Farm</span> {
        <span class='ident'>chickens</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>Chicken</span><span class='op'>&gt;</span>,
        <span class='kw'>pub</span> <span class='ident'>farmer</span>: <span class='ident'>Human</span>
    }

    <span class='kw'>impl</span> <span class='ident'>Farm</span> {
        <span class='kw'>fn</span> <span class='ident'>feed_chickens</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) { <span class='comment'>/* ... */</span> }
        <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>add_chicken</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>c</span>: <span class='ident'>Chicken</span>) { <span class='comment'>/* ... */</span> }
    }

    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>feed_animals</span>(<span class='ident'>farm</span>: <span class='kw-2'>&amp;</span><span class='ident'>Farm</span>) {
        <span class='ident'>farm</span>.<span class='ident'>feed_chickens</span>();
    }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>f</span> <span class='op'>=</span> <span class='ident'>make_me_a_farm</span>();
    <span class='ident'>f</span>.<span class='ident'>add_chicken</span>(<span class='ident'>make_me_a_chicken</span>());
    <span class='ident'>farm</span>::<span class='ident'>feed_animals</span>(<span class='kw-2'>&amp;</span><span class='ident'>f</span>);
    <span class='ident'>f</span>.<span class='ident'>farmer</span>.<span class='ident'>rest</span>();

    <span class='comment'>// This wouldn&#39;t compile because both are private:</span>
    <span class='comment'>// `f.feed_chickens();`</span>
    <span class='comment'>// `let chicken_counter = f.chickens.len();`</span>
}
</pre>

<p>Exact details and specifications about visibility rules can be found in the Rust
manual.</p>

<h2 id="files-and-modules" class='section-header'><a
                           href="#files-and-modules">18.4 Files and modules</a></h2>
<p>One important aspect of Rust&#39;s module system is that source files and modules are not the same thing. You define a module hierarchy, populate it with all your definitions, define visibility, maybe put in a <code>fn main()</code>, and that&#39;s it.</p>

<p>The only file that&#39;s relevant when compiling is the one that contains the body
of your crate root, and it&#39;s only relevant because you have to pass that file
to <code>rustc</code> to compile your crate.</p>

<p>In principle, that&#39;s all you need: You can write any Rust program as one giant source file that contains your
crate root and everything else in <code>mod ... { ... }</code> declarations.</p>

<p>However, in practice you usually want to split up your code into multiple
source files to make it more manageable. Rust allows you to move the body of
any module into its own source file. If you declare a module without its body,
like <code>mod foo;</code>, the compiler will look for the files <code>foo.rs</code> and <code>foo/mod.rs</code>
inside some directory (usually the same as of the source file containing the
<code>mod foo;</code> declaration). If it finds either, it uses the content of that file
as the body of the module. If it finds both, that&#39;s a compile error.</p>

<p>To move the content of <code>mod farm</code> into its own file, you can write:</p>
<span id='rust-example-raw-131' class='rusttest'>// `main.rs` - contains body of the crate root
mod farm; // Compiler will look for `farm.rs` and `farm/mod.rs`

fn main() {
    println!(&quot;Hello farm!&quot;);
    ::farm::cow();
}</span><pre id='rust-example-rendered-131' class='rust '>
<span class='comment'>// `main.rs` - contains body of the crate root</span>
<span class='kw'>mod</span> <span class='ident'>farm</span>; <span class='comment'>// Compiler will look for `farm.rs` and `farm/mod.rs`</span>

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Hello farm!&quot;</span>);
    ::<span class='ident'>farm</span>::<span class='ident'>cow</span>();
}
</pre>
<span id='rust-example-raw-132' class='rusttest'>// `farm.rs` - contains body of module &#39;farm&#39; in the crate root
pub fn chicken() { println!(&quot;cluck cluck&quot;); }
pub fn cow() { println!(&quot;mooo&quot;); }

pub mod barn {
    pub fn hay() { println!(&quot;...&quot;); }
}
fn main() { }</span><pre id='rust-example-rendered-132' class='rust '>
<span class='comment'>// `farm.rs` - contains body of module &#39;farm&#39; in the crate root</span>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>chicken</span>() { <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;cluck cluck&quot;</span>); }
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>cow</span>() { <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;mooo&quot;</span>); }

<span class='kw'>pub</span> <span class='kw'>mod</span> <span class='ident'>barn</span> {
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>hay</span>() { <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;...&quot;</span>); }
}
</pre>

<p>In short, <code>mod foo;</code> is just syntactic sugar for <code>mod foo { /* content of &lt;...&gt;/foo.rs or &lt;...&gt;/foo/mod.rs */ }</code>.</p>

<p>This also means that having two or more identical <code>mod foo;</code> declarations
somewhere in your crate hierarchy is generally a bad idea,
just like copy-and-paste-ing a module into multiple places is a bad idea.
Both will result in duplicate and mutually incompatible definitions.</p>

<p>When <code>rustc</code> resolves these module declarations, it starts by looking in the
parent directory of the file containing the <code>mod foo</code> declaration. For example,
given a file with the module body:</p>
<span id='rust-example-raw-133' class='rusttest'>fn main() {
    // `src/main.rs`
    mod plants;
    mod animals {
        mod fish;
        mod mammals {
            mod humans;
        }
    }
}</span><pre id='rust-example-rendered-133' class='rust '>
<span class='comment'>// `src/main.rs`</span>
<span class='kw'>mod</span> <span class='ident'>plants</span>;
<span class='kw'>mod</span> <span class='ident'>animals</span> {
    <span class='kw'>mod</span> <span class='ident'>fish</span>;
    <span class='kw'>mod</span> <span class='ident'>mammals</span> {
        <span class='kw'>mod</span> <span class='ident'>humans</span>;
    }
}
</pre>

<p>The compiler will look for these files, in this order:</p>

<pre><code class="language-text">src/plants.rs
src/plants/mod.rs

src/animals/fish.rs
src/animals/fish/mod.rs

src/animals/mammals/humans.rs
src/animals/mammals/humans/mod.rs</code></pre>

<p>Keep in mind that identical module hierarchies can still lead to different path
lookups depending on how and where you&#39;ve moved a module body to its own file.
For example, if you move the <code>animals</code> module into its own file:</p>
<span id='rust-example-raw-134' class='rusttest'>fn main() {
    // `src/main.rs`
    mod plants;
    mod animals;
}</span><pre id='rust-example-rendered-134' class='rust '>
<span class='comment'>// `src/main.rs`</span>
<span class='kw'>mod</span> <span class='ident'>plants</span>;
<span class='kw'>mod</span> <span class='ident'>animals</span>;
</pre>
<span id='rust-example-raw-135' class='rusttest'>fn main() {
    // `src/animals.rs` or `src/animals/mod.rs`
    mod fish;
    mod mammals {
        mod humans;
    }
}</span><pre id='rust-example-rendered-135' class='rust '>
<span class='comment'>// `src/animals.rs` or `src/animals/mod.rs`</span>
<span class='kw'>mod</span> <span class='ident'>fish</span>;
<span class='kw'>mod</span> <span class='ident'>mammals</span> {
    <span class='kw'>mod</span> <span class='ident'>humans</span>;
}
</pre>

<p>...then the source files of <code>mod animals</code>&#39;s submodules can either be in the same directory as the animals source file or in a subdirectory of its directory. If the animals file is <code>src/animals.rs</code>, <code>rustc</code> will look for:</p>

<pre><code class="language-text">src/animals.rs
    src/fish.rs
    src/fish/mod.rs

    src/mammals/humans.rs
    src/mammals/humans/mod.rs</code></pre>

<p>If the animals file is <code>src/animals/mod.rs</code>, <code>rustc</code> will look for:</p>

<pre><code class="language-text">src/animals/mod.rs
    src/animals/fish.rs
    src/animals/fish/mod.rs

    src/animals/mammals/humans.rs
    src/animals/mammals/humans/mod.rs
</code></pre>

<p>These rules allow you to write small modules consisting of single source files which can live in the same directory as well as large modules which group submodule source files in subdirectories.</p>

<p>If you need to override where <code>rustc</code> will look for the file containing a
module&#39;s source code, use the <code>path</code> compiler directive. For example, to load a
<code>classified</code> module from a different file:</p>
<span id='rust-example-raw-136' class='rusttest'>fn main() {
    #[path=&quot;../../area51/alien.rs&quot;]
    mod classified;
}</span><pre id='rust-example-rendered-136' class='rust '>
<span class='attribute'>#[<span class='ident'>path</span><span class='op'>=</span><span class='string'>&quot;../../area51/alien.rs&quot;</span>]</span>
<span class='kw'>mod</span> <span class='ident'>classified</span>;
</pre>

<h2 id="importing-names-into-the-local-scope" class='section-header'><a
                           href="#importing-names-into-the-local-scope">18.5 Importing names into the local scope</a></h2>
<p>Always referring to definitions in other modules with their global
path gets old really fast, so Rust has a way to import
them into the local scope of your module: <code>use</code>-statements.</p>

<p>They work like this: At the beginning of any module body, <code>fn</code> body, or any other block
you can write a list of <code>use</code>-statements, consisting of the keyword <code>use</code> and a <strong>global path</strong> to an item
without the <code>::</code> prefix. For example, this imports <code>cow</code> into the local scope:</p>
<span id='rust-example-raw-137' class='rusttest'>use farm::cow;
mod farm { pub fn cow() { println!(&quot;I&#39;m a hidden ninja cow!&quot;) } }
fn main() { cow() }</span><pre id='rust-example-rendered-137' class='rust '>
<span class='kw'>use</span> <span class='ident'>farm</span>::<span class='ident'>cow</span>;
</pre>

<p>The path you give to <code>use</code> is per default global, meaning relative to the crate root,
no matter how deep the module hierarchy is, or whether the module body it&#39;s written in
is contained in its own file. (Remember: files are irrelevant.)</p>

<p>This is different from other languages, where you often only find a single import construct that combines the semantic
of <code>mod foo;</code> and <code>use</code>-statements, and which tend to work relative to the source file or use an absolute file path
- Ruby&#39;s <code>require</code> or C/C++&#39;s <code>#include</code> come to mind.</p>

<p>However, it&#39;s also possible to import things relative to the module of the <code>use</code>-statement:
Adding a <code>super::</code> in front of the path will start in the parent module,
while adding a <code>self::</code> prefix will start in the current module:</p>
<span id='rust-example-raw-138' class='rusttest'>fn main() {
    mod workaround {
    pub fn some_parent_item(){ println!(&quot;...&quot;) }
    mod foo {
    use super::some_parent_item;
    use self::some_child_module::some_item;
    pub fn bar() { some_parent_item(); some_item() }
    pub mod some_child_module { pub fn some_item() {} }
    }
    }
}</span><pre id='rust-example-rendered-138' class='rust '>
<span class='kw'>use</span> <span class='ident'>super</span>::<span class='ident'>some_parent_item</span>;
<span class='kw'>use</span> <span class='self'>self</span>::<span class='ident'>some_child_module</span>::<span class='ident'>some_item</span>;
</pre>

<p>Again - relative to the module, not to the file.</p>

<p>Imports are also shadowed by local definitions:
For each name you mention in a module/block, <code>rust</code>
will first look at all items that are defined locally,
and only if that results in no match look at items you brought in
scope with corresponding <code>use</code> statements.</p>
<span id='rust-example-raw-139' class='rusttest'>// FIXME: Allow unused import in doc test
use farm::cow;
// ...
mod farm { pub fn cow() { println!(&quot;Hidden ninja cow is hidden.&quot;) } }
fn cow() { println!(&quot;Mooo!&quot;) }

fn main() {
    cow() // resolves to the locally defined `cow()` function
}</span><pre id='rust-example-rendered-139' class='rust '>
<span class='kw'>use</span> <span class='ident'>farm</span>::<span class='ident'>cow</span>;
<span class='comment'>// ...</span>
<span class='kw'>fn</span> <span class='ident'>cow</span>() { <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Mooo!&quot;</span>) }

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='ident'>cow</span>() <span class='comment'>// resolves to the locally defined `cow()` function</span>
}
</pre>

<p>To make this behavior more obvious, the rule has been made that <code>use</code>-statement always need to be written
before any declaration, like in the example above. This is a purely artificial rule introduced
because people always assumed they shadowed each other based on order, despite the fact that all items in rust are
mutually recursive, order independent definitions.</p>

<p>One odd consequence of that rule is that <code>use</code> statements also go in front of any <code>mod</code> declaration,
even if they refer to things inside them:</p>
<span id='rust-example-raw-140' class='rusttest'>use farm::cow;
mod farm {
    pub fn cow() { println!(&quot;Moooooo?&quot;) }
}

fn main() { cow() }</span><pre id='rust-example-rendered-140' class='rust '>
<span class='kw'>use</span> <span class='ident'>farm</span>::<span class='ident'>cow</span>;
<span class='kw'>mod</span> <span class='ident'>farm</span> {
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>cow</span>() { <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Moooooo?&quot;</span>) }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() { <span class='ident'>cow</span>() }
</pre>

<p>This is what our <code>farm</code> example looks like with <code>use</code> statements:</p>
<span id='rust-example-raw-141' class='rusttest'>use farm::chicken;
use farm::cow;
use farm::barn;

mod farm {
    pub fn chicken() { println!(&quot;cluck cluck&quot;); }
    pub fn cow() { println!(&quot;mooo&quot;); }

    pub mod barn {
        pub fn hay() { println!(&quot;...&quot;); }
    }
}

fn main() {
    println!(&quot;Hello farm!&quot;);

    // Can now refer to those names directly:
    chicken();
    cow();
    barn::hay();
}</span><pre id='rust-example-rendered-141' class='rust '>
<span class='kw'>use</span> <span class='ident'>farm</span>::<span class='ident'>chicken</span>;
<span class='kw'>use</span> <span class='ident'>farm</span>::<span class='ident'>cow</span>;
<span class='kw'>use</span> <span class='ident'>farm</span>::<span class='ident'>barn</span>;

<span class='kw'>mod</span> <span class='ident'>farm</span> {
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>chicken</span>() { <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;cluck cluck&quot;</span>); }
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>cow</span>() { <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;mooo&quot;</span>); }

    <span class='kw'>pub</span> <span class='kw'>mod</span> <span class='ident'>barn</span> {
        <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>hay</span>() { <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;...&quot;</span>); }
    }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Hello farm!&quot;</span>);

    <span class='comment'>// Can now refer to those names directly:</span>
    <span class='ident'>chicken</span>();
    <span class='ident'>cow</span>();
    <span class='ident'>barn</span>::<span class='ident'>hay</span>();
}
</pre>

<p>And here an example with multiple files:</p>
<span id='rust-example-raw-142' class='rusttest'>// `a.rs` - crate root
use b::foo;
use b::c::bar;
mod b;
fn main() {
    foo();
    bar();
}</span><pre id='rust-example-rendered-142' class='rust '>
<span class='comment'>// `a.rs` - crate root</span>
<span class='kw'>use</span> <span class='ident'>b</span>::<span class='ident'>foo</span>;
<span class='kw'>use</span> <span class='ident'>b</span>::<span class='ident'>c</span>::<span class='ident'>bar</span>;
<span class='kw'>mod</span> <span class='ident'>b</span>;
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='ident'>foo</span>();
    <span class='ident'>bar</span>();
}
</pre>
<span id='rust-example-raw-143' class='rusttest'>fn main() {
    // `b/mod.rs`
    pub mod c;
    pub fn foo() { println!(&quot;Foo!&quot;); }
}</span><pre id='rust-example-rendered-143' class='rust '>
<span class='comment'>// `b/mod.rs`</span>
<span class='kw'>pub</span> <span class='kw'>mod</span> <span class='ident'>c</span>;
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>foo</span>() { <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Foo!&quot;</span>); }
</pre>
<span id='rust-example-raw-144' class='rusttest'>fn main() {
    // `b/c.rs`
    pub fn bar() { println!(&quot;Bar!&quot;); }
}</span><pre id='rust-example-rendered-144' class='rust '>
<span class='comment'>// `b/c.rs`</span>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>bar</span>() { <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Bar!&quot;</span>); }
</pre>

<p>There also exist two short forms for importing multiple names at once:</p>

<ol>
<li>Explicit mention multiple names as the last element of an <code>use</code> path:</li>
</ol>
<span id='rust-example-raw-145' class='rusttest'>use farm::{chicken, cow};
mod farm {
    pub fn cow() { println!(&quot;Did I already mention how hidden and ninja I am?&quot;) }
    pub fn chicken() { println!(&quot;I&#39;m Bat-chicken, guardian of the hidden tutorial code.&quot;) }
}
fn main() { cow(); chicken() }</span><pre id='rust-example-rendered-145' class='rust '>
<span class='kw'>use</span> <span class='ident'>farm</span>::{<span class='ident'>chicken</span>, <span class='ident'>cow</span>};
</pre>

<ol>
<li>Import everything in a module with a wildcard:</li>
</ol>
<span id='rust-example-raw-146' class='rusttest'>#![feature(globs)]
use farm::*;
mod farm {
    pub fn cow() { println!(&quot;Bat-chicken? What a stupid name!&quot;) }
    pub fn chicken() { println!(&quot;Says the &#39;hidden ninja&#39; cow.&quot;) }
}
fn main() { cow(); chicken() }</span><pre id='rust-example-rendered-146' class='rust '>
<span class='kw'>use</span> <span class='ident'>farm</span>::<span class='op'>*</span>;
</pre>

<blockquote>
<p><em>Note:</em> This feature of the compiler is currently gated behind the
<code>#![feature(globs)]</code> directive. More about these directives can be found in
the manual.</p>
</blockquote>

<p>However, that&#39;s not all. You can also rename an item while you&#39;re bringing it into scope:</p>
<span id='rust-example-raw-147' class='rusttest'>use egg_layer = farm::chicken;
mod farm { pub fn chicken() { println!(&quot;Laying eggs is fun!&quot;)  } }
// ...

fn main() {
    egg_layer();
}</span><pre id='rust-example-rendered-147' class='rust '>
<span class='kw'>use</span> <span class='ident'>egg_layer</span> <span class='op'>=</span> <span class='ident'>farm</span>::<span class='ident'>chicken</span>;
<span class='comment'>// ...</span>

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='ident'>egg_layer</span>();
}
</pre>

<p>In general, <code>use</code> creates a local alias:
An alternate path and a possibly different name to access the same item,
without touching the original, and with both being interchangeable.</p>

<h2 id="reexporting-names" class='section-header'><a
                           href="#reexporting-names">18.6 Reexporting names</a></h2>
<p>It is also possible to reexport items to be accessible under your module.</p>

<p>For that, you write <code>pub use</code>:</p>
<span id='rust-example-raw-148' class='rusttest'>mod farm {
    pub use self::barn::hay;

    pub fn chicken() { println!(&quot;cluck cluck&quot;); }
    pub fn cow() { println!(&quot;mooo&quot;); }

    mod barn {
        pub fn hay() { println!(&quot;...&quot;); }
    }
}

fn main() {
    farm::chicken();
    farm::cow();
    farm::hay();
}</span><pre id='rust-example-rendered-148' class='rust '>
<span class='kw'>mod</span> <span class='ident'>farm</span> {
    <span class='kw'>pub</span> <span class='kw'>use</span> <span class='self'>self</span>::<span class='ident'>barn</span>::<span class='ident'>hay</span>;

    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>chicken</span>() { <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;cluck cluck&quot;</span>); }
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>cow</span>() { <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;mooo&quot;</span>); }

    <span class='kw'>mod</span> <span class='ident'>barn</span> {
        <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>hay</span>() { <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;...&quot;</span>); }
    }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='ident'>farm</span>::<span class='ident'>chicken</span>();
    <span class='ident'>farm</span>::<span class='ident'>cow</span>();
    <span class='ident'>farm</span>::<span class='ident'>hay</span>();
}
</pre>

<p>Just like in normal <code>use</code> statements, the exported names
merely represent an alias to the same thing and can also be renamed.</p>

<p>The above example also demonstrate what you can use <code>pub use</code> for:
The nested <code>barn</code> module is private, but the <code>pub use</code> allows users
of the module <code>farm</code> to access a function from <code>barn</code> without needing
to know that <code>barn</code> exists.</p>

<p>In other words, you can use it to decouple a public api from its internal implementation.</p>

<h2 id="using-libraries" class='section-header'><a
                           href="#using-libraries">18.7 Using libraries</a></h2>
<p>So far we&#39;ve only talked about how to define and structure your own crate.</p>

<p>However, most code out there will want to use preexisting libraries,
as there really is no reason to start from scratch each time you start a new project.</p>

<p>In Rust terminology, we need a way to refer to other crates.</p>

<p>For that, Rust offers you the <code>extern crate</code> declaration:</p>
<span id='rust-example-raw-149' class='rusttest'>extern crate num;
// `num` ships with Rust (much like `extra`; more details further down).

fn main() {
    // The rational number &#39;1/2&#39;:
    let one_half = ::num::rational::Ratio::new(1i, 2);
}</span><pre id='rust-example-rendered-149' class='rust '>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>num</span>;
<span class='comment'>// `num` ships with Rust (much like `extra`; more details further down).</span>

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='comment'>// The rational number &#39;1/2&#39;:</span>
    <span class='kw'>let</span> <span class='ident'>one_half</span> <span class='op'>=</span> ::<span class='ident'>num</span>::<span class='ident'>rational</span>::<span class='ident'>Ratio</span>::<span class='ident'>new</span>(<span class='number'>1i</span>, <span class='number'>2</span>);
}
</pre>

<p>A statement of the form <code>extern crate foo;</code> will cause <code>rustc</code> to search for the crate <code>foo</code>,
and if it finds a matching binary it lets you use it from inside your crate.</p>

<p>The effect it has on your module hierarchy mirrors aspects of both <code>mod</code> and <code>use</code>:</p>

<ul>
<li><p>Like <code>mod</code>, it causes <code>rustc</code> to actually emit code:
The linkage information the binary needs to use the library <code>foo</code>.</p></li>
<li><p>But like <code>use</code>, all <code>extern crate</code> statements that refer to the same library are interchangeable,
as each one really just presents an alias to an external module (the crate root of the library
you&#39;re linking against).</p></li>
</ul>

<p>Remember how <code>use</code>-statements have to go before local declarations because the latter shadows the former?
Well, <code>extern crate</code> statements also have their own rules in that regard:
Both <code>use</code> and local declarations can shadow them, so the rule is that <code>extern crate</code> has to go in front
of both <code>use</code> and local declarations.</p>

<p>Which can result in something like this:</p>
<span id='rust-example-raw-150' class='rusttest'>extern crate num;

use farm::dog;
use num::rational::Ratio;

mod farm {
    pub fn dog() { println!(&quot;woof&quot;); }
}

fn main() {
    farm::dog();
    let a_third = Ratio::new(1i, 3);
}</span><pre id='rust-example-rendered-150' class='rust '>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>num</span>;

<span class='kw'>use</span> <span class='ident'>farm</span>::<span class='ident'>dog</span>;
<span class='kw'>use</span> <span class='ident'>num</span>::<span class='ident'>rational</span>::<span class='ident'>Ratio</span>;

<span class='kw'>mod</span> <span class='ident'>farm</span> {
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>dog</span>() { <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;woof&quot;</span>); }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='ident'>farm</span>::<span class='ident'>dog</span>();
    <span class='kw'>let</span> <span class='ident'>a_third</span> <span class='op'>=</span> <span class='ident'>Ratio</span>::<span class='ident'>new</span>(<span class='number'>1i</span>, <span class='number'>3</span>);
}
</pre>

<p>It&#39;s a bit weird, but it&#39;s the result of shadowing rules that have been set that way because
they model most closely what people expect to shadow.</p>

<h2 id="crate-metadata-and-settings" class='section-header'><a
                           href="#crate-metadata-and-settings">18.8 Crate metadata and settings</a></h2>
<p>For every crate you can define a number of metadata items, such as link name, version or author.
You can also toggle settings that have crate-global consequences. Both mechanism
work by providing attributes in the crate root.</p>

<p>For example, Rust uniquely identifies crates by their link metadata, which includes
the link name and the version. It also hashes the filename and the symbols in a binary
based on the link metadata, allowing you to use two different versions of the same library in a crate
without conflict.</p>

<p>Therefore, if you plan to compile your crate as a library, you should annotate it with that information:</p>
<span id='rust-example-raw-151' class='rusttest'>fn main() {
    #![allow(unused_attribute)]
    // `lib.rs`
    
    #![crate_type = &quot;lib&quot;]
    #![crate_id = &quot;farm#2.5&quot;]
    
    // ...
    fn farm() {}
}</span><pre id='rust-example-rendered-151' class='rust '>
<span class='comment'>// `lib.rs`</span>

<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>crate_id</span> <span class='op'>=</span> <span class='string'>&quot;farm#2.5&quot;</span>]</span>

<span class='comment'>// ...</span>
</pre>

<p>You can also specify crate id information in a <code>extern crate</code> statement.  For
example, these <code>extern crate</code> statements would both accept and select the
crate define above:</p>
<span id='rust-example-raw-152' class='rusttest'>fn main() {
    extern crate farm;
    extern crate farm = &quot;farm#2.5&quot;;
    extern crate my_farm = &quot;farm&quot;;
}</span><pre id='rust-example-rendered-152' class='rust '>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>farm</span>;
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>farm</span> <span class='op'>=</span> <span class='string'>&quot;farm#2.5&quot;</span>;
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>my_farm</span> <span class='op'>=</span> <span class='string'>&quot;farm&quot;</span>;
</pre>

<p>Other crate settings and metadata include things like enabling/disabling certain errors or warnings,
or setting the crate type (library or executable) explicitly:</p>
<span id='rust-example-raw-153' class='rusttest'>fn main() {
    #![allow(unused_attribute)]
    // `lib.rs`
    // ...
    
    // This crate is a library (&quot;bin&quot; is the default)
    #![crate_id = &quot;farm#2.5&quot;]
    #![crate_type = &quot;lib&quot;]
    
    // Turn on a warning
    #[warn(non_camel_case_types)]
    fn farm() {}
}</span><pre id='rust-example-rendered-153' class='rust '>
<span class='comment'>// `lib.rs`</span>
<span class='comment'>// ...</span>

<span class='comment'>// This crate is a library (&quot;bin&quot; is the default)</span>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>crate_id</span> <span class='op'>=</span> <span class='string'>&quot;farm#2.5&quot;</span>]</span>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>crate_type</span> <span class='op'>=</span> <span class='string'>&quot;lib&quot;</span>]</span>

<span class='comment'>// Turn on a warning</span>
<span class='attribute'>#[<span class='ident'>warn</span>(<span class='ident'>non_camel_case_types</span>)]</span>
</pre>

<h2 id="a-minimal-example" class='section-header'><a
                           href="#a-minimal-example">18.9 A minimal example</a></h2>
<p>Now for something that you can actually compile yourself.</p>

<p>We define two crates, and use one of them as a library in the other.</p>
<span id='rust-example-raw-154' class='rusttest'>fn main() {
    #![allow(unused_attribute)]
    // `world.rs`
    #![crate_id = &quot;world#0.42&quot;]
    
    mod secret_module_to_make_this_test_run {
    pub fn explore() -&gt; &amp;&#39;static str { &quot;world&quot; }
    }
}</span><pre id='rust-example-rendered-154' class='rust '>
<span class='comment'>// `world.rs`</span>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>crate_id</span> <span class='op'>=</span> <span class='string'>&quot;world#0.42&quot;</span>]</span>

<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>explore</span>() <span class='op'>-&gt;</span> <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;static</span> <span class='ident'>str</span> { <span class='string'>&quot;world&quot;</span> }
</pre>
<span id='rust-example-raw-155' class='rusttest'>// `main.rs`
extern crate world;
fn main() { println!(&quot;hello {}&quot;, world::explore()); }</span><pre id='rust-example-rendered-155' class='rust '>
<span class='comment'>// `main.rs`</span>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>world</span>;
<span class='kw'>fn</span> <span class='ident'>main</span>() { <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;hello {}&quot;</span>, <span class='ident'>world</span>::<span class='ident'>explore</span>()); }
</pre>

<p>Now compile and run like this (adjust to your platform if necessary):</p>

<pre><code class="language-console">$ rustc --crate-type=lib world.rs  # compiles libworld-&lt;HASH&gt;-0.42.rlib
$ rustc main.rs -L .               # compiles main
$ ./main
&quot;hello world&quot;</code></pre>

<p>Notice that the library produced contains the version in the file name
as well as an inscrutable string of alphanumerics. As explained in the previous paragraph,
these are both part of Rust&#39;s library versioning scheme. The alphanumerics are
a hash representing the crate&#39;s id.</p>

<h2 id="the-standard-library-and-the-prelude" class='section-header'><a
                           href="#the-standard-library-and-the-prelude">18.10 The standard library and the prelude</a></h2>
<p>While reading the examples in this tutorial, you might have asked yourself where all
those magical predefined items like <code>range</code> are coming from.</p>

<p>The truth is, there&#39;s nothing magical about them: They are all defined normally
in the <code>std</code> library, which is a crate that ships with Rust.</p>

<p>The only magical thing that happens is that <code>rustc</code> automatically inserts this line into your crate root:</p>
<span id='rust-example-raw-156' class='rusttest'>fn main() {
    extern crate std;
}</span><pre id='rust-example-rendered-156' class='rust '>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>std</span>;
</pre>

<p>As well as this line into every module body:</p>
<span id='rust-example-raw-157' class='rusttest'>fn main() {
    use std::prelude::*;
}</span><pre id='rust-example-rendered-157' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>prelude</span>::<span class='op'>*</span>;
</pre>

<p>The role of the <code>prelude</code> module is to re-export common definitions from <code>std</code>.</p>

<p>This allows you to use common types and functions like <code>Option&lt;T&gt;</code> or <code>range</code>
without needing to import them. And if you need something from <code>std</code> that&#39;s not in the prelude,
you just have to import it with an <code>use</code> statement.</p>

<p>For example, it re-exports <code>range</code> which is defined in <code>std::iter::range</code>:</p>
<span id='rust-example-raw-158' class='rusttest'>use iter_range = std::iter::range;

fn main() {
    // `range` is imported by default
    for _ in range(0u, 10) {}

    // Doesn&#39;t hinder you from importing it under a different name yourself
    for _ in iter_range(0u, 10) {}

    // Or from not using the automatic import.
    for _ in ::std::iter::range(0u, 10) {}
}</span><pre id='rust-example-rendered-158' class='rust '>
<span class='kw'>use</span> <span class='ident'>iter_range</span> <span class='op'>=</span> <span class='ident'>std</span>::<span class='ident'>iter</span>::<span class='ident'>range</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='comment'>// `range` is imported by default</span>
    <span class='kw'>for</span> _ <span class='kw'>in</span> <span class='ident'>range</span>(<span class='number'>0u</span>, <span class='number'>10</span>) {}

    <span class='comment'>// Doesn&#39;t hinder you from importing it under a different name yourself</span>
    <span class='kw'>for</span> _ <span class='kw'>in</span> <span class='ident'>iter_range</span>(<span class='number'>0u</span>, <span class='number'>10</span>) {}

    <span class='comment'>// Or from not using the automatic import.</span>
    <span class='kw'>for</span> _ <span class='kw'>in</span> ::<span class='ident'>std</span>::<span class='ident'>iter</span>::<span class='ident'>range</span>(<span class='number'>0u</span>, <span class='number'>10</span>) {}
}
</pre>

<p>Both auto-insertions can be disabled with an attribute if necessary:</p>
<span id='rust-example-raw-159' class='rusttest'>fn main() {
    #![allow(unused_attribute)]
    // In the crate root:
    #![no_std]
}</span><pre id='rust-example-rendered-159' class='rust '>
<span class='comment'>// In the crate root:</span>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>no_std</span>]</span>
</pre>
<span id='rust-example-raw-160' class='rusttest'>fn main() {
    #![allow(unused_attribute)]
    // In any module:
    #![no_implicit_prelude]
}</span><pre id='rust-example-rendered-160' class='rust '>
<span class='comment'>// In any module:</span>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>no_implicit_prelude</span>]</span>
</pre>

<p>See the <a href="std/index.html">API documentation</a> for details.</p>

<h1 id="what-next?" class='section-header'><a
                           href="#what-next?">19 What next?</a></h1>
<p>Now that you know the essentials, check out any of the additional
guides on individual topics.</p>

<ul>
<li><a href="guide-pointers.html">Pointers</a></li>
<li><a href="guide-lifetimes.html">Lifetimes</a></li>
<li><a href="guide-tasks.html">Tasks and communication</a></li>
<li><a href="guide-macros.html">Macros</a></li>
<li><a href="guide-ffi.html">The foreign function interface</a></li>
<li><a href="guide-container.html">Containers and iterators</a></li>
<li><a href="rustdoc.html">Documenting Rust code</a></li>
<li><a href="guide-testing.html">Testing Rust code</a></li>
<li><a href="guide-runtime.html">The Rust Runtime</a></li>
</ul>

<p>There is further documentation on the <a href="https://github.com/rust-lang/rust/wiki/Docs">wiki</a>, however those tend to be even more out of date than this document.</p>

    <script type="text/javascript">
        window.playgroundUrl = "http://play.rust-lang.org/";
    </script>
    <footer><p>
Copyright &copy; 2011-2014 The Rust Project Developers. Licensed under the
<a href="http://www.apache.org/licenses/LICENSE-2.0">Apache License, Version 2.0</a>
or the <a href="http://opensource.org/licenses/MIT">MIT license</a>, at your option.
</p><p>
This file may not be copied, modified, or distributed except according to those terms.
</p></footer>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="playpen.js"></script>


</body>
</html>