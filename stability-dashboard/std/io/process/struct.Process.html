<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="The std library documentation.">

    <title>std::io::process::Process - Rust</title>

    <link href='http://fonts.googleapis.com/css?family=Source+Code+Pro:400,600'
          rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="../../../main.css">

    <link rel="shortcut icon" href="http://www.rust-lang.org/favicon.ico">
    
</head>
<body>
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <section class="sidebar">
        <a href='../../../std/index.html'><img src='http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png' alt='' width='100'></a>
        <p class='location'><a href='../../index.html'>std</a>&#8203;::<a href='../index.html'>io</a>&#8203;::<a href='index.html'>process</a></p><div class='block struct'><h2>Structs</h2><a class='struct ' href='struct.Command.html'>Command</a><a class='struct current' href='struct.Process.html'>Process</a><a class='struct ' href='struct.ProcessOutput.html'>ProcessOutput</a></div>
    </section>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press 'S' to search, '?' for more options..."
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content struct">
<h1 class='fqn'>Struct <a href='../../index.html'>std</a>::<a href='../index.html'>io</a>::<a href='index.html'>process</a>::<a class='struct' href=''>Process</a><a class='stability Experimental' title=''>Experimental</a><span class='out-of-band'><a id='src-40372' href='../../../src/std/Users/aturon/moz/working/stability-dashboard/src/libstd/io/process.rs.html#60-79'>[src]</a></span></h1>
<pre class='rust struct'>pub struct Process {
    pub stdin: <a class='type' href='../../../std/option/type.Option.html' title='std::option::Option'>Option</a>&lt;<a class='struct' href='../../../std/io/pipe/struct.PipeStream.html' title='std::io::pipe::PipeStream'>PipeStream</a>&gt;,
    pub stdout: <a class='type' href='../../../std/option/type.Option.html' title='std::option::Option'>Option</a>&lt;<a class='struct' href='../../../std/io/pipe/struct.PipeStream.html' title='std::io::pipe::PipeStream'>PipeStream</a>&gt;,
    pub stderr: <a class='type' href='../../../std/option/type.Option.html' title='std::option::Option'>Option</a>&lt;<a class='struct' href='../../../std/io/pipe/struct.PipeStream.html' title='std::io::pipe::PipeStream'>PipeStream</a>&gt;,
    pub extra_io: <a class='struct' href='../../../std/vec/struct.Vec.html' title='std::vec::Vec'>Vec</a>&lt;<a class='type' href='../../../std/option/type.Option.html' title='std::option::Option'>Option</a>&lt;<a class='struct' href='../../../std/io/pipe/struct.PipeStream.html' title='std::io::pipe::PipeStream'>PipeStream</a>&gt;&gt;,
    // some fields omitted
}</pre><div class='docblock'><p>Representation of a running or exited child process.</p>

<p>This structure is used to represent and manage child processes. A child
process is created via the <code>Command</code> struct, which configures the spawning
process and can itself be constructed using a builder-style interface.</p>

<h1 id="example" class='section-header'><a
                           href="#example">Example</a></h1><span id='rust-example-raw-0' class='rusttest'>fn main() {
    use std::io::Command;
    
    let mut child = match Command::new(&quot;/bin/cat&quot;).arg(&quot;file.txt&quot;).spawn() {
        Ok(child) =&gt; child,
        Err(e) =&gt; fail!(&quot;failed to execute child: {}&quot;, e),
    };
    
    let contents = child.stdout.get_mut_ref().read_to_end();
    assert!(child.wait().unwrap().success());
}</span><pre id='rust-example-rendered-0' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::<span class='ident'>Command</span>;

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>child</span> <span class='op'>=</span> <span class='kw'>match</span> <span class='ident'>Command</span>::<span class='ident'>new</span>(<span class='string'>&quot;/bin/cat&quot;</span>).<span class='ident'>arg</span>(<span class='string'>&quot;file.txt&quot;</span>).<span class='ident'>spawn</span>() {
    <span class='prelude-val'>Ok</span>(<span class='ident'>child</span>) <span class='op'>=&gt;</span> <span class='ident'>child</span>,
    <span class='prelude-val'>Err</span>(<span class='ident'>e</span>) <span class='op'>=&gt;</span> <span class='macro'>fail</span><span class='macro'>!</span>(<span class='string'>&quot;failed to execute child: {}&quot;</span>, <span class='ident'>e</span>),
};

<span class='kw'>let</span> <span class='ident'>contents</span> <span class='op'>=</span> <span class='ident'>child</span>.<span class='ident'>stdout</span>.<span class='ident'>get_mut_ref</span>().<span class='ident'>read_to_end</span>();
<span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>child</span>.<span class='ident'>wait</span>().<span class='ident'>unwrap</span>().<span class='ident'>success</span>());
</pre>
</div><h2 class='fields'>Fields</h2>
<table><tr><td id='structfield.stdin'><a class='stability Experimental' title='Experimental'></a><code>stdin</code></td><td><div class='docblock'><p>Handle to the child&#39;s stdin, if the <code>stdin</code> field of this process&#39;s
<code>ProcessConfig</code> was <code>CreatePipe</code>. By default, this handle is <code>Some</code>.</p>
</div></td></tr><tr><td id='structfield.stdout'><a class='stability Experimental' title='Experimental'></a><code>stdout</code></td><td><div class='docblock'><p>Handle to the child&#39;s stdout, if the <code>stdout</code> field of this process&#39;s
<code>ProcessConfig</code> was <code>CreatePipe</code>. By default, this handle is <code>Some</code>.</p>
</div></td></tr><tr><td id='structfield.stderr'><a class='stability Experimental' title='Experimental'></a><code>stderr</code></td><td><div class='docblock'><p>Handle to the child&#39;s stderr, if the <code>stderr</code> field of this process&#39;s
<code>ProcessConfig</code> was <code>CreatePipe</code>. By default, this handle is <code>Some</code>.</p>
</div></td></tr><tr><td id='structfield.extra_io'><a class='stability Experimental' title='Experimental'></a><code>extra_io</code></td><td><div class='docblock'><p>Extra I/O handles as configured by the original <code>ProcessConfig</code> when
this process was created. This is by default empty.</p>
</div></td></tr></table><h2 id='methods'>Methods</h2><h3 class='impl'><a class='stability Experimental' title='Experimental'></a><code>impl <a class='struct' href='../../../std/io/process/struct.Process.html' title='std::io::process::Process'>Process</a></code></h3><div class='impl-methods'><h4 id='method.kill' class='method'><a class='stability Experimental' title='Experimental'></a><code>fn <a href='#method.kill' class='fnname'>kill</a>(id: <a class='type' href='../../../libc/types/os/arch/posix88/type.pid_t.html' title='libc::types::os::arch::posix88::pid_t'>pid_t</a>, signal: <a href='../../primitive.int.html'>int</a>) -&gt; <a class='type' href='../../../std/io/type.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;()&gt;</code></h4>
<div class='docblock'><p>Sends <code>signal</code> to another process in the system identified by <code>id</code>.</p>

<p>Note that windows doesn&#39;t quite have the same model as unix, so some
unix signals are mapped to windows signals. Notably, unix termination
signals (SIGTERM/SIGKILL/SIGINT) are translated to <code>TerminateProcess</code>.</p>

<p>Additionally, a signal number of 0 can check for existence of the target
process. Note, though, that on some platforms signals will continue to
be successfully delivered if the child has exited, but not yet been
reaped.</p>
</div><h4 id='method.id' class='method'><a class='stability Experimental' title='Experimental'></a><code>fn <a href='#method.id' class='fnname'>id</a>(&amp;self) -&gt; <a class='type' href='../../../libc/types/os/arch/posix88/type.pid_t.html' title='libc::types::os::arch::posix88::pid_t'>pid_t</a></code></h4>
<div class='docblock'><p>Returns the process id of this child process</p>
</div><h4 id='method.signal' class='method'><a class='stability Experimental' title='Experimental'></a><code>fn <a href='#method.signal' class='fnname'>signal</a>(&amp;mut self, signal: <a href='../../primitive.int.html'>int</a>) -&gt; <a class='type' href='../../../std/io/type.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;()&gt;</code></h4>
<div class='docblock'><p>Sends the specified signal to the child process, returning whether the
signal could be delivered or not.</p>

<p>Note that signal 0 is interpreted as a poll to check whether the child
process is still alive or not. If an error is returned, then the child
process has exited.</p>

<p>On some unix platforms signals will continue to be received after a
child has exited but not yet been reaped. In order to report the status
of signal delivery correctly, unix implementations may invoke
<code>waitpid()</code> with <code>WNOHANG</code> in order to reap the child as necessary.</p>

<h1 id="errors" class='section-header'><a
                           href="#errors">Errors</a></h1>
<p>If the signal delivery fails, the corresponding error is returned.</p>
</div><h4 id='method.signal_exit' class='method'><a class='stability Experimental' title='Experimental'></a><code>fn <a href='#method.signal_exit' class='fnname'>signal_exit</a>(&amp;mut self) -&gt; <a class='type' href='../../../std/io/type.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;()&gt;</code></h4>
<div class='docblock'><p>Sends a signal to this child requesting that it exits. This is
equivalent to sending a SIGTERM on unix platforms.</p>
</div><h4 id='method.signal_kill' class='method'><a class='stability Experimental' title='Experimental'></a><code>fn <a href='#method.signal_kill' class='fnname'>signal_kill</a>(&amp;mut self) -&gt; <a class='type' href='../../../std/io/type.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;()&gt;</code></h4>
<div class='docblock'><p>Sends a signal to this child forcing it to exit. This is equivalent to
sending a SIGKILL on unix platforms.</p>
</div><h4 id='method.wait' class='method'><a class='stability Experimental' title='Experimental'></a><code>fn <a href='#method.wait' class='fnname'>wait</a>(&amp;mut self) -&gt; <a class='type' href='../../../std/io/type.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;<a class='type' href='../../../std/io/process/type.ProcessExit.html' title='std::io::process::ProcessExit'>ProcessExit</a>&gt;</code></h4>
<div class='docblock'><p>Wait for the child to exit completely, returning the status that it
exited with. This function will continue to have the same return value
after it has been called at least once.</p>

<p>The stdin handle to the child process will be closed before waiting.</p>

<h1 id="errors-1" class='section-header'><a
                           href="#errors-1">Errors</a></h1>
<p>This function can fail if a timeout was previously specified via
<code>set_timeout</code> and the timeout expires before the child exits.</p>
</div><h4 id='method.set_timeout' class='method'><a class='stability Experimental' title='Experimental: the type of the timeout is likely to change'></a><code>fn <a href='#method.set_timeout' class='fnname'>set_timeout</a>(&amp;mut self, timeout_ms: <a class='type' href='../../../std/option/type.Option.html' title='std::option::Option'>Option</a>&lt;<a href='../../primitive.u64.html'>u64</a>&gt;)</code></h4>
<div class='docblock'><p>Sets a timeout, in milliseconds, for future calls to wait().</p>

<p>The argument specified is a relative distance into the future, in
milliseconds, after which any call to wait() will return immediately
with a timeout error, and all future calls to wait() will not block.</p>

<p>A value of <code>None</code> will clear any previous timeout, and a value of <code>Some</code>
will override any previously set timeout.</p>

<h1 id="example-1" class='section-header'><a
                           href="#example-1">Example</a></h1><span id='rust-example-raw-1' class='rusttest'>fn main() {
    #![allow(experimental)]
    use std::io::{Command, IoResult};
    use std::io::process::ProcessExit;
    
    fn run_gracefully(prog: &amp;str) -&gt; IoResult&lt;ProcessExit&gt; {
        let mut p = try!(Command::new(&quot;long-running-process&quot;).spawn());
    
        // give the process 10 seconds to finish completely
        p.set_timeout(Some(10_000));
        match p.wait() {
            Ok(status) =&gt; return Ok(status),
            Err(..) =&gt; {}
        }
    
        // Attempt to exit gracefully, but don&#39;t wait for it too long
        try!(p.signal_exit());
        p.set_timeout(Some(1_000));
        match p.wait() {
            Ok(status) =&gt; return Ok(status),
            Err(..) =&gt; {}
        }
    
        // Well, we did our best, forcefully kill the process
        try!(p.signal_kill());
        p.set_timeout(None);
        p.wait()
    }
}</span><pre id='rust-example-rendered-1' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::{<span class='ident'>Command</span>, <span class='ident'>IoResult</span>};
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::<span class='ident'>process</span>::<span class='ident'>ProcessExit</span>;

<span class='kw'>fn</span> <span class='ident'>run_gracefully</span>(<span class='ident'>prog</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>) <span class='op'>-&gt;</span> <span class='ident'>IoResult</span><span class='op'>&lt;</span><span class='ident'>ProcessExit</span><span class='op'>&gt;</span> {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>p</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>Command</span>::<span class='ident'>new</span>(<span class='string'>&quot;long-running-process&quot;</span>).<span class='ident'>spawn</span>());<span class='comment'>

    // give the process 10 seconds to finish completely
    </span><span class='ident'>p</span>.<span class='ident'>set_timeout</span>(<span class='prelude-val'>Some</span>(<span class='number'>10_000</span>));
    <span class='kw'>match</span> <span class='ident'>p</span>.<span class='ident'>wait</span>() {
        <span class='prelude-val'>Ok</span>(<span class='ident'>status</span>) <span class='op'>=&gt;</span> <span class='kw'>return</span> <span class='prelude-val'>Ok</span>(<span class='ident'>status</span>),
        <span class='prelude-val'>Err</span>(..) <span class='op'>=&gt;</span> {}
    }<span class='comment'>

    // Attempt to exit gracefully, but don&#39;t wait for it too long
    </span><span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>p</span>.<span class='ident'>signal_exit</span>());
    <span class='ident'>p</span>.<span class='ident'>set_timeout</span>(<span class='prelude-val'>Some</span>(<span class='number'>1_000</span>));
    <span class='kw'>match</span> <span class='ident'>p</span>.<span class='ident'>wait</span>() {
        <span class='prelude-val'>Ok</span>(<span class='ident'>status</span>) <span class='op'>=&gt;</span> <span class='kw'>return</span> <span class='prelude-val'>Ok</span>(<span class='ident'>status</span>),
        <span class='prelude-val'>Err</span>(..) <span class='op'>=&gt;</span> {}
    }<span class='comment'>

    // Well, we did our best, forcefully kill the process
    </span><span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>p</span>.<span class='ident'>signal_kill</span>());
    <span class='ident'>p</span>.<span class='ident'>set_timeout</span>(<span class='prelude-val'>None</span>);
    <span class='ident'>p</span>.<span class='ident'>wait</span>()
}
</pre>
</div><h4 id='method.wait_with_output' class='method'><a class='stability Experimental' title='Experimental'></a><code>fn <a href='#method.wait_with_output' class='fnname'>wait_with_output</a>(self) -&gt; <a class='type' href='../../../std/io/type.IoResult.html' title='std::io::IoResult'>IoResult</a>&lt;<a class='struct' href='../../../std/io/process/struct.ProcessOutput.html' title='std::io::process::ProcessOutput'>ProcessOutput</a>&gt;</code></h4>
<div class='docblock'><p>Simultaneously wait for the child to exit and collect all remaining
output on the stdout/stderr handles, returning a <code>ProcessOutput</code>
instance.</p>

<p>The stdin handle to the child is closed before waiting.</p>

<h1 id="errors-2" class='section-header'><a
                           href="#errors-2">Errors</a></h1>
<p>This function can fail for any of the same reasons that <code>wait()</code> can
fail.</p>
</div><h4 id='method.forget' class='method'><a class='stability Experimental' title='Experimental'></a><code>fn <a href='#method.forget' class='fnname'>forget</a>(self)</code></h4>
<div class='docblock'><p>Forgets this process, allowing it to outlive the parent</p>

<p>This function will forcefully prevent calling <code>wait()</code> on the child
process in the destructor, allowing the child to outlive the
parent. Note that this operation can easily lead to leaking the
resources of the child process, so care must be taken when
invoking this method.</p>
</div></div><h2 id='implementations'>Trait Implementations</h2><h3 class='impl'><a class='stability Experimental' title='Experimental'></a><code>impl <a class='trait' href='../../../std/ops/trait.Drop.html' title='std::ops::Drop'>Drop</a> for <a class='struct' href='../../../std/io/process/struct.Process.html' title='std::io::process::Process'>Process</a></code></h3><div class='impl-methods'><h4 id='method.drop' class='method'><a class='stability Experimental' title='Experimental'></a><code>fn <a href='#method.drop' class='fnname'>drop</a>(&amp;mut self)</code></h4>
</div></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <div id="help" class="hidden">
        <div class="shortcuts">
            <h1>Keyboard shortcuts</h1>
            <dl>
                <dt>?</dt>
                <dd>Show this help dialog</dd>
                <dt>S</dt>
                <dd>Focus the search field</dd>
                <dt>&larrb;</dt>
                <dd>Move up in search results</dd>
                <dt>&rarrb;</dt>
                <dd>Move down in search results</dd>
                <dt>&#9166;</dt>
                <dd>Go to active search result</dd>
            </dl>
        </div>
        <div class="infos">
            <h1>Search tricks</h1>
            <p>
                Prefix searches with a type followed by a colon (e.g.
                <code>fn:</code>) to restrict the search to a given type.
            </p>
            <p>
                Accepted types are: <code>fn</code>, <code>mod</code>,
                <code>struct</code> (or <code>str</code>), <code>enum</code>,
                <code>trait</code>, <code>typedef</code> (or
                <code>tdef</code>).
            </p>
        </div>
    </div>

    

    <script>
        window.rootPath = "../../../";
        window.currentCrate = "std";
        window.playgroundUrl = "http://play.rust-lang.org/";
    </script>
    <script src="../../../jquery.js"></script>
    <script src="../../../main.js"></script>
    <script src="../../../playpen.js"></script>
    <script async src="../../../search-index.js"></script>
</body>
</html>