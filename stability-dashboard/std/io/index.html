<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="The std library documentation.">

    <title>std::io - Rust</title>

    <link href='http://fonts.googleapis.com/css?family=Source+Code+Pro:400,600'
          rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="../../main.css">

    <link rel="shortcut icon" href="http://www.rust-lang.org/favicon.ico">
    
</head>
<body>
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <section class="sidebar">
        <a href='../../std/index.html'><img src='http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png' alt='' width='100'></a>
        <p class='location'><a href='../index.html'>std</a></p><div class='block mod'><h2>Modules</h2><a class='mod ' href='../any/index.html'>any</a><a class='mod ' href='../ascii/index.html'>ascii</a><a class='mod ' href='../bitflags/index.html'>bitflags</a><a class='mod ' href='../bool/index.html'>bool</a><a class='mod ' href='../c_str/index.html'>c_str</a><a class='mod ' href='../c_vec/index.html'>c_vec</a><a class='mod ' href='../cell/index.html'>cell</a><a class='mod ' href='../char/index.html'>char</a><a class='mod ' href='../clone/index.html'>clone</a><a class='mod ' href='../cmp/index.html'>cmp</a><a class='mod ' href='../collections/index.html'>collections</a><a class='mod ' href='../comm/index.html'>comm</a><a class='mod ' href='../default/index.html'>default</a><a class='mod ' href='../dynamic_lib/index.html'>dynamic_lib</a><a class='mod ' href='../f32/index.html'>f32</a><a class='mod ' href='../f64/index.html'>f64</a><a class='mod ' href='../finally/index.html'>finally</a><a class='mod ' href='../fmt/index.html'>fmt</a><a class='mod ' href='../from_str/index.html'>from_str</a><a class='mod ' href='../gc/index.html'>gc</a><a class='mod ' href='../hash/index.html'>hash</a><a class='mod ' href='../i16/index.html'>i16</a><a class='mod ' href='../i32/index.html'>i32</a><a class='mod ' href='../i64/index.html'>i64</a><a class='mod ' href='../i8/index.html'>i8</a><a class='mod ' href='../int/index.html'>int</a><a class='mod ' href='../intrinsics/index.html'>intrinsics</a><a class='mod current' href='../io/index.html'>io</a><a class='mod ' href='../iter/index.html'>iter</a><a class='mod ' href='../kinds/index.html'>kinds</a><a class='mod ' href='../local_data/index.html'>local_data</a><a class='mod ' href='../macros/index.html'>macros</a><a class='mod ' href='../mem/index.html'>mem</a><a class='mod ' href='../num/index.html'>num</a><a class='mod ' href='../ops/index.html'>ops</a><a class='mod ' href='../option/index.html'>option</a><a class='mod ' href='../os/index.html'>os</a><a class='mod ' href='../owned/index.html'>owned</a><a class='mod ' href='../path/index.html'>path</a><a class='mod ' href='../prelude/index.html'>prelude</a><a class='mod ' href='../ptr/index.html'>ptr</a><a class='mod ' href='../rand/index.html'>rand</a><a class='mod ' href='../raw/index.html'>raw</a><a class='mod ' href='../rc/index.html'>rc</a><a class='mod ' href='../result/index.html'>result</a><a class='mod ' href='../rt/index.html'>rt</a><a class='mod ' href='../simd/index.html'>simd</a><a class='mod ' href='../slice/index.html'>slice</a><a class='mod ' href='../str/index.html'>str</a><a class='mod ' href='../string/index.html'>string</a><a class='mod ' href='../sync/index.html'>sync</a><a class='mod ' href='../task/index.html'>task</a><a class='mod ' href='../to_str/index.html'>to_str</a><a class='mod ' href='../tuple/index.html'>tuple</a><a class='mod ' href='../ty/index.html'>ty</a><a class='mod ' href='../u16/index.html'>u16</a><a class='mod ' href='../u32/index.html'>u32</a><a class='mod ' href='../u64/index.html'>u64</a><a class='mod ' href='../u8/index.html'>u8</a><a class='mod ' href='../uint/index.html'>uint</a><a class='mod ' href='../unstable/index.html'>unstable</a><a class='mod ' href='../vec/index.html'>vec</a></div>
    </section>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press 'S' to search, '?' for more options..."
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content mod">
<h1 class='fqn'>Module <a href='../index.html'>std</a>::<a class='mod' href=''>io</a><a class='stability Experimental' title=''>Experimental</a><span class='out-of-band'><a id='src-25599' href='../../src/std/Users/aturon/moz/working/stability-dashboard/src/libstd/io/mod.rs.html#17-1931'>[src]</a></span></h1>
<div class='docblock'><p>I/O, including files, networking, timers, and processes</p>

<p><code>std::io</code> provides Rust&#39;s basic I/O types,
for reading and writing to files, TCP, UDP,
and other types of sockets and pipes,
manipulating the file system, spawning processes and signal handling.</p>

<h1 id="examples" class='section-header'><a
                           href="#examples">Examples</a></h1>
<p>Some examples of obvious things you might want to do</p>

<ul>
<li><p>Read lines from stdin</p>
<span id='rust-example-raw-0' class='rusttest'>fn main() {
    use std::io;
    
    for line in io::stdin().lines() {
        print!(&quot;{}&quot;, line.unwrap());
    }
}</span><pre id='rust-example-rendered-0' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>;

<span class='kw'>for</span> <span class='ident'>line</span> <span class='kw'>in</span> <span class='ident'>io</span>::<span class='ident'>stdin</span>().<span class='ident'>lines</span>() {
    <span class='macro'>print</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>line</span>.<span class='ident'>unwrap</span>());
}
</pre></li>
<li><p>Read a complete file</p>
<span id='rust-example-raw-1' class='rusttest'>fn main() {
    use std::io::File;
    
    let contents = File::open(&amp;Path::new(&quot;message.txt&quot;)).read_to_end();
}</span><pre id='rust-example-rendered-1' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::<span class='ident'>File</span>;

<span class='kw'>let</span> <span class='ident'>contents</span> <span class='op'>=</span> <span class='ident'>File</span>::<span class='ident'>open</span>(<span class='kw-2'>&amp;</span><span class='ident'>Path</span>::<span class='ident'>new</span>(<span class='string'>&quot;message.txt&quot;</span>)).<span class='ident'>read_to_end</span>();
</pre></li>
<li><p>Write a line to a file</p>
<span id='rust-example-raw-2' class='rusttest'>fn main() {
    #![allow(unused_must_use)]
    use std::io::File;
    
    let mut file = File::create(&amp;Path::new(&quot;message.txt&quot;));
    file.write(b&quot;hello, file!\n&quot;);
    drop(file);
    ::std::io::fs::unlink(&amp;Path::new(&quot;message.txt&quot;));
}</span><pre id='rust-example-rendered-2' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::<span class='ident'>File</span>;

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>file</span> <span class='op'>=</span> <span class='ident'>File</span>::<span class='ident'>create</span>(<span class='kw-2'>&amp;</span><span class='ident'>Path</span>::<span class='ident'>new</span>(<span class='string'>&quot;message.txt&quot;</span>));
<span class='ident'>file</span>.<span class='ident'>write</span>(<span class='string'>b&quot;hello, file!\n&quot;</span>);
</pre></li>
<li><p>Iterate over the lines of a file</p>
<span id='rust-example-raw-3' class='rusttest'>fn main() {
    use std::io::BufferedReader;
    use std::io::File;
    
    let path = Path::new(&quot;message.txt&quot;);
    let mut file = BufferedReader::new(File::open(&amp;path));
    for line in file.lines() {
        print!(&quot;{}&quot;, line.unwrap());
    }
}</span><pre id='rust-example-rendered-3' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::<span class='ident'>BufferedReader</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::<span class='ident'>File</span>;

<span class='kw'>let</span> <span class='ident'>path</span> <span class='op'>=</span> <span class='ident'>Path</span>::<span class='ident'>new</span>(<span class='string'>&quot;message.txt&quot;</span>);
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>file</span> <span class='op'>=</span> <span class='ident'>BufferedReader</span>::<span class='ident'>new</span>(<span class='ident'>File</span>::<span class='ident'>open</span>(<span class='kw-2'>&amp;</span><span class='ident'>path</span>));
<span class='kw'>for</span> <span class='ident'>line</span> <span class='kw'>in</span> <span class='ident'>file</span>.<span class='ident'>lines</span>() {
    <span class='macro'>print</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>line</span>.<span class='ident'>unwrap</span>());
}
</pre></li>
<li><p>Pull the lines of a file into a vector of strings</p>
<span id='rust-example-raw-4' class='rusttest'>fn main() {
    use std::io::BufferedReader;
    use std::io::File;
    
    let path = Path::new(&quot;message.txt&quot;);
    let mut file = BufferedReader::new(File::open(&amp;path));
    let lines: Vec&lt;String&gt; = file.lines().map(|x| x.unwrap()).collect();
}</span><pre id='rust-example-rendered-4' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::<span class='ident'>BufferedReader</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::<span class='ident'>File</span>;

<span class='kw'>let</span> <span class='ident'>path</span> <span class='op'>=</span> <span class='ident'>Path</span>::<span class='ident'>new</span>(<span class='string'>&quot;message.txt&quot;</span>);
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>file</span> <span class='op'>=</span> <span class='ident'>BufferedReader</span>::<span class='ident'>new</span>(<span class='ident'>File</span>::<span class='ident'>open</span>(<span class='kw-2'>&amp;</span><span class='ident'>path</span>));
<span class='kw'>let</span> <span class='ident'>lines</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>String</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>file</span>.<span class='ident'>lines</span>().<span class='ident'>map</span>(<span class='op'>|</span><span class='ident'>x</span><span class='op'>|</span> <span class='ident'>x</span>.<span class='ident'>unwrap</span>()).<span class='ident'>collect</span>();
</pre></li>
<li><p>Make a simple TCP client connection and request</p>
<span id='rust-example-raw-5' class='rusttest'>fn main() {
    #![allow(unused_must_use)]
    use std::io::TcpStream;
    
    // connection doesn&#39;t fail if a server is running on 8080
    // locally, we still want to be type checking this code, so lets
    // just stop it running (#11576)
    if false {
    let mut socket = TcpStream::connect(&quot;127.0.0.1&quot;, 8080).unwrap();
    socket.write(b&quot;GET / HTTP/1.0\n\n&quot;);
    let response = socket.read_to_end();
    }
}</span><pre id='rust-example-rendered-5' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::<span class='ident'>TcpStream</span>;

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>socket</span> <span class='op'>=</span> <span class='ident'>TcpStream</span>::<span class='ident'>connect</span>(<span class='string'>&quot;127.0.0.1&quot;</span>, <span class='number'>8080</span>).<span class='ident'>unwrap</span>();
<span class='ident'>socket</span>.<span class='ident'>write</span>(<span class='string'>b&quot;GET / HTTP/1.0\n\n&quot;</span>);
<span class='kw'>let</span> <span class='ident'>response</span> <span class='op'>=</span> <span class='ident'>socket</span>.<span class='ident'>read_to_end</span>();
</pre></li>
<li><p>Make a simple TCP server</p>
<span id='rust-example-raw-6' class='rusttest'>fn main() { }
fn foo() {
#![allow(dead_code)]
use std::io::{TcpListener, TcpStream};
use std::io::{Acceptor, Listener};

let listener = TcpListener::bind(&quot;127.0.0.1&quot;, 80);

// bind the listener to the specified address
let mut acceptor = listener.listen();

fn handle_client(mut stream: TcpStream) {
    // ...
&amp;mut stream; // silence unused mutability/variable warning
}
// accept connections and process them, spawning a new tasks for each one
for stream in acceptor.incoming() {
    match stream {
        Err(e) =&gt; { /* connection failed */ }
        Ok(stream) =&gt; spawn(proc() {
            // connection succeeded
            handle_client(stream)
        })
    }
}

// close the socket server
drop(acceptor);
}</span><pre id='rust-example-rendered-6' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::{<span class='ident'>TcpListener</span>, <span class='ident'>TcpStream</span>};
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::{<span class='ident'>Acceptor</span>, <span class='ident'>Listener</span>};

<span class='kw'>let</span> <span class='ident'>listener</span> <span class='op'>=</span> <span class='ident'>TcpListener</span>::<span class='ident'>bind</span>(<span class='string'>&quot;127.0.0.1&quot;</span>, <span class='number'>80</span>);<span class='comment'>

// bind the listener to the specified address
</span><span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>acceptor</span> <span class='op'>=</span> <span class='ident'>listener</span>.<span class='ident'>listen</span>();

<span class='kw'>fn</span> <span class='ident'>handle_client</span>(<span class='kw-2'>mut</span> <span class='ident'>stream</span>: <span class='ident'>TcpStream</span>) {<span class='comment'>
    // ...
</span>}<span class='comment'>
// accept connections and process them, spawning a new tasks for each one
</span><span class='kw'>for</span> <span class='ident'>stream</span> <span class='kw'>in</span> <span class='ident'>acceptor</span>.<span class='ident'>incoming</span>() {
    <span class='kw'>match</span> <span class='ident'>stream</span> {
        <span class='prelude-val'>Err</span>(<span class='ident'>e</span>) <span class='op'>=&gt;</span> {<span class='comment'> /* connection failed */ </span>}
        <span class='prelude-val'>Ok</span>(<span class='ident'>stream</span>) <span class='op'>=&gt;</span> <span class='ident'>spawn</span>(<span class='kw'>proc</span>() {<span class='comment'>
            // connection succeeded
            </span><span class='ident'>handle_client</span>(<span class='ident'>stream</span>)
        })
    }
}<span class='comment'>

// close the socket server
</span><span class='ident'>drop</span>(<span class='ident'>acceptor</span>);
</pre></li>
</ul>

<h1 id="error-handling" class='section-header'><a
                           href="#error-handling">Error Handling</a></h1>
<p>I/O is an area where nearly every operation can result in unexpected
errors. Errors should be painfully visible when they happen, and handling them
should be easy to work with. It should be convenient to handle specific I/O
errors, and it should also be convenient to not deal with I/O errors.</p>

<p>Rust&#39;s I/O employs a combination of techniques to reduce boilerplate
while still providing feedback about errors. The basic strategy:</p>

<ul>
<li>All I/O operations return <code>IoResult&lt;T&gt;</code> which is equivalent to
<code>Result&lt;T, IoError&gt;</code>. The <code>Result</code> type is defined in the <code>std::result</code>
module.</li>
<li>If the <code>Result</code> type goes unused, then the compiler will by default emit a
warning about the unused result. This is because <code>Result</code> has the
<code>#[must_use]</code> attribute.</li>
<li>Common traits are implemented for <code>IoResult</code>, e.g.
<code>impl&lt;R: Reader&gt; Reader for IoResult&lt;R&gt;</code>, so that error values do not have
to be &#39;unwrapped&#39; before use.</li>
</ul>

<p>These features combine in the API to allow for expressions like
<code>File::create(&amp;Path::new(&quot;diary.txt&quot;)).write(b&quot;Met a girl.\n&quot;)</code>
without having to worry about whether &quot;diary.txt&quot; exists or whether
the write succeeds. As written, if either <code>new</code> or <code>write_line</code>
encounters an error then the result of the entire expression will
be an error.</p>

<p>If you wanted to handle the error though you might write:</p>
<span id='rust-example-raw-7' class='rusttest'>fn main() {
    #![allow(unused_must_use)]
    use std::io::File;
    
    match File::create(&amp;Path::new(&quot;diary.txt&quot;)).write(b&quot;Met a girl.\n&quot;) {
        Ok(()) =&gt; (), // succeeded
        Err(e) =&gt; println!(&quot;failed to write to my diary: {}&quot;, e),
    }
    
    ::std::io::fs::unlink(&amp;Path::new(&quot;diary.txt&quot;));
}</span><pre id='rust-example-rendered-7' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::<span class='ident'>File</span>;

<span class='kw'>match</span> <span class='ident'>File</span>::<span class='ident'>create</span>(<span class='kw-2'>&amp;</span><span class='ident'>Path</span>::<span class='ident'>new</span>(<span class='string'>&quot;diary.txt&quot;</span>)).<span class='ident'>write</span>(<span class='string'>b&quot;Met a girl.\n&quot;</span>) {
    <span class='prelude-val'>Ok</span>(()) <span class='op'>=&gt;</span> (),<span class='comment'> // succeeded
    </span><span class='prelude-val'>Err</span>(<span class='ident'>e</span>) <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;failed to write to my diary: {}&quot;</span>, <span class='ident'>e</span>),
}
</pre>

<p>So what actually happens if <code>create</code> encounters an error?
It&#39;s important to know that what <code>new</code> returns is not a <code>File</code>
but an <code>IoResult&lt;File&gt;</code>.  If the file does not open, then <code>new</code> will simply
return <code>Err(..)</code>. Because there is an implementation of <code>Writer</code> (the trait
required ultimately required for types to implement <code>write_line</code>) there is no
need to inspect or unwrap the <code>IoResult&lt;File&gt;</code> and we simply call <code>write_line</code>
on it. If <code>new</code> returned an <code>Err(..)</code> then the followup call to <code>write_line</code>
will also return an error.</p>

<h2 id="try!" class='section-header'><a
                           href="#try!"><code>try!</code></a></h2>
<p>Explicit pattern matching on <code>IoResult</code>s can get quite verbose, especially
when performing many I/O operations. Some examples (like those above) are
alleviated with extra methods implemented on <code>IoResult</code>, but others have more
complex interdependencies among each I/O operation.</p>

<p>The <code>try!</code> macro from <code>std::macros</code> is provided as a method of early-return
inside <code>Result</code>-returning functions. It expands to an early-return on <code>Err</code>
and otherwise unwraps the contained <code>Ok</code> value.</p>

<p>If you wanted to read several <code>u32</code>s from a file and return their product:</p>
<span id='rust-example-raw-8' class='rusttest'>fn main() {
    use std::io::{File, IoResult};
    
    fn file_product(p: &amp;Path) -&gt; IoResult&lt;u32&gt; {
        let mut f = File::open(p);
        let x1 = try!(f.read_le_u32());
        let x2 = try!(f.read_le_u32());
    
        Ok(x1 * x2)
    }
    
    match file_product(&amp;Path::new(&quot;numbers.bin&quot;)) {
        Ok(x) =&gt; println!(&quot;{}&quot;, x),
        Err(e) =&gt; println!(&quot;Failed to read numbers!&quot;)
    }
}</span><pre id='rust-example-rendered-8' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::{<span class='ident'>File</span>, <span class='ident'>IoResult</span>};

<span class='kw'>fn</span> <span class='ident'>file_product</span>(<span class='ident'>p</span>: <span class='kw-2'>&amp;</span><span class='ident'>Path</span>) <span class='op'>-&gt;</span> <span class='ident'>IoResult</span><span class='op'>&lt;</span><span class='ident'>u32</span><span class='op'>&gt;</span> {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>f</span> <span class='op'>=</span> <span class='ident'>File</span>::<span class='ident'>open</span>(<span class='ident'>p</span>);
    <span class='kw'>let</span> <span class='ident'>x1</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>f</span>.<span class='ident'>read_le_u32</span>());
    <span class='kw'>let</span> <span class='ident'>x2</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>f</span>.<span class='ident'>read_le_u32</span>());

    <span class='prelude-val'>Ok</span>(<span class='ident'>x1</span> <span class='op'>*</span> <span class='ident'>x2</span>)
}

<span class='kw'>match</span> <span class='ident'>file_product</span>(<span class='kw-2'>&amp;</span><span class='ident'>Path</span>::<span class='ident'>new</span>(<span class='string'>&quot;numbers.bin&quot;</span>)) {
    <span class='prelude-val'>Ok</span>(<span class='ident'>x</span>) <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>x</span>),
    <span class='prelude-val'>Err</span>(<span class='ident'>e</span>) <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Failed to read numbers!&quot;</span>)
}
</pre>

<p>With <code>try!</code> in <code>file_product</code>, each <code>read_le_u32</code> need not be directly
concerned with error handling; instead its caller is responsible for
responding to errors that may occur while attempting to read the numbers.</p>
</div><h2 id='reexports' class='section-header'><a href="#reexports">Reexports</a></h2>
<table><tr><td><code>pub use self::<a class='mod'
                                            href='./stdio/index.html'>stdio</a>::<a class='fn' href='../../std/io/stdio/fn.stdin.html' title='std::io::stdio::stdin'>stdin</a>;</code></td></tr><tr><td><code>pub use self::<a class='mod'
                                            href='./stdio/index.html'>stdio</a>::<a class='fn' href='../../std/io/stdio/fn.stdout.html' title='std::io::stdio::stdout'>stdout</a>;</code></td></tr><tr><td><code>pub use self::<a class='mod'
                                            href='./stdio/index.html'>stdio</a>::<a class='fn' href='../../std/io/stdio/fn.stderr.html' title='std::io::stdio::stderr'>stderr</a>;</code></td></tr><tr><td><code>pub use self::<a class='mod'
                                            href='./stdio/index.html'>stdio</a>::<a class='fn' href='../../std/io/stdio/fn.print.html' title='std::io::stdio::print'>print</a>;</code></td></tr><tr><td><code>pub use self::<a class='mod'
                                            href='./stdio/index.html'>stdio</a>::<a class='fn' href='../../std/io/stdio/fn.println.html' title='std::io::stdio::println'>println</a>;</code></td></tr><tr><td><code>pub use self::<a class='mod'
                                            href='./fs/index.html'>fs</a>::<a class='struct' href='../../std/io/fs/struct.File.html' title='std::io::fs::File'>File</a>;</code></td></tr><tr><td><code>pub use self::<a class='mod'
                                            href='./timer/index.html'>timer</a>::<a class='struct' href='../../std/io/timer/struct.Timer.html' title='std::io::timer::Timer'>Timer</a>;</code></td></tr><tr><td><code>pub use self::<a class='mod'
                                            href='./net/index.html'>net</a>::<a class='mod'
                                            href='./net/ip/index.html'>ip</a>::<a class='type' href='../../std/io/net/ip/type.IpAddr.html' title='std::io::net::ip::IpAddr'>IpAddr</a>;</code></td></tr><tr><td><code>pub use self::<a class='mod'
                                            href='./net/index.html'>net</a>::<a class='mod'
                                            href='./net/tcp/index.html'>tcp</a>::<a class='struct' href='../../std/io/net/tcp/struct.TcpListener.html' title='std::io::net::tcp::TcpListener'>TcpListener</a>;</code></td></tr><tr><td><code>pub use self::<a class='mod'
                                            href='./net/index.html'>net</a>::<a class='mod'
                                            href='./net/tcp/index.html'>tcp</a>::<a class='struct' href='../../std/io/net/tcp/struct.TcpStream.html' title='std::io::net::tcp::TcpStream'>TcpStream</a>;</code></td></tr><tr><td><code>pub use self::<a class='mod'
                                            href='./net/index.html'>net</a>::<a class='mod'
                                            href='./net/udp/index.html'>udp</a>::<a class='struct' href='../../std/io/net/udp/struct.UdpStream.html' title='std::io::net::udp::UdpStream'>UdpStream</a>;</code></td></tr><tr><td><code>pub use self::<a class='mod'
                                            href='./pipe/index.html'>pipe</a>::<a class='struct' href='../../std/io/pipe/struct.PipeStream.html' title='std::io::pipe::PipeStream'>PipeStream</a>;</code></td></tr><tr><td><code>pub use self::process::{<a class='struct' href='../../std/io/process/struct.Process.html' title='std::io::process::Process'>Process</a>, <a class='struct' href='../../std/io/process/struct.Command.html' title='std::io::process::Command'>Command</a>};</code></td></tr></table><h2 id='modules' class='section-header'><a href="#modules">Modules</a></h2>
<table>
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='mod' href='extensions/index.html'
                               title='std::io::extensions'>extensions</a></td>
                        <td class='docblock short'><p>Utility mixins that apply to all Readers and Writers</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='mod' href='fs/index.html'
                               title='std::io::fs'>fs</a></td>
                        <td class='docblock short'><p>Synchronous File I/O</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='mod' href='net/index.html'
                               title='std::io::net'>net</a></td>
                        <td class='docblock short'><p>Networking I/O</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='mod' href='pipe/index.html'
                               title='std::io::pipe'>pipe</a></td>
                        <td class='docblock short'><p>Synchronous, in-memory pipes.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='mod' href='process/index.html'
                               title='std::io::process'>process</a></td>
                        <td class='docblock short'><p>Bindings for executing child processes</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='mod' href='signal/index.html'
                               title='std::io::signal'>signal</a></td>
                        <td class='docblock short'><p>Signal handling</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='mod' href='stdio/index.html'
                               title='std::io::stdio'>stdio</a></td>
                        <td class='docblock short'><p>Non-blocking access to stdin, stdout, and stderr.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='mod' href='test/index.html'
                               title='std::io::test'>test</a></td>
                        <td class='docblock short'><p>Various utility functions useful for writing I/O tests</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='mod' href='timer/index.html'
                               title='std::io::timer'>timer</a></td>
                        <td class='docblock short'><p>Synchronous Timers</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='mod' href='util/index.html'
                               title='std::io::util'>util</a></td>
                        <td class='docblock short'><p>Utility implementations of Reader and Writer</p>
</td>
                    </tr>
                </table><h2 id='structs' class='section-header'><a href="#structs">Structs</a></h2>
<table>
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='struct' href='struct.BufReader.html'
                               title='std::io::BufReader'>BufReader</a></td>
                        <td class='docblock short'><p>Reads from a fixed-size byte slice</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='struct' href='struct.BufWriter.html'
                               title='std::io::BufWriter'>BufWriter</a></td>
                        <td class='docblock short'><p>Writes to a fixed-size byte slice</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='struct' href='struct.BufferedReader.html'
                               title='std::io::BufferedReader'>BufferedReader</a></td>
                        <td class='docblock short'><p>Wraps a Reader and buffers input from it</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='struct' href='struct.BufferedStream.html'
                               title='std::io::BufferedStream'>BufferedStream</a></td>
                        <td class='docblock short'><p>Wraps a Stream and buffers input and output to and from it.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='struct' href='struct.BufferedWriter.html'
                               title='std::io::BufferedWriter'>BufferedWriter</a></td>
                        <td class='docblock short'><p>Wraps a Writer and buffers output to it</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='struct' href='struct.ChanReader.html'
                               title='std::io::ChanReader'>ChanReader</a></td>
                        <td class='docblock short'><p>Allows reading from a rx.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='struct' href='struct.ChanWriter.html'
                               title='std::io::ChanWriter'>ChanWriter</a></td>
                        <td class='docblock short'><p>Allows writing to a tx.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='struct' href='struct.Chars.html'
                               title='std::io::Chars'>Chars</a></td>
                        <td class='docblock short'><p>An iterator that reads a utf8-encoded character on each iteration,
until <code>.read_char()</code> encounters <code>EndOfFile</code>.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='struct' href='struct.FilePermission.html'
                               title='std::io::FilePermission'>FilePermission</a></td>
                        <td class='docblock short'><p>A set of permissions for a file or directory is represented
by a set of flags which are or&#39;d together.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='struct' href='struct.FileStat.html'
                               title='std::io::FileStat'>FileStat</a></td>
                        <td class='docblock short'><p>A structure used to describe metadata information about a file. This
structure is created through the <code>stat</code> method on a <code>Path</code>.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='struct' href='struct.IncomingConnections.html'
                               title='std::io::IncomingConnections'>IncomingConnections</a></td>
                        <td class='docblock short'><p>An infinite iterator over incoming connection attempts.
Calling <code>next</code> will block the task until a connection is attempted.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='struct' href='struct.IoError.html'
                               title='std::io::IoError'>IoError</a></td>
                        <td class='docblock short'><p>The type passed to I/O condition handlers to indicate error</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='struct' href='struct.LineBufferedWriter.html'
                               title='std::io::LineBufferedWriter'>LineBufferedWriter</a></td>
                        <td class='docblock short'><p>Wraps a Writer and buffers output to it, flushing whenever a newline (<code>0x0a</code>,
<code>&#39;\n&#39;</code>) is detected.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='struct' href='struct.Lines.html'
                               title='std::io::Lines'>Lines</a></td>
                        <td class='docblock short'><p>An iterator that reads a line on each iteration,
until <code>.read_line()</code> encounters <code>EndOfFile</code>.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='struct' href='struct.MemReader.html'
                               title='std::io::MemReader'>MemReader</a></td>
                        <td class='docblock short'><p>Reads from an owned byte vector</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='struct' href='struct.MemWriter.html'
                               title='std::io::MemWriter'>MemWriter</a></td>
                        <td class='docblock short'><p>Writes to an owned, growable byte vector</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='struct' href='struct.RefReader.html'
                               title='std::io::RefReader'>RefReader</a></td>
                        <td class='docblock short'><p>A <code>RefReader</code> is a struct implementing <code>Reader</code> which contains a reference
to another reader. This is often useful when composing streams.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='struct' href='struct.RefWriter.html'
                               title='std::io::RefWriter'>RefWriter</a></td>
                        <td class='docblock short'><p>A <code>RefWriter</code> is a struct implementing <code>Writer</code> which contains a reference
to another writer. This is often useful when composing streams.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='struct' href='struct.TempDir.html'
                               title='std::io::TempDir'>TempDir</a></td>
                        <td class='docblock short'><p>A wrapper for a path to temporary directory implementing automatic
scope-based deletion.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Unstable' title='Unstable'></a><a class='struct' href='struct.UnstableFileStat.html'
                               title='std::io::UnstableFileStat'>UnstableFileStat</a></td>
                        <td class='docblock short'><p>This structure represents all of the possible information which can be
returned from a <code>stat</code> syscall which is not contained in the <code>FileStat</code>
structure. This information is not necessarily platform independent, and may
have different meanings or no meaning at all on some platforms.</p>
</td>
                    </tr>
                </table><h2 id='enums' class='section-header'><a href="#enums">Enums</a></h2>
<table>
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='type' href='type.FileAccess.html'
                               title='std::io::FileAccess'>FileAccess</a></td>
                        <td class='docblock short'><p>Access permissions with which the file should be opened. <code>File</code>s
opened with <code>Read</code> will return an error if written to.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='type' href='type.FileMode.html'
                               title='std::io::FileMode'>FileMode</a></td>
                        <td class='docblock short'><p>A mode specifies how a file should be opened or created. These modes are
passed to <code>File::open_mode</code> and are used to control where the file is
positioned when it is initially opened.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='type' href='type.FileType.html'
                               title='std::io::FileType'>FileType</a></td>
                        <td class='docblock short'><p>Different kinds of files which can be identified by a call to stat</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='type' href='type.IoErrorKind.html'
                               title='std::io::IoErrorKind'>IoErrorKind</a></td>
                        <td class='docblock short'><p>A list specifying general categories of I/O error.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='type' href='type.SeekStyle.html'
                               title='std::io::SeekStyle'>SeekStyle</a></td>
                        <td class='docblock short'><p>When seeking, the resulting cursor is offset from a base by the offset given
to the <code>seek</code> function. The base used is specified by this enumeration.</p>
</td>
                    </tr>
                </table><h2 id='statics' class='section-header'><a href="#statics">Statics</a></h2>
<table>
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><code>pub static AllPermissions: <a class='struct' href='../../std/io/struct.FilePermission.html' title='std::io::FilePermission'>FilePermission</a></code><code> = </code><code>BitFlags { bits: $value }</code></td>
                        <td class='docblock'><p>All possible permissions enabled.</p>
&nbsp;</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><code>pub static GroupExecute: <a class='struct' href='../../std/io/struct.FilePermission.html' title='std::io::FilePermission'>FilePermission</a></code><code> = </code><code>BitFlags { bits: $value }</code></td>
                        <td class='docblock'>&nbsp;</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><code>pub static GroupRWX: <a class='struct' href='../../std/io/struct.FilePermission.html' title='std::io::FilePermission'>FilePermission</a></code><code> = </code><code>BitFlags { bits: $value }</code></td>
                        <td class='docblock'>&nbsp;</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><code>pub static GroupRead: <a class='struct' href='../../std/io/struct.FilePermission.html' title='std::io::FilePermission'>FilePermission</a></code><code> = </code><code>BitFlags { bits: $value }</code></td>
                        <td class='docblock'>&nbsp;</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><code>pub static GroupWrite: <a class='struct' href='../../std/io/struct.FilePermission.html' title='std::io::FilePermission'>FilePermission</a></code><code> = </code><code>BitFlags { bits: $value }</code></td>
                        <td class='docblock'>&nbsp;</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><code>pub static OtherExecute: <a class='struct' href='../../std/io/struct.FilePermission.html' title='std::io::FilePermission'>FilePermission</a></code><code> = </code><code>BitFlags { bits: $value }</code></td>
                        <td class='docblock'>&nbsp;</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><code>pub static OtherRWX: <a class='struct' href='../../std/io/struct.FilePermission.html' title='std::io::FilePermission'>FilePermission</a></code><code> = </code><code>BitFlags { bits: $value }</code></td>
                        <td class='docblock'>&nbsp;</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><code>pub static OtherRead: <a class='struct' href='../../std/io/struct.FilePermission.html' title='std::io::FilePermission'>FilePermission</a></code><code> = </code><code>BitFlags { bits: $value }</code></td>
                        <td class='docblock'>&nbsp;</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><code>pub static OtherWrite: <a class='struct' href='../../std/io/struct.FilePermission.html' title='std::io::FilePermission'>FilePermission</a></code><code> = </code><code>BitFlags { bits: $value }</code></td>
                        <td class='docblock'>&nbsp;</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><code>pub static UserDir: <a class='struct' href='../../std/io/struct.FilePermission.html' title='std::io::FilePermission'>FilePermission</a></code><code> = </code><code>BitFlags { bits: $value }</code></td>
                        <td class='docblock'><p>Permissions for user owned directories, equivalent to 0755 on
unix-like systems.</p>
&nbsp;</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><code>pub static UserExec: <a class='struct' href='../../std/io/struct.FilePermission.html' title='std::io::FilePermission'>FilePermission</a></code><code> = </code><code>BitFlags { bits: $value }</code></td>
                        <td class='docblock'><p>Permissions for user owned executables, equivalent to 0755
on unix-like systems.</p>
&nbsp;</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><code>pub static UserExecute: <a class='struct' href='../../std/io/struct.FilePermission.html' title='std::io::FilePermission'>FilePermission</a></code><code> = </code><code>BitFlags { bits: $value }</code></td>
                        <td class='docblock'>&nbsp;</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><code>pub static UserFile: <a class='struct' href='../../std/io/struct.FilePermission.html' title='std::io::FilePermission'>FilePermission</a></code><code> = </code><code>BitFlags { bits: $value }</code></td>
                        <td class='docblock'><p>Permissions for user owned files, equivalent to 0644 on
unix-like systems.</p>
&nbsp;</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><code>pub static UserRWX: <a class='struct' href='../../std/io/struct.FilePermission.html' title='std::io::FilePermission'>FilePermission</a></code><code> = </code><code>BitFlags { bits: $value }</code></td>
                        <td class='docblock'>&nbsp;</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><code>pub static UserRead: <a class='struct' href='../../std/io/struct.FilePermission.html' title='std::io::FilePermission'>FilePermission</a></code><code> = </code><code>BitFlags { bits: $value }</code></td>
                        <td class='docblock'>&nbsp;</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><code>pub static UserWrite: <a class='struct' href='../../std/io/struct.FilePermission.html' title='std::io::FilePermission'>FilePermission</a></code><code> = </code><code>BitFlags { bits: $value }</code></td>
                        <td class='docblock'>&nbsp;</td>
                    </tr>
                </table><h2 id='traits' class='section-header'><a href="#traits">Traits</a></h2>
<table>
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='trait' href='trait.Acceptor.html'
                               title='std::io::Acceptor'>Acceptor</a></td>
                        <td class='docblock short'><p>An acceptor is a value that presents incoming connections</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='trait' href='trait.Buffer.html'
                               title='std::io::Buffer'>Buffer</a></td>
                        <td class='docblock short'><p>A Buffer is a type of reader which has some form of internal buffering to
allow certain kinds of reading operations to be more optimized than others.
This type extends the <code>Reader</code> trait with a few methods that are not
possible to reasonably implement with purely a read interface.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='trait' href='trait.Listener.html'
                               title='std::io::Listener'>Listener</a></td>
                        <td class='docblock short'><p>A listener is a value that can consume itself to start listening for
connections.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='trait' href='trait.Reader.html'
                               title='std::io::Reader'>Reader</a></td>
                        <td class='docblock short'><p>A trait for objects which are byte-oriented streams. Readers are defined by
one method, <code>read</code>. This function will block until data is available,
filling in the provided buffer with any data read.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='trait' href='trait.Seek.html'
                               title='std::io::Seek'>Seek</a></td>
                        <td class='docblock short'><p>An object implementing <code>Seek</code> internally has some form of cursor which can
be moved within a stream of bytes. The stream typically has a fixed size,
allowing seeking relative to either end.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='trait' href='trait.Stream.html'
                               title='std::io::Stream'>Stream</a></td>
                        <td class='docblock short'><p>A Stream is a readable and a writable object. Data written is typically
received by the object which reads receive data from.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='trait' href='trait.UpdateIoError.html'
                               title='std::io::UpdateIoError'>UpdateIoError</a></td>
                        <td class='docblock short'><p>A trait that lets you add a <code>detail</code> to an IoError easily</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='trait' href='trait.Writer.html'
                               title='std::io::Writer'>Writer</a></td>
                        <td class='docblock short'><p>A trait for objects which are byte-oriented streams. Writers are defined by
one method, <code>write</code>. This function will block until the provided buffer of
bytes has been entirely written, and it will return any failures which occur.</p>
</td>
                    </tr>
                </table><h2 id='functions' class='section-header'><a href="#functions">Functions</a></h2>
<table>
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='fn' href='fn.standard_error.html'
                               title='std::io::standard_error'>standard_error</a></td>
                        <td class='docblock short'><p>Creates a standard error for a commonly used flavor of error. The <code>detail</code>
field of the returned error will always be <code>None</code>.</p>
</td>
                    </tr>
                </table><h2 id='types' class='section-header'><a href="#types">Type Definitions</a></h2>
<table>
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='type' href='type.IoResult.html'
                               title='std::io::IoResult'>IoResult</a></td>
                        <td class='docblock short'><p>A convenient typedef of the return value of any I/O action.</p>
</td>
                    </tr>
                </table></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <div id="help" class="hidden">
        <div class="shortcuts">
            <h1>Keyboard shortcuts</h1>
            <dl>
                <dt>?</dt>
                <dd>Show this help dialog</dd>
                <dt>S</dt>
                <dd>Focus the search field</dd>
                <dt>&larrb;</dt>
                <dd>Move up in search results</dd>
                <dt>&rarrb;</dt>
                <dd>Move down in search results</dd>
                <dt>&#9166;</dt>
                <dd>Go to active search result</dd>
            </dl>
        </div>
        <div class="infos">
            <h1>Search tricks</h1>
            <p>
                Prefix searches with a type followed by a colon (e.g.
                <code>fn:</code>) to restrict the search to a given type.
            </p>
            <p>
                Accepted types are: <code>fn</code>, <code>mod</code>,
                <code>struct</code> (or <code>str</code>), <code>enum</code>,
                <code>trait</code>, <code>typedef</code> (or
                <code>tdef</code>).
            </p>
        </div>
    </div>

    

    <script>
        window.rootPath = "../../";
        window.currentCrate = "std";
        window.playgroundUrl = "http://play.rust-lang.org/";
    </script>
    <script src="../../jquery.js"></script>
    <script src="../../main.js"></script>
    <script src="../../playpen.js"></script>
    <script async src="../../search-index.js"></script>
</body>
</html>