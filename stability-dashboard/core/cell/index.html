<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="The core library documentation.">

    <title>core::cell - Rust</title>

    <link href='http://fonts.googleapis.com/css?family=Source+Code+Pro:400,600'
          rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="../../main.css">

    <link rel="shortcut icon" href="http://www.rust-lang.org/favicon.ico">
    
</head>
<body>
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <section class="sidebar">
        <a href='../../core/index.html'><img src='http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png' alt='' width='100'></a>
        <p class='location'><a href='../index.html'>core</a></p><div class='block mod'><h2>Modules</h2><a class='mod ' href='../any/index.html'>any</a><a class='mod ' href='../atomics/index.html'>atomics</a><a class='mod ' href='../bool/index.html'>bool</a><a class='mod current' href='../cell/index.html'>cell</a><a class='mod ' href='../char/index.html'>char</a><a class='mod ' href='../clone/index.html'>clone</a><a class='mod ' href='../cmp/index.html'>cmp</a><a class='mod ' href='../collections/index.html'>collections</a><a class='mod ' href='../default/index.html'>default</a><a class='mod ' href='../f32/index.html'>f32</a><a class='mod ' href='../f64/index.html'>f64</a><a class='mod ' href='../failure/index.html'>failure</a><a class='mod ' href='../finally/index.html'>finally</a><a class='mod ' href='../fmt/index.html'>fmt</a><a class='mod ' href='../i16/index.html'>i16</a><a class='mod ' href='../i32/index.html'>i32</a><a class='mod ' href='../i64/index.html'>i64</a><a class='mod ' href='../i8/index.html'>i8</a><a class='mod ' href='../int/index.html'>int</a><a class='mod ' href='../intrinsics/index.html'>intrinsics</a><a class='mod ' href='../iter/index.html'>iter</a><a class='mod ' href='../kinds/index.html'>kinds</a><a class='mod ' href='../mem/index.html'>mem</a><a class='mod ' href='../num/index.html'>num</a><a class='mod ' href='../ops/index.html'>ops</a><a class='mod ' href='../option/index.html'>option</a><a class='mod ' href='../prelude/index.html'>prelude</a><a class='mod ' href='../ptr/index.html'>ptr</a><a class='mod ' href='../raw/index.html'>raw</a><a class='mod ' href='../result/index.html'>result</a><a class='mod ' href='../simd/index.html'>simd</a><a class='mod ' href='../slice/index.html'>slice</a><a class='mod ' href='../str/index.html'>str</a><a class='mod ' href='../tuple/index.html'>tuple</a><a class='mod ' href='../ty/index.html'>ty</a><a class='mod ' href='../u16/index.html'>u16</a><a class='mod ' href='../u32/index.html'>u32</a><a class='mod ' href='../u64/index.html'>u64</a><a class='mod ' href='../u8/index.html'>u8</a><a class='mod ' href='../uint/index.html'>uint</a></div>
    </section>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press 'S' to search, '?' for more options..."
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content mod">
<h1 class='fqn'>Module <a href='../index.html'>core</a>::<a class='mod' href=''>cell</a><a class='stability Experimental' title=''>Experimental</a><span class='out-of-band'><a id='src-82170' href='../../src/core/Users/aturon/moz/working/stability-dashboard/src/libcore/cell.rs.html#11-385'>[src]</a></span></h1>
<div class='docblock'><p>Shareable mutable containers.</p>

<p>Values of the <code>Cell</code> and <code>RefCell</code> types may be mutated through
shared references (i.e. the common <code>&amp;T</code> type), whereas most Rust
types can only be mutated through unique (<code>&amp;mut T</code>) references. We
say that <code>Cell</code> and <code>RefCell</code> provide <em>interior mutability</em>, in
contrast with typical Rust types that exhibit <em>inherited
mutability</em>.</p>

<p>Cell types come in two flavors: <code>Cell</code> and <code>RefCell</code>. <code>Cell</code>
provides <code>get</code> and <code>set</code> methods that change the
interior value with a single method call. <code>Cell</code> though is only
compatible with types that implement <code>Copy</code>. For other types,
one must use the <code>RefCell</code> type, acquiring a write lock before
mutating.</p>

<p><code>RefCell</code> uses Rust&#39;s lifetimes to implement <em>dynamic borrowing</em>,
a process whereby one can claim temporary, exclusive, mutable
access to the inner value. Borrows for <code>RefCell</code>s are tracked <em>at
runtime</em>, unlike Rust&#39;s native reference types which are entirely
tracked statically, at compile time. Because <code>RefCell</code> borrows are
dynamic it is possible to attempt to borrow a value that is
already mutably borrowed; when this happens it results in task
failure.</p>

<h1 id="when-to-choose-interior-mutability" class='section-header'><a
                           href="#when-to-choose-interior-mutability">When to choose interior mutability</a></h1>
<p>The more common inherited mutability, where one must have unique
access to mutate a value, is one of the key language elements that
enables Rust to reason strongly about pointer aliasing, statically
preventing crash bugs. Because of that, inherited mutability is
preferred, and interior mutability is something of a last
resort. Since cell types enable mutation where it would otherwise
be disallowed though, there are occasions when interior
mutability might be appropriate, or even <em>must</em> be used, e.g.</p>

<ul>
<li>Introducing inherited mutability roots to shared types.</li>
<li>Implementation details of logically-immutable methods.</li>
<li>Mutating implementations of <code>clone</code>.</li>
</ul>

<h2 id="introducing-inherited-mutability-roots-to-shared-types" class='section-header'><a
                           href="#introducing-inherited-mutability-roots-to-shared-types">Introducing inherited mutability roots to shared types</a></h2>
<p>Shared smart pointer types, including <code>Rc</code> and <code>Arc</code>, provide
containers that can be cloned and shared between multiple parties.
Because the contained values may be multiply-aliased, they can
only be borrowed as shared references, not mutable references.
Without cells it would be impossible to mutate data inside of
shared boxes at all!</p>

<p>It&#39;s very common then to put a <code>RefCell</code> inside shared pointer
types to reintroduce mutability:</p>
<span id='rust-example-raw-0' class='rusttest'>use std::collections::HashMap;
use std::cell::RefCell;
use std::rc::Rc;

fn main() {
    let shared_map: Rc&lt;RefCell&lt;_&gt;&gt; = Rc::new(RefCell::new(HashMap::new()));
    shared_map.borrow_mut().insert(&quot;africa&quot;, 92388i);
    shared_map.borrow_mut().insert(&quot;kyoto&quot;, 11837i);
    shared_map.borrow_mut().insert(&quot;piccadilly&quot;, 11826i);
    shared_map.borrow_mut().insert(&quot;marbles&quot;, 38i);
}</span><pre id='rust-example-rendered-0' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>collections</span>::<span class='ident'>HashMap</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>cell</span>::<span class='ident'>RefCell</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>rc</span>::<span class='ident'>Rc</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>shared_map</span>: <span class='ident'>Rc</span><span class='op'>&lt;</span><span class='ident'>RefCell</span><span class='op'>&lt;</span>_<span class='op'>&gt;&gt;</span> <span class='op'>=</span> <span class='ident'>Rc</span>::<span class='ident'>new</span>(<span class='ident'>RefCell</span>::<span class='ident'>new</span>(<span class='ident'>HashMap</span>::<span class='ident'>new</span>()));
    <span class='ident'>shared_map</span>.<span class='ident'>borrow_mut</span>().<span class='ident'>insert</span>(<span class='string'>&quot;africa&quot;</span>, <span class='number'>92388i</span>);
    <span class='ident'>shared_map</span>.<span class='ident'>borrow_mut</span>().<span class='ident'>insert</span>(<span class='string'>&quot;kyoto&quot;</span>, <span class='number'>11837i</span>);
    <span class='ident'>shared_map</span>.<span class='ident'>borrow_mut</span>().<span class='ident'>insert</span>(<span class='string'>&quot;piccadilly&quot;</span>, <span class='number'>11826i</span>);
    <span class='ident'>shared_map</span>.<span class='ident'>borrow_mut</span>().<span class='ident'>insert</span>(<span class='string'>&quot;marbles&quot;</span>, <span class='number'>38i</span>);
}
</pre>

<h2 id="implementation-details-of-logically-immutable-methods" class='section-header'><a
                           href="#implementation-details-of-logically-immutable-methods">Implementation details of logically-immutable methods</a></h2>
<p>Occasionally it may be desirable not to expose in an API that
there is mutation happening &quot;under the hood&quot;. This may be because
logically the operation is immutable, but e.g. caching forces the
implementation to perform mutation; or because you must employ
mutation to implement a trait method that was originally defined
to take <code>&amp;self</code>.</p>
<span id='rust-example-raw-1' class='rusttest'>use std::cell::RefCell;

struct Graph {
    edges: Vec&lt;(uint, uint)&gt;,
    span_tree_cache: RefCell&lt;Option&lt;Vec&lt;(uint, uint)&gt;&gt;&gt;
}

impl Graph {
    fn minimum_spanning_tree(&amp;self) -&gt; Vec&lt;(uint, uint)&gt; {
        // Create a new scope to contain the lifetime of the
        // dynamic borrow
        {
            // Take a reference to the inside of cache cell
            let mut cache = self.span_tree_cache.borrow_mut();
            if cache.is_some() {
                return cache.get_ref().clone();
            }

            let span_tree = self.calc_span_tree();
            *cache = Some(span_tree);
        }

        // Recursive call to return the just-cached value.
        // Note that if we had not let the previous borrow
        // of the cache fall out of scope then the subsequent
        // recursive borrow would cause a dynamic task failure.
        // This is the major hazard of using `RefCell`.
        self.minimum_spanning_tree()
    }
  fn calc_span_tree(&amp;self) -&gt; Vec&lt;(uint, uint)&gt; { vec![] }
}
fn main() { }</span><pre id='rust-example-rendered-1' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>cell</span>::<span class='ident'>RefCell</span>;

<span class='kw'>struct</span> <span class='ident'>Graph</span> {
    <span class='ident'>edges</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span>(<span class='ident'>uint</span>, <span class='ident'>uint</span>)<span class='op'>&gt;</span>,
    <span class='ident'>span_tree_cache</span>: <span class='ident'>RefCell</span><span class='op'>&lt;</span><span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>Vec</span><span class='op'>&lt;</span>(<span class='ident'>uint</span>, <span class='ident'>uint</span>)<span class='op'>&gt;&gt;</span><span class='op'>&gt;</span>
}

<span class='kw'>impl</span> <span class='ident'>Graph</span> {
    <span class='kw'>fn</span> <span class='ident'>minimum_spanning_tree</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>Vec</span><span class='op'>&lt;</span>(<span class='ident'>uint</span>, <span class='ident'>uint</span>)<span class='op'>&gt;</span> {<span class='comment'>
        // Create a new scope to contain the lifetime of the
        // dynamic borrow
        </span>{<span class='comment'>
            // Take a reference to the inside of cache cell
            </span><span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>cache</span> <span class='op'>=</span> <span class='self'>self</span>.<span class='ident'>span_tree_cache</span>.<span class='ident'>borrow_mut</span>();
            <span class='kw'>if</span> <span class='ident'>cache</span>.<span class='ident'>is_some</span>() {
                <span class='kw'>return</span> <span class='ident'>cache</span>.<span class='ident'>get_ref</span>().<span class='ident'>clone</span>();
            }

            <span class='kw'>let</span> <span class='ident'>span_tree</span> <span class='op'>=</span> <span class='self'>self</span>.<span class='ident'>calc_span_tree</span>();
            <span class='op'>*</span><span class='ident'>cache</span> <span class='op'>=</span> <span class='prelude-val'>Some</span>(<span class='ident'>span_tree</span>);
        }<span class='comment'>

        // Recursive call to return the just-cached value.
        // Note that if we had not let the previous borrow
        // of the cache fall out of scope then the subsequent
        // recursive borrow would cause a dynamic task failure.
        // This is the major hazard of using `RefCell`.
        </span><span class='self'>self</span>.<span class='ident'>minimum_spanning_tree</span>()
    }
}
</pre>

<h2 id="mutating-implementations-of-clone" class='section-header'><a
                           href="#mutating-implementations-of-clone">Mutating implementations of <code>clone</code></a></h2>
<p>This is simply a special - but common - case of the previous:
hiding mutability for operations that appear to be immutable.
The <code>clone</code> method is expected to not change the source value, and
is declared to take <code>&amp;self</code>, not <code>&amp;mut self</code>. Therefore any
mutation that happens in the <code>clone</code> method must use cell
types. For example, <code>Rc</code> maintains its reference counts within a
<code>Cell</code>.</p>
<span id='rust-example-raw-2' class='rusttest'>fn main() {
    use std::cell::Cell;
    
    struct Rc&lt;T&gt; {
        ptr: *mut RcBox&lt;T&gt;
    }
    
    struct RcBox&lt;T&gt; {
        value: T,
        refcount: Cell&lt;uint&gt;
    }
    
    impl&lt;T&gt; Clone for Rc&lt;T&gt; {
        fn clone(&amp;self) -&gt; Rc&lt;T&gt; {
            unsafe {
                (*self.ptr).refcount.set((*self.ptr).refcount.get() + 1);
                Rc { ptr: self.ptr }
            }
        }
    }
}</span><pre id='rust-example-rendered-2' class='rust '>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>cell</span>::<span class='ident'>Cell</span>;

<span class='kw'>struct</span> <span class='ident'>Rc</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='ident'>ptr</span>: <span class='op'>*</span><span class='kw-2'>mut</span> <span class='ident'>RcBox</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>
}

<span class='kw'>struct</span> <span class='ident'>RcBox</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='ident'>value</span>: <span class='ident'>T</span>,
    <span class='ident'>refcount</span>: <span class='ident'>Cell</span><span class='op'>&lt;</span><span class='ident'>uint</span><span class='op'>&gt;</span>
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='ident'>Clone</span> <span class='kw'>for</span> <span class='ident'>Rc</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>fn</span> <span class='ident'>clone</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>Rc</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
        <span class='kw'>unsafe</span> {
            (<span class='op'>*</span><span class='self'>self</span>.<span class='ident'>ptr</span>).<span class='ident'>refcount</span>.<span class='ident'>set</span>((<span class='op'>*</span><span class='self'>self</span>.<span class='ident'>ptr</span>).<span class='ident'>refcount</span>.<span class='ident'>get</span>() <span class='op'>+</span> <span class='number'>1</span>);
            <span class='ident'>Rc</span> { <span class='ident'>ptr</span>: <span class='self'>self</span>.<span class='ident'>ptr</span> }
        }
    }
}
</pre>
</div><h2 id='structs' class='section-header'><a href="#structs">Structs</a></h2>
<table>
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='struct' href='struct.Cell.html'
                               title='core::cell::Cell'>Cell</a></td>
                        <td class='docblock short'><p>A mutable memory location that admits only <code>Copy</code> data.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='struct' href='struct.Ref.html'
                               title='core::cell::Ref'>Ref</a></td>
                        <td class='docblock short'><p>Wraps a borrowed reference to a value in a <code>RefCell</code> box.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='struct' href='struct.RefCell.html'
                               title='core::cell::RefCell'>RefCell</a></td>
                        <td class='docblock short'><p>A mutable memory location with dynamically checked borrow rules</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='struct' href='struct.RefMut.html'
                               title='core::cell::RefMut'>RefMut</a></td>
                        <td class='docblock short'><p>Wraps a mutable borrowed reference to a value in a <code>RefCell</code> box.</p>
</td>
                    </tr>
                </table><h2 id='functions' class='section-header'><a href="#functions">Functions</a></h2>
<table>
                    <tr>
                        <td><a class='stability Experimental' title='Experimental'></a><a class='fn' href='fn.clone_ref.html'
                               title='core::cell::clone_ref'>clone_ref</a></td>
                        <td class='docblock short'><p>Copy a <code>Ref</code>.</p>
</td>
                    </tr>
                </table></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <div id="help" class="hidden">
        <div class="shortcuts">
            <h1>Keyboard shortcuts</h1>
            <dl>
                <dt>?</dt>
                <dd>Show this help dialog</dd>
                <dt>S</dt>
                <dd>Focus the search field</dd>
                <dt>&larrb;</dt>
                <dd>Move up in search results</dd>
                <dt>&rarrb;</dt>
                <dd>Move down in search results</dd>
                <dt>&#9166;</dt>
                <dd>Go to active search result</dd>
            </dl>
        </div>
        <div class="infos">
            <h1>Search tricks</h1>
            <p>
                Prefix searches with a type followed by a colon (e.g.
                <code>fn:</code>) to restrict the search to a given type.
            </p>
            <p>
                Accepted types are: <code>fn</code>, <code>mod</code>,
                <code>struct</code> (or <code>str</code>), <code>enum</code>,
                <code>trait</code>, <code>typedef</code> (or
                <code>tdef</code>).
            </p>
        </div>
    </div>

    

    <script>
        window.rootPath = "../../";
        window.currentCrate = "core";
        window.playgroundUrl = "http://play.rust-lang.org/";
    </script>
    <script src="../../jquery.js"></script>
    <script src="../../main.js"></script>
    <script src="../../playpen.js"></script>
    <script async src="../../search-index.js"></script>
</body>
</html>